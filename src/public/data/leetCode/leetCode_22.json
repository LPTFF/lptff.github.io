[
    {
        "problemsName": " 1576.替换所有的问号",
        "hardRate": "EASY",
        "passRate": "50.94%",
        "problemsUrl": "https://leetcode.cn/problems/replace-all-s-to-avoid-consecutive-repeating-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-all-s-to-avoid-consecutive-repeating-characters/solution",
        "problemsDesc": "<p>给你一个仅包含小写英文字母和 <code>'?'</code> 字符的字符串 <code>s</code>，请你将所有的 <code>'?'</code> 转换为若干小写字母，使最终的字符串不包含任何 <strong>连续重复</strong> 的字符。</p>\n\n<p>注意：你 <strong>不能</strong> 修改非 <code>'?'</code> 字符。</p>\n\n<p>题目测试用例保证 <strong>除</strong> <code>'?'</code> 字符 <strong>之外</strong>，不存在连续重复的字符。</p>\n\n<p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"?zs\"\n<strong>输出：</strong>\"azs\"\n<strong>解释：</strong>该示例共有 25 种解决方案，从 \"azs\" 到 \"yzs\" 都是符合题目要求的。只有 \"z\" 是无效的修改，因为字符串 \"zzs\" 中有连续重复的两个 'z' 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ubv?w\"\n<strong>输出：</strong>\"ubvaw\"\n<strong>解释：</strong>该示例共有 24 种解决方案，只有替换成 \"v\" 和 \"w\" 不符合题目要求。因为 \"ubvvw\" 和 \"ubvww\" 都包含连续重复的字符。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>\n\t<p><code>1 &lt;= s.length&nbsp;&lt;= 100</code></p>\n\t</li>\n\t<li>\n\t<p><code>s</code> 仅包含小写英文字母和 <code>'?'</code> 字符</p>\n\t</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1577.数的平方等于两数乘积的方法数",
        "hardRate": "MEDIUM",
        "passRate": "34.62%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你返回根据以下规则形成的三元组的数目（类型 1 和类型 2 ）：</p>\n\n<ul>\n\t<li>类型 1：三元组 <code>(i, j, k)</code> ，如果 <code>nums1[i]<sup>2</sup>&nbsp;== nums2[j] * nums2[k]</code> 其中 <code>0 &lt;= i &lt; nums1.length</code> 且 <code>0 &lt;= j &lt; k &lt; nums2.length</code></li>\n\t<li>类型 2：三元组 <code>(i, j, k)</code> ，如果 <code>nums2[i]<sup>2</sup>&nbsp;== nums1[j] * nums1[k]</code> 其中 <code>0 &lt;= i &lt; nums2.length</code> 且 <code>0 &lt;= j &lt; k &lt; nums1.length</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [7,4], nums2 = [5,2,8,9]\n<strong>输出：</strong>1\n<strong>解释：</strong>类型 1：(1,1,2), nums1[1]^2 = nums2[1] * nums2[2] (4^2 = 2 * 8)</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [1,1], nums2 = [1,1,1]\n<strong>输出：</strong>9\n<strong>解释：</strong>所有三元组都符合题目要求，因为 1^2 = 1 * 1\n类型 1：(0,0,1), (0,0,2), (0,1,2), (1,0,1), (1,0,2), (1,1,2), nums1[i]^2 = nums2[j] * nums2[k]\n类型 2：(0,0,1), (1,0,1), (2,0,1), nums2[i]^2 = nums1[j] * nums1[k]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [7,7,8,3], nums2 = [1,2,9,7]\n<strong>输出：</strong>2\n<strong>解释：</strong>有两个符合题目要求的三元组\n类型 1：(3,0,2), nums1[3]^2 = nums2[0] * nums2[2]\n类型 2：(3,0,1), nums2[3]^2 = nums1[0] * nums1[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [4,7,9,11,23], nums2 = [3,5,1024,12,18]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在符合题目要求的三元组\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1578.使绳子变成彩色的最短时间",
        "hardRate": "MEDIUM",
        "passRate": "59.65%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-make-rope-colorful/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-make-rope-colorful/solution",
        "problemsDesc": "<p>Alice 把 <code>n</code> 个气球排列在一根绳子上。给你一个下标从 <strong>0</strong> 开始的字符串 <code>colors</code> ，其中 <code>colors[i]</code> 是第 <code>i</code> 个气球的颜色。</p>\n\n<p>Alice 想要把绳子装扮成 <strong>彩色</strong> ，且她不希望两个连续的气球涂着相同的颜色，所以她喊来 Bob 帮忙。Bob 可以从绳子上移除一些气球使绳子变成 <strong>彩色</strong> 。给你一个下标从 <strong>0</strong> 开始的整数数组 <code>neededTime</code> ，其中 <code>neededTime[i]</code> 是 Bob 从绳子上移除第 <code>i</code> 个气球需要的时间（以秒为单位）。</p>\n\n<p>返回 Bob 使绳子变成 <strong>彩色</strong> 需要的 <strong>最少时间</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/13/ballon1.jpg\" style=\"width: 404px; height: 243px;\" />\n<pre>\n<strong>输入：</strong>colors = \"abaac\", neededTime = [1,2,3,4,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>在上图中，'a' 是蓝色，'b' 是红色且 'c' 是绿色。\nBob 可以移除下标 2 的蓝色气球。这将花费 3 秒。\n移除后，不存在两个连续的气球涂着相同的颜色。总时间 = 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/13/balloon2.jpg\" style=\"width: 244px; height: 243px;\" />\n<pre>\n<strong>输入：</strong>colors = \"abc\", neededTime = [1,2,3]\n<strong>输出：</strong>0\n<strong>解释：</strong>绳子已经是彩色的，Bob 不需要从绳子上移除任何气球。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/13/balloon3.jpg\" style=\"width: 404px; height: 243px;\" />\n<pre>\n<strong>输入：</strong>colors = \"aabaa\", neededTime = [1,2,3,4,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>Bob 会移除下标 0 和下标 4 处的气球。这两个气球各需要 1 秒来移除。\n移除后，不存在两个连续的气球涂着相同的颜色。总时间 = 1 + 1 = 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == colors.length == neededTime.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= neededTime[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>colors</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1579.保证图可完全遍历",
        "hardRate": "HARD",
        "passRate": "62.07%",
        "problemsUrl": "https://leetcode.cn/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/solution",
        "problemsDesc": "<p>Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3&nbsp; 种类型的边：</p>\n\n<ul>\n\t<li>类型 1：只能由 Alice 遍历。</li>\n\t<li>类型 2：只能由 Bob 遍历。</li>\n\t<li>类型 3：Alice 和 Bob 都可以遍历。</li>\n</ul>\n\n<p>给你一个数组 <code>edges</code> ，其中 <code>edges[i] = [type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>]</code>&nbsp;表示节点 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 之间存在类型为 <code>type<sub>i</sub></code> 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。</p>\n\n<p>返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex1.png\" style=\"height: 191px; width: 179px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]\n<strong>输出：</strong>2\n<strong>解释：</strong>如果删除<strong> </strong>[1,1,2] 和 [1,1,3] 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历。所以可以删除的最大边数是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex2.png\" style=\"height: 190px; width: 178px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]\n<strong>输出：</strong>0\n<strong>解释：</strong>注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex3.png\" style=\"height: 190px; width: 178px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>在当前图中，Alice 无法从其他节点到达节点 4 。类似地，Bob 也不能达到节点 1 。因此，图无法完全遍历。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(10^5, 3 * n * (n-1) / 2)</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>1 &lt;= edges[i][0] &lt;= 3</code></li>\n\t<li><code>1 &lt;= edges[i][1] &lt; edges[i][2] &lt;= n</code></li>\n\t<li>所有元组 <code>(type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>)</code> 互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1580.把箱子放进仓库里 II",
        "hardRate": "MEDIUM",
        "passRate": "59.63%",
        "problemsUrl": "https://leetcode.cn/problems/put-boxes-into-the-warehouse-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/put-boxes-into-the-warehouse-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1581.进店却未进行过交易的顾客",
        "hardRate": "EASY",
        "passRate": "79.33%",
        "problemsUrl": "https://leetcode.cn/problems/customer-who-visited-but-did-not-make-any-transactions/",
        "solutionsUrl": "https://leetcode.cn/problems/customer-who-visited-but-did-not-make-any-transactions/solution",
        "problemsDesc": "<p>表：<code>Visits</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| visit_id    | int     |\n| customer_id | int     |\n+-------------+---------+\nvisit_id 是该表的主键。\n该表包含有关光临过购物中心的顾客的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表：<code>Transactions</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| transaction_id | int     |\n| visit_id       | int     |\n| amount         | int     |\n+----------------+---------+\ntransaction_id 是此表的主键。\n此表包含 visit_id 期间进行的交易的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>有一些顾客可能光顾了购物中心但没有进行交易。请你编写一个 SQL 查询，来查找这些顾客的 ID ，以及他们只光顾不交易的次数。</p>\n\n<p>返回以 <strong>任何顺序</strong> 排序的结果表。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<code><strong>输入:</strong>\nVisits</code>\n+----------+-------------+\n| visit_id | customer_id |\n+----------+-------------+\n| 1        | 23          |\n| 2        | 9           |\n| 4        | 30          |\n| 5        | 54          |\n| 6        | 96          |\n| 7        | 54          |\n| 8        | 54          |\n+----------+-------------+\n<code>Transactions</code>\n+----------------+----------+--------+\n| transaction_id | visit_id | amount |\n+----------------+----------+--------+\n| 2              | 5        | 310    |\n| 3              | 5        | 300    |\n| 9              | 5        | 200    |\n| 12             | 1        | 910    |\n| 13             | 2        | 970    |\n+----------------+----------+--------+\n<b>输出:</b>\n+-------------+----------------+\n| customer_id | count_no_trans |\n+-------------+----------------+\n| 54          | 2              |\n| 30          | 1              |\n| 96          | 1              |\n+-------------+----------------+\n<b>解释:</b>\nID = 23 的顾客曾经逛过一次购物中心，并在 ID = 12 的访问期间进行了一笔交易。\nID = 9 的顾客曾经逛过一次购物中心，并在 ID = 13 的访问期间进行了一笔交易。\nID = 30 的顾客曾经去过购物中心，并且没有进行任何交易。\nID = 54 的顾客三度造访了购物中心。在 2 次访问中，他们没有进行任何交易，在 1 次访问中，他们进行了 3 次交易。\nID = 96 的顾客曾经去过购物中心，并且没有进行任何交易。\n如我们所见，ID 为 30 和 96 的顾客一次没有进行任何交易就去了购物中心。顾客 54 也两次访问了购物中心并且没有进行任何交易。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1582.二进制矩阵中的特殊位置",
        "hardRate": "EASY",
        "passRate": "69.48%",
        "problemsUrl": "https://leetcode.cn/problems/special-positions-in-a-binary-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/special-positions-in-a-binary-matrix/solution",
        "problemsDesc": "<p>给你一个大小为 <code>rows x cols</code> 的矩阵 <code>mat</code>，其中 <code>mat[i][j]</code> 是 <code>0</code> 或 <code>1</code>，请返回 <strong>矩阵&nbsp;<em><code>mat</code></em> 中特殊位置的数目</strong> 。</p>\n\n<p><strong>特殊位置</strong> 定义：如果 <code>mat[i][j] == 1</code> 并且第 <code>i</code> 行和第 <code>j</code> 列中的所有其他元素均为 <code>0</code>（行和列的下标均 <strong>从 0 开始</strong> ），则位置 <code>(i, j)</code> 被称为特殊位置。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[1,0,0],\n&nbsp;           [0,0,<strong>1</strong>],\n&nbsp;           [1,0,0]]\n<strong>输出：</strong>1\n<strong>解释：</strong>(1,2) 是一个特殊位置，因为 mat[1][2] == 1 且所处的行和列上所有其他元素都是 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[<strong>1</strong>,0,0],\n&nbsp;           [0,<strong>1</strong>,0],\n&nbsp;           [0,0,<strong>1</strong>]]\n<strong>输出：</strong>3\n<strong>解释：</strong>(0,0), (1,1) 和 (2,2) 都是特殊位置\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[0,0,0,<strong>1</strong>],\n&nbsp;           [<strong>1</strong>,0,0,0],\n&nbsp;           [0,1,1,0],\n&nbsp;           [0,0,0,0]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[0,0,0,0,0],\n&nbsp;           [<strong>1</strong>,0,0,0,0],\n&nbsp;           [0,<strong>1</strong>,0,0,0],\n&nbsp;           [0,0,<strong>1</strong>,0,0],\n&nbsp;           [0,0,0,1,1]]\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == mat.length</code></li>\n\t<li><code>cols == mat[i].length</code></li>\n\t<li><code>1 &lt;= rows, cols &lt;= 100</code></li>\n\t<li><code>mat[i][j]</code> 是 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1583.统计不开心的朋友",
        "hardRate": "MEDIUM",
        "passRate": "67.92%",
        "problemsUrl": "https://leetcode.cn/problems/count-unhappy-friends/",
        "solutionsUrl": "https://leetcode.cn/problems/count-unhappy-friends/solution",
        "problemsDesc": "<p>给你一份 <code>n</code> 位朋友的亲近程度列表，其中 <code>n</code> 总是 <strong>偶数</strong> 。</p>\n\n<p>对每位朋友 <code>i</code>，<code>preferences[i]</code> 包含一份 <strong>按亲近程度从高</strong><strong>到低排列</strong> 的朋友列表。换句话说，排在列表前面的朋友与 <code>i</code> 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 <code>0</code> 到 <code>n-1</code> 之间的整数表示。</p>\n\n<p>所有的朋友被分成几对，配对情况以列表 <code>pairs</code> 给出，其中 <code>pairs[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示 <code>x<sub>i</sub></code> 与 <code>y<sub>i</sub></code> 配对，且 <code>y<sub>i</sub></code> 与 <code>x<sub>i</sub></code> 配对。</p>\n\n<p>但是，这样的配对情况可能会使其中部分朋友感到不开心。在 <code>x</code> 与 <code>y</code> 配对且 <code>u</code> 与 <code>v</code> 配对的情况下，如果同时满足下述两个条件，<code>x</code> 就会不开心：</p>\n\n<ul>\n\t<li><code>x</code> 与 <code>u</code> 的亲近程度胜过 <code>x</code> 与 <code>y</code>，且</li>\n\t<li><code>u</code> 与 <code>x</code> 的亲近程度胜过 <code>u</code> 与 <code>v</code></li>\n</ul>\n\n<p>返回 <strong>不开心的朋友的数目</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n朋友 1 不开心，因为：\n- <strong>1 与 0 </strong>配对，但 <strong>1 与 3</strong> 的亲近程度比 <strong>1 与 0</strong> 高，且\n- <strong>3 与 1</strong> 的亲近程度比 <strong>3 与 2</strong> 高。\n朋友 3 不开心，因为：\n- 3 与 2 配对，但 <strong>3 与 1</strong> 的亲近程度比 <strong>3 与 2</strong> 高，且\n- <strong>1 与 3</strong> 的亲近程度比 <strong>1 与 0</strong> 高。\n朋友 0 和 2 都是开心的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, preferences = [[1], [0]], pairs = [[1, 0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>朋友 0 和 1 都开心。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 500</code></li>\n\t<li><code>n</code> 是偶数</li>\n\t<li><code>preferences.length&nbsp;== n</code></li>\n\t<li><code>preferences[i].length&nbsp;== n - 1</code></li>\n\t<li><code>0 &lt;= preferences[i][j] &lt;= n - 1</code></li>\n\t<li><code>preferences[i]</code> 不包含 <code>i</code></li>\n\t<li><code>preferences[i]</code> 中的所有值都是独一无二的</li>\n\t<li><code>pairs.length&nbsp;== n/2</code></li>\n\t<li><code>pairs[i].length&nbsp;== 2</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li>每位朋友都 <strong>恰好</strong> 被包含在一对中</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1584.连接所有点的最小费用",
        "hardRate": "MEDIUM",
        "passRate": "65.57%",
        "problemsUrl": "https://leetcode.cn/problems/min-cost-to-connect-all-points/",
        "solutionsUrl": "https://leetcode.cn/problems/min-cost-to-connect-all-points/solution",
        "problemsDesc": "<p>给你一个<code>points</code>&nbsp;数组，表示 2D 平面上的一些点，其中&nbsp;<code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>连接点&nbsp;<code>[x<sub>i</sub>, y<sub>i</sub>]</code> 和点&nbsp;<code>[x<sub>j</sub>, y<sub>j</sub>]</code>&nbsp;的费用为它们之间的 <strong>曼哈顿距离</strong>&nbsp;：<code>|x<sub>i</sub> - x<sub>j</sub>| + |y<sub>i</sub> - y<sub>j</sub>|</code>&nbsp;，其中&nbsp;<code>|val|</code>&nbsp;表示&nbsp;<code>val</code>&nbsp;的绝对值。</p>\n\n<p>请你返回将所有点连接的最小总费用。只有任意两点之间 <strong>有且仅有</strong>&nbsp;一条简单路径时，才认为所有点都已连接。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/26/d.png\" style=\"height:268px; width:214px; background:#e5e5e5\" /></p>\n\n<pre>\n<strong>输入：</strong>points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\n<strong>输出：</strong>20\n<strong>解释：\n</strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/26/c.png\" style=\"height:268px; width:214px; background:#e5e5e5\" />\n我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。\n注意到任意两个点之间只有唯一一条路径互相到达。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[3,12],[-2,5],[-4,1]]\n<strong>输出：</strong>18\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[0,0],[1,1],[1,0],[-1,1]]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[-1000000,-1000000],[1000000,1000000]]\n<strong>输出：</strong>4000000\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[0,0]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 1000</code></li>\n\t<li><code>-10<sup>6</sup>&nbsp;&lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n\t<li>所有点&nbsp;<code>(x<sub>i</sub>, y<sub>i</sub>)</code>&nbsp;两两不同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1585.检查字符串是否可以通过排序子字符串得到另一个字符串",
        "hardRate": "HARD",
        "passRate": "43.45%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-string-is-transformable-with-substring-sort-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-string-is-transformable-with-substring-sort-operations/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s</code> 和&nbsp;<code>t</code>&nbsp;，请你通过若干次以下操作将字符串&nbsp;<code>s</code>&nbsp;转化成字符串&nbsp;<code>t</code>&nbsp;：</p>\n\n<ul>\n\t<li>选择 <code>s</code>&nbsp;中一个 <strong>非空</strong>&nbsp;子字符串并将它包含的字符就地 <strong>升序</strong>&nbsp;排序。</li>\n</ul>\n\n<p>比方说，对下划线所示的子字符串进行操作可以由&nbsp;<code>&quot;1<strong>4234</strong>&quot;</code>&nbsp;得到&nbsp;<code>&quot;1<strong>2344</strong>&quot;</code>&nbsp;。</p>\n\n<p>如果可以将字符串 <code>s</code>&nbsp;变成 <code>t</code>&nbsp;，返回 <code>true</code>&nbsp;。否则，返回 <code>false</code>&nbsp;。</p>\n\n<p>一个 <strong>子字符串</strong>&nbsp;定义为一个字符串中连续的若干字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;84532&quot;, t = &quot;34852&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以按以下操作将 s 转变为 t ：\n&quot;84<strong>53</strong>2&quot; （从下标 2 到下标 3）-&gt; &quot;84<strong>35</strong>2&quot;\n&quot;<strong>843</strong>52&quot; （从下标 0 到下标 2） -&gt; &quot;<strong>348</strong>52&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;34521&quot;, t = &quot;23415&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以按以下操作将 s 转变为 t ：\n&quot;<strong>3452</strong>1&quot; -&gt; &quot;<strong>2345</strong>1&quot;\n&quot;234<strong>51</strong>&quot; -&gt; &quot;234<strong>15</strong>&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;12345&quot;, t = &quot;12435&quot;\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;1&quot;, t = &quot;2&quot;\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s.length == t.length</code></li>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和&nbsp;<code>t</code>&nbsp;都只包含数字字符，即&nbsp;<code>&#39;0&#39;</code>&nbsp;到&nbsp;<code>&#39;9&#39;</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1586.二叉搜索树迭代器 II",
        "hardRate": "MEDIUM",
        "passRate": "63.05%",
        "problemsUrl": "https://leetcode.cn/problems/binary-search-tree-iterator-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-search-tree-iterator-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1587.银行账户概要 II",
        "hardRate": "EASY",
        "passRate": "80.07%",
        "problemsUrl": "https://leetcode.cn/problems/bank-account-summary-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/bank-account-summary-ii/solution",
        "problemsDesc": "<p>表: <code>Users</code></p>\n\n<pre>+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| account      | int     |\n| name         | varchar |\n+--------------+---------+\naccount 是该表的主键.\n表中的每一行包含银行里中每一个用户的账号.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表: <code>Transactions</code></p>\n\n<pre>+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| trans_id      | int     |\n| account       | int     |\n| amount        | int     |\n| transacted_on | date    |\n+---------------+---------+\ntrans_id 是该表主键.\n该表的每一行包含了所有账户的交易改变情况.\n如果用户收到了钱, 那么金额是正的; 如果用户转了钱, 那么金额是负的.\n所有账户的起始余额为 0.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一个 SQL,&nbsp;&nbsp;报告余额高于 10000 的所有用户的名字和余额.&nbsp;账户的余额等于包含该账户的所有交易的总和.</p>\n\n<p>返回结果表单没有顺序要求.</p>\n\n<p>查询结果格式如下例所示.</p>\n\n<p>&nbsp;</p>\n\n<pre><code>Users</code> table:\n+------------+--------------+\n| account    | name         |\n+------------+--------------+\n| 900001     | Alice        |\n| 900002     | Bob          |\n| 900003     | Charlie      |\n+------------+--------------+\n\n<code>Transactions</code> table:\n+------------+------------+------------+---------------+\n| trans_id   | account    | amount     | transacted_on |\n+------------+------------+------------+---------------+\n| 1          | 900001     | 7000       |  2020-08-01   |\n| 2          | 900001     | 7000       |  2020-09-01   |\n| 3          | 900001     | -3000      |  2020-09-02   |\n| 4          | 900002     | 1000       |  2020-09-12   |\n| 5          | 900003     | 6000       |  2020-08-07   |\n| 6          | 900003     | 6000       |  2020-09-07   |\n| 7          | 900003     | -4000      |  2020-09-11   |\n+------------+------------+------------+---------------+\n\nResult table:\n+------------+------------+\n| <code>name    </code>   | <code>balance  </code>  |\n+------------+------------+\n| Alice      | 11000      |\n+------------+------------+\nAlice 的余额为(7000 + 7000 - 3000) = 11000.\nBob 的余额为1000.\nCharlie 的余额为(6000 + 6000 - 4000) = 8000.\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1588.所有奇数长度子数组的和",
        "hardRate": "EASY",
        "passRate": "83.22%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-all-odd-length-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-all-odd-length-subarrays/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>arr</code>&nbsp;，请你计算所有可能的奇数长度子数组的和。</p>\n\n<p><strong>子数组</strong> 定义为原数组中的一个连续子序列。</p>\n\n<p>请你返回 <code>arr</code>&nbsp;中 <strong>所有奇数长度子数组的和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,4,2,5,3]\n<strong>输出：</strong>58\n<strong>解释：</strong>所有奇数长度子数组和它们的和为：\n[1] = 1\n[4] = 4\n[2] = 2\n[5] = 5\n[3] = 3\n[1,4,2] = 7\n[4,2,5] = 11\n[2,5,3] = 10\n[1,4,2,5,3] = 15\n我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [10,11,12]\n<strong>输出：</strong>66\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你可以设计一个 O(n) 时间复杂度的算法解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1589.所有排列中的最大和",
        "hardRate": "MEDIUM",
        "passRate": "32.40%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-obtained-of-any-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-obtained-of-any-permutation/solution",
        "problemsDesc": "<p>有一个整数数组&nbsp;<code>nums</code>&nbsp;，和一个查询数组&nbsp;<code>requests</code>&nbsp;，其中&nbsp;<code>requests[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;。第&nbsp;<code>i</code>&nbsp;个查询求&nbsp;<code>nums[start<sub>i</sub>] + nums[start<sub>i</sub> + 1] + ... + nums[end<sub>i</sub> - 1] + nums[end<sub>i</sub>]</code>&nbsp;的结果&nbsp;，<code>start<sub>i</sub></code> 和&nbsp;<code>end<sub>i</sub></code>&nbsp;数组索引都是 <strong>从 0 开始</strong> 的。</p>\n\n<p>你可以任意排列 <code>nums</code>&nbsp;中的数字，请你返回所有查询结果之和的最大值。</p>\n\n<p>由于答案可能会很大，请你将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5], requests = [[1,3],[0,1]]\n<strong>输出：</strong>19\n<strong>解释：</strong>一个可行的 nums 排列为 [2,1,3,4,5]，并有如下结果：\nrequests[0] -&gt; nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8\nrequests[1] -&gt; nums[0] + nums[1] = 2 + 1 = 3\n总和为：8 + 3 = 11。\n一个总和更大的排列为 [3,5,4,2,1]，并有如下结果：\nrequests[0] -&gt; nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11\nrequests[1] -&gt; nums[0] + nums[1] = 3 + 5  = 8\n总和为： 11 + 8 = 19，这个方案是所有排列中查询之和最大的结果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5,6], requests = [[0,1]]\n<strong>输出：</strong>11\n<strong>解释：</strong>一个总和最大的排列为 [6,5,4,3,2,1] ，查询和为 [11]。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]\n<strong>输出：</strong>47\n<strong>解释：</strong>一个和最大的排列为 [4,10,5,3,2,1] ，查询结果分别为 [19,18,10]。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= requests.length &lt;=&nbsp;10<sup>5</sup></code></li>\n\t<li><code>requests[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub>&nbsp;&lt;= end<sub>i</sub>&nbsp;&lt;&nbsp;n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1590.使数组和能被 P 整除",
        "hardRate": "MEDIUM",
        "passRate": "36.38%",
        "problemsUrl": "https://leetcode.cn/problems/make-sum-divisible-by-p/",
        "solutionsUrl": "https://leetcode.cn/problems/make-sum-divisible-by-p/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>nums</code>，请你移除 <strong>最短</strong>&nbsp;子数组（可以为 <strong>空</strong>），使得剩余元素的 <strong>和</strong>&nbsp;能被 <code>p</code>&nbsp;整除。 <strong>不允许</strong>&nbsp;将整个数组都移除。</p>\n\n<p>请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 <code>-1</code>&nbsp;。</p>\n\n<p><strong>子数组</strong>&nbsp;定义为原数组中连续的一组元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,1,4,2], p = 6\n<strong>输出：</strong>1\n<strong>解释：</strong>nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [6,3,5,2], p = 9\n<strong>输出：</strong>2\n<strong>解释：</strong>我们无法移除任何一个元素使得和被 9 整除，最优方案是移除子数组 [5,2] ，剩余元素为 [6,3]，和为 9 。\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3], p = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>和恰好为 6 ，已经能被 3 整除了。所以我们不需要移除任何元素。\n</pre>\n\n<p><strong>示例&nbsp; 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3], p = 7\n<strong>输出：</strong>-1\n<strong>解释：</strong>没有任何方案使得移除子数组后剩余元素的和被 7 整除。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1000000000,1000000000,1000000000], p = 3\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= p &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1591.奇怪的打印机 II",
        "hardRate": "HARD",
        "passRate": "63.76%",
        "problemsUrl": "https://leetcode.cn/problems/strange-printer-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/strange-printer-ii/solution",
        "problemsDesc": "<p>给你一个奇怪的打印机，它有如下两个特殊的打印规则：</p>\n\n<ul>\n\t<li>每一次操作时，打印机会用同一种颜色打印一个矩形的形状，每次打印会覆盖矩形对应格子里原本的颜色。</li>\n\t<li>一旦矩形根据上面的规则使用了一种颜色，那么 <strong>相同的颜色不能再被使用&nbsp;</strong>。</li>\n</ul>\n\n<p>给你一个初始没有颜色的&nbsp;<code>m x n</code>&nbsp;的矩形&nbsp;<code>targetGrid</code>&nbsp;，其中&nbsp;<code>targetGrid[row][col]</code>&nbsp;是位置&nbsp;<code>(row, col)</code>&nbsp;的颜色。</p>\n\n<p>如果你能按照上述规则打印出矩形<em>&nbsp;</em><code>targetGrid</code>&nbsp;，请你返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/19/sample_1_1929.png\" style=\"height: 138px; width: 483px;\"></p>\n\n<pre><strong>输入：</strong>targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/19/sample_2_1929.png\" style=\"height: 290px; width: 483px;\"></p>\n\n<pre><strong>输入：</strong>targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>targetGrid = [[1,2,1],[2,1,2],[1,2,1]]\n<strong>输出：</strong>false\n<strong>解释：</strong>没有办法得到 targetGrid ，因为每一轮操作使用的颜色互不相同。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>targetGrid = [[1,1,1],[3,1,3]]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == targetGrid.length</code></li>\n\t<li><code>n == targetGrid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 60</code></li>\n\t<li><code>1 &lt;= targetGrid[row][col] &lt;= 60</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1592.重新排列单词间的空格",
        "hardRate": "EASY",
        "passRate": "46.71%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-spaces-between-words/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-spaces-between-words/solution",
        "problemsDesc": "<p>给你一个字符串 <code>text</code> ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 <code>text</code> <strong>至少包含一个单词</strong> 。</p>\n\n<p>请你重新排列空格，使每对相邻单词之间的空格数目都 <strong>相等</strong> ，并尽可能 <strong>最大化</strong> 该数目。如果不能重新平均分配所有空格，请 <strong>将多余的空格放置在字符串末尾</strong> ，这也意味着返回的字符串应当与原 <code>text</code> 字符串的长度相等。</p>\n\n<p>返回 <strong>重新排列空格后的字符串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;  this   is  a sentence &quot;\n<strong>输出：</strong>&quot;this   is   a   sentence&quot;\n<strong>解释：</strong>总共有 9 个空格和 4 个单词。可以将 9 个空格平均分配到相邻单词之间，相邻单词间空格数为：9 / (4-1) = 3 个。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot; practice   makes   perfect&quot;\n<strong>输出：</strong>&quot;practice   makes   perfect &quot;\n<strong>解释：</strong>总共有 7 个空格和 3 个单词。7 / (3-1) = 3 个空格加上 1 个多余的空格。多余的空格需要放在字符串的末尾。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;hello   world&quot;\n<strong>输出：</strong>&quot;hello   world&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;  walks  udp package   into  bar a&quot;\n<strong>输出：</strong>&quot;walks  udp  package  into  bar  a &quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;a&quot;\n<strong>输出：</strong>&quot;a&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 100</code></li>\n\t<li><code>text</code> 由小写英文字母和 <code>&#39; &#39;</code> 组成</li>\n\t<li><code>text</code> 中至少包含一个单词</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1593.拆分字符串使唯一子字符串的数目最大",
        "hardRate": "MEDIUM",
        "passRate": "57.48%",
        "problemsUrl": "https://leetcode.cn/problems/split-a-string-into-the-max-number-of-unique-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/split-a-string-into-the-max-number-of-unique-substrings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，请你拆分该字符串，并返回拆分后唯一子字符串的最大数目。</p>\n\n<p>字符串 <code>s</code> 拆分后可以得到若干 <strong>非空子字符串</strong> ，这些子字符串连接后应当能够还原为原字符串。但是拆分出来的每个子字符串都必须是 <strong>唯一的</strong> 。</p>\n\n<p>注意：<strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;ababccc&quot;\n<strong>输出：</strong>5\n<strong>解释：</strong>一种最大拆分方法为 [&#39;a&#39;, &#39;b&#39;, &#39;ab&#39;, &#39;c&#39;, &#39;cc&#39;] 。像 [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;cc&#39;] 这样拆分不满足题目要求，因为其中的 &#39;a&#39; 和 &#39;b&#39; 都出现了不止一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aba&quot;\n<strong>输出：</strong>2\n<strong>解释：</strong>一种最大拆分方法为 [&#39;a&#39;, &#39;ba&#39;] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aa&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>无法进一步拆分字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>\n\t<p><code>1 &lt;= s.length&nbsp;&lt;= 16</code></p>\n\t</li>\n\t<li>\n\t<p><code>s</code> 仅包含小写英文字母</p>\n\t</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1594.矩阵的最大非负积",
        "hardRate": "MEDIUM",
        "passRate": "33.79%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-non-negative-product-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-non-negative-product-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的矩阵 <code>grid</code> 。最初，你位于左上角 <code>(0, 0)</code> ，每一步，你可以在矩阵中 <strong>向右</strong> 或 <strong>向下</strong> 移动。</p>\n\n<p>在从左上角 <code>(0, 0)</code> 开始到右下角 <code>(m - 1, n - 1)</code> 结束的所有路径中，找出具有 <strong>最大非负积</strong> 的路径。路径的积是沿路径访问的单元格中所有整数的乘积。</p>\n\n<p>返回 <strong>最大非负积 </strong>对<strong><em> </em><code>10<sup>9</sup>&nbsp;+ 7</code></strong> <strong>取余</strong> 的结果。如果最大积为 <strong>负数</strong> ，则返回<em> </em><code>-1</code> 。</p>\n\n<p><strong>注意，</strong>取余是在得到最大积之后执行的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/23/product1.jpg\" style=\"width: 244px; height: 245px;\" />\n<pre>\n<strong>输入：</strong>grid = [[-1,-2,-3],[-2,-3,-3],[-3,-3,-2]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>从 (0, 0) 到 (2, 2) 的路径中无法得到非负积，所以返回 -1 。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/23/product2.jpg\" style=\"width: 244px; height: 245px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,-2,1],[1,-2,1],[3,-4,1]]\n<strong>输出：</strong>8\n<strong>解释：</strong>最大非负积对应的路径如图所示 (1 * 1 * -2 * -4 * 1 = 8)\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/23/product3.jpg\" style=\"width: 164px; height: 165px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,3],[0,-4]]\n<strong>输出：</strong>0\n<strong>解释：</strong>最大非负积对应的路径如图所示 (1 * 0 * -4 = 0)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 15</code></li>\n\t<li><code>-4 &lt;= grid[i][j] &lt;= 4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1595.连通两组点的最小成本",
        "hardRate": "HARD",
        "passRate": "65.76%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-connect-two-groups-of-points/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-connect-two-groups-of-points/solution",
        "problemsDesc": "<p>给你两组点，其中第一组中有 <code>size<sub>1</sub></code> 个点，第二组中有 <code>size<sub>2</sub></code> 个点，且 <code>size<sub>1</sub> &gt;= size<sub>2</sub></code> 。</p>\n\n<p>任意两点间的连接成本 <code>cost</code> 由大小为 <code>size<sub>1</sub> x size<sub>2</sub></code> 矩阵给出，其中 <code>cost[i][j]</code> 是第一组中的点 <code>i</code> 和第二组中的点 <code>j</code> 的连接成本。<strong>如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是连通的。</strong>换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一组中的一个点连接。</p>\n\n<p>返回连通两组点所需的最小成本。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/20/ex1.jpg\" style=\"height: 243px; width: 322px;\"></p>\n\n<pre><strong>输入：</strong>cost = [[15, 96], [36, 2]]\n<strong>输出：</strong>17\n<strong>解释：</strong>连通两组点的最佳方法是：\n1--A\n2--B\n总成本为 17 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/20/ex2.jpg\" style=\"height: 403px; width: 322px;\"></p>\n\n<pre><strong>输入：</strong>cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]\n<strong>输出：</strong>4\n<strong>解释：</strong>连通两组点的最佳方法是：\n1--A\n2--B\n2--C\n3--A\n最小成本为 4 。\n请注意，虽然有多个点连接到第一组中的点 2 和第二组中的点 A ，但由于题目并不限制连接点的数目，所以只需要关心最低总成本。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]\n<strong>输出：</strong>10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>size<sub>1</sub> == cost.length</code></li>\n\t<li><code>size<sub>2</sub> == cost[i].length</code></li>\n\t<li><code>1 &lt;= size<sub>1</sub>, size<sub>2</sub> &lt;= 12</code></li>\n\t<li><code>size<sub>1</sub> &gt;=&nbsp;size<sub>2</sub></code></li>\n\t<li><code>0 &lt;= cost[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1596.每位顾客最经常订购的商品",
        "hardRate": "MEDIUM",
        "passRate": "73.42%",
        "problemsUrl": "https://leetcode.cn/problems/the-most-frequently-ordered-products-for-each-customer/",
        "solutionsUrl": "https://leetcode.cn/problems/the-most-frequently-ordered-products-for-each-customer/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1597.根据中缀表达式构造二叉表达式树",
        "hardRate": "HARD",
        "passRate": "68.36%",
        "problemsUrl": "https://leetcode.cn/problems/build-binary-expression-tree-from-infix-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/build-binary-expression-tree-from-infix-expression/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1598.文件夹操作日志搜集器",
        "hardRate": "EASY",
        "passRate": "69.53%",
        "problemsUrl": "https://leetcode.cn/problems/crawler-log-folder/",
        "solutionsUrl": "https://leetcode.cn/problems/crawler-log-folder/solution",
        "problemsDesc": "<p>每当用户执行变更文件夹操作时，LeetCode 文件系统都会保存一条日志记录。</p>\n\n<p>下面给出对变更操作的说明：</p>\n\n<ul>\n\t<li><code>&quot;../&quot;</code> ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 <strong>继续停留在当前文件夹</strong> 。</li>\n\t<li><code>&quot;./&quot;</code> ：继续停留在当前文件夹<strong>。</strong></li>\n\t<li><code>&quot;x/&quot;</code> ：移动到名为 <code>x</code> 的子文件夹中。题目数据 <strong>保证总是存在文件夹 <code>x</code></strong> 。</li>\n</ul>\n\n<p>给你一个字符串列表 <code>logs</code> ，其中 <code>logs[i]</code> 是用户在 <code>i<sup>th</sup></code> 步执行的操作。</p>\n\n<p>文件系统启动时位于主文件夹，然后执行 <code>logs</code> 中的操作。</p>\n\n<p>执行完所有变更文件夹操作后，请你找出 <strong>返回主文件夹所需的最小步数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/sample_11_1957.png\" style=\"height: 151px; width: 775px;\"></p>\n\n<pre><strong>输入：</strong>logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;../&quot;,&quot;d21/&quot;,&quot;./&quot;]\n<strong>输出：</strong>2\n<strong>解释：</strong>执行 &quot;../&quot; 操作变更文件夹 2 次，即可回到主文件夹\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/sample_22_1957.png\" style=\"height: 270px; width: 600px;\"></p>\n\n<pre><strong>输入：</strong>logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;./&quot;,&quot;d3/&quot;,&quot;../&quot;,&quot;d31/&quot;]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>logs = [&quot;d1/&quot;,&quot;../&quot;,&quot;../&quot;,&quot;../&quot;]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= logs.length &lt;= 10<sup>3</sup></code></li>\n\t<li><code>2 &lt;= logs[i].length &lt;= 10</code></li>\n\t<li><code>logs[i]</code> 包含小写英文字母，数字，<code>&#39;.&#39;</code> 和 <code>&#39;/&#39;</code></li>\n\t<li><code>logs[i]</code> 符合语句中描述的格式</li>\n\t<li>文件夹名称由小写英文字母和数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1599.经营摩天轮的最大利润",
        "hardRate": "MEDIUM",
        "passRate": "51.47%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-profit-of-operating-a-centennial-wheel/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-profit-of-operating-a-centennial-wheel/solution",
        "problemsDesc": "<p>你正在经营一座摩天轮，该摩天轮共有 <strong>4 个座舱</strong> ，每个座舱<strong> 最多可以容纳 4 位游客</strong> 。你可以 <strong>逆时针</strong>&nbsp;轮转座舱，但每次轮转都需要支付一定的运行成本 <code>runningCost</code> 。摩天轮每次轮转都恰好转动 1 / 4 周。</p>\n\n<p>给你一个长度为 <code>n</code> 的数组 <code>customers</code> ， <code>customers[i]</code> 是在第 <code>i</code> 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 <code>i</code> 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 <code>boardingCost</code> ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。</p>\n\n<p>你可以随时停下摩天轮，即便是 <strong>在服务所有游客之前</strong> 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，<strong>将免费进行</strong><strong>所有后续轮转</strong>&nbsp;。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 <strong>下一次轮转</strong> 。</p>\n\n<p>返回最大化利润所需执行的 <strong>最小轮转次数</strong> 。 如果不存在利润为正的方案，则返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/wheeldiagram12.png\" /></p>\n\n<pre>\n<strong>输入：</strong>customers = [8,3], boardingCost = 5, runningCost = 6\n<strong>输出：</strong>3\n<strong>解释：</strong>座舱上标注的数字是该座舱的当前游客数。\n1. 8 位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为 4 * $5 - 1 * $6 = $14 。\n2. 3 位游客抵达，4 位在等待的游客登舱，其他 3 位等待，摩天轮轮转。当前利润为 8 * $5 - 2 * $6 = $28 。\n3. 最后 3 位游客登舱，摩天轮轮转。当前利润为 11 * $5 - 3 * $6 = $37 。\n轮转 3 次得到最大利润，最大利润为 $37 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>customers = [10,9,6], boardingCost = 6, runningCost = 4\n<strong>输出：</strong>7\n<strong>解释：</strong>\n1. 10 位游客抵达，4 位登舱，6 位等待下一舱，摩天轮轮转。当前利润为 4 * $6 - 1 * $4 = $20 。\n2. 9 位游客抵达，4 位登舱，11 位等待（2 位是先前就在等待的，9 位新加入等待的），摩天轮轮转。当前利润为 8 * $6 - 2 * $4 = $40 。\n3. 最后 6 位游客抵达，4 位登舱，13 位等待，摩天轮轮转。当前利润为 12 * $6 - 3 * $4 = $60 。\n4. 4 位登舱，9 位等待，摩天轮轮转。当前利润为 * $6 - 4 * $4 = $80 。\n5. 4 位登舱，5 位等待，摩天轮轮转。当前利润为 20 * $6 - 5 * $4 = $100 。\n6. 4 位登舱，1 位等待，摩天轮轮转。当前利润为 24 * $6 - 6 * $4 = $120 。\n7. 1 位登舱，摩天轮轮转。当前利润为 25 * $6 - 7 * $4 = $122 。\n轮转 7 次得到最大利润，最大利润为$122 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n1. 3 位游客抵达，3 位登舱，0 位等待，摩天轮轮转。当前利润为 3 * $1 - 1 * $92 = -$89 。\n2. 4 位游客抵达，4 位登舱，0 位等待，摩天轮轮转。当前利润为 is 7 * $1 - 2 * $92 = -$177 。\n3. 0 位游客抵达，0 位登舱，0 位等待，摩天轮轮转。当前利润为 7 * $1 - 3 * $92 = -$269 。\n4. 5 位游客抵达，4 位登舱，1 位等待，摩天轮轮转。当前利润为 12 * $1 - 4 * $92 = -$356 。\n5. 1 位游客抵达，2 位登舱，0 位等待，摩天轮轮转。当前利润为 13 * $1 - 5 * $92 = -$447 。\n利润永不为正，所以返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == customers.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= customers[i] &lt;= 50</code></li>\n\t<li><code>1 &lt;= boardingCost, runningCost &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1600.王位继承顺序",
        "hardRate": "MEDIUM",
        "passRate": "65.66%",
        "problemsUrl": "https://leetcode.cn/problems/throne-inheritance/",
        "solutionsUrl": "https://leetcode.cn/problems/throne-inheritance/solution",
        "problemsDesc": "<p>一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。</p>\n\n<p>这个王国有一个明确规定的王位继承顺序，第一继承人总是国王自己。我们定义递归函数&nbsp;<code>Successor(x, curOrder)</code>&nbsp;，给定一个人&nbsp;<code>x</code>&nbsp;和当前的继承顺序，该函数返回 <code>x</code>&nbsp;的下一继承人。</p>\n\n<pre>\nSuccessor(x, curOrder):\n    如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：\n        如果 x 是国王，那么返回 null\n        否则，返回 Successor(x 的父亲, curOrder)\n    否则，返回 x 不在 curOrder 中最年长的孩子\n</pre>\n\n<p>比方说，假设王国由国王，他的孩子&nbsp;Alice 和 Bob （Alice 比 Bob&nbsp;年长）和 Alice 的孩子&nbsp;Jack 组成。</p>\n\n<ol>\n\t<li>一开始，&nbsp;<code>curOrder</code>&nbsp;为&nbsp;<code>[\"king\"]</code>.</li>\n\t<li>调用&nbsp;<code>Successor(king, curOrder)</code>&nbsp;，返回 Alice ，所以我们将 Alice 放入 <code>curOrder</code>&nbsp;中，得到&nbsp;<code>[\"king\", \"Alice\"]</code>&nbsp;。</li>\n\t<li>调用&nbsp;<code>Successor(Alice, curOrder)</code>&nbsp;，返回 Jack ，所以我们将 Jack 放入&nbsp;<code>curOrder</code>&nbsp;中，得到&nbsp;<code>[\"king\", \"Alice\", \"Jack\"]</code>&nbsp;。</li>\n\t<li>调用&nbsp;<code>Successor(Jack, curOrder)</code>&nbsp;，返回 Bob ，所以我们将 Bob 放入&nbsp;<code>curOrder</code>&nbsp;中，得到&nbsp;<code>[\"king\", \"Alice\", \"Jack\", \"Bob\"]</code>&nbsp;。</li>\n\t<li>调用&nbsp;<code>Successor(Bob, curOrder)</code>&nbsp;，返回&nbsp;<code>null</code>&nbsp;。最终得到继承顺序为&nbsp;<code>[\"king\", \"Alice\", \"Jack\", \"Bob\"]</code>&nbsp;。</li>\n</ol>\n\n<p>通过以上的函数，我们总是能得到一个唯一的继承顺序。</p>\n\n<p>请你实现&nbsp;<code>ThroneInheritance</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>ThroneInheritance(string kingName)</code> 初始化一个&nbsp;<code>ThroneInheritance</code>&nbsp;类的对象。国王的名字作为构造函数的参数传入。</li>\n\t<li><code>void birth(string parentName, string childName)</code>&nbsp;表示&nbsp;<code>parentName</code>&nbsp;新拥有了一个名为&nbsp;<code>childName</code>&nbsp;的孩子。</li>\n\t<li><code>void death(string name)</code>&nbsp;表示名为&nbsp;<code>name</code>&nbsp;的人死亡。一个人的死亡不会影响&nbsp;<code>Successor</code>&nbsp;函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。</li>\n\t<li><code>string[] getInheritanceOrder()</code>&nbsp;返回 <strong>除去</strong>&nbsp;死亡人员的当前继承顺序列表。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"ThroneInheritance\", \"birth\", \"birth\", \"birth\", \"birth\", \"birth\", \"birth\", \"getInheritanceOrder\", \"death\", \"getInheritanceOrder\"]\n[[\"king\"], [\"king\", \"andy\"], [\"king\", \"bob\"], [\"king\", \"catherine\"], [\"andy\", \"matthew\"], [\"bob\", \"alex\"], [\"bob\", \"asha\"], [null], [\"bob\"], [null]]\n<strong>输出：</strong>\n[null, null, null, null, null, null, null, [\"king\", \"andy\", \"matthew\", \"bob\", \"alex\", \"asha\", \"catherine\"], null, [\"king\", \"andy\", \"matthew\", \"alex\", \"asha\", \"catherine\"]]\n\n<strong>解释：</strong>\nThroneInheritance t= new ThroneInheritance(\"king\"); // 继承顺序：<strong>king</strong>\nt.birth(\"king\", \"andy\"); // 继承顺序：king &gt; <strong>andy</strong>\nt.birth(\"king\", \"bob\"); // 继承顺序：king &gt; andy &gt; <strong>bob</strong>\nt.birth(\"king\", \"catherine\"); // 继承顺序：king &gt; andy &gt; bob &gt; <strong>catherine</strong>\nt.birth(\"andy\", \"matthew\"); // 继承顺序：king &gt; andy &gt; <strong>matthew</strong> &gt; bob &gt; catherine\nt.birth(\"bob\", \"alex\"); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; <strong>alex</strong> &gt; catherine\nt.birth(\"bob\", \"asha\"); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; <strong>asha</strong> &gt; catherine\nt.getInheritanceOrder(); // 返回 [\"king\", \"andy\", \"matthew\", \"bob\", \"alex\", \"asha\", \"catherine\"]\nt.death(\"bob\"); // 继承顺序：king &gt; andy &gt; matthew &gt; <strong>bob（已经去世）</strong>&gt; alex &gt; asha &gt; catherine\nt.getInheritanceOrder(); // 返回 [\"king\", \"andy\", \"matthew\", \"alex\", \"asha\", \"catherine\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= kingName.length, parentName.length, childName.length, name.length &lt;= 15</code></li>\n\t<li><code>kingName</code>，<code>parentName</code>，&nbsp;<code>childName</code>&nbsp;和&nbsp;<code>name</code>&nbsp;仅包含小写英文字母。</li>\n\t<li>所有的参数&nbsp;<code>childName</code> 和&nbsp;<code>kingName</code>&nbsp;<strong>互不相同</strong>。</li>\n\t<li>所有&nbsp;<code>death</code>&nbsp;函数中的死亡名字 <code>name</code>&nbsp;要么是国王，要么是已经出生了的人员名字。</li>\n\t<li>每次调用 <code>birth(parentName, childName)</code> 时，测试用例都保证 <code>parentName</code> 对应的人员是活着的。</li>\n\t<li>最多调用&nbsp;<code>10<sup>5</sup></code>&nbsp;次<code>birth</code> 和&nbsp;<code>death</code>&nbsp;。</li>\n\t<li>最多调用&nbsp;<code>10</code>&nbsp;次&nbsp;<code>getInheritanceOrder</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1601.最多可达成的换楼请求数目",
        "hardRate": "HARD",
        "passRate": "61.89%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-achievable-transfer-requests/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-achievable-transfer-requests/solution",
        "problemsDesc": "<p>我们有&nbsp;<code>n</code>&nbsp;栋楼，编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。</p>\n\n<p>给你一个数组 <code>requests</code>&nbsp;，其中&nbsp;<code>requests[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;，表示一个员工请求从编号为&nbsp;<code>from<sub>i</sub></code>&nbsp;的楼搬到编号为&nbsp;<code>to<sub>i</sub></code><sub>&nbsp;</sub>的楼。</p>\n\n<p>一开始&nbsp;<strong>所有楼都是满的</strong>，所以从请求列表中选出的若干个请求是可行的需要满足 <strong>每栋楼员工净变化为 0&nbsp;</strong>。意思是每栋楼 <strong>离开</strong>&nbsp;的员工数目 <strong>等于</strong>&nbsp;该楼 <strong>搬入</strong>&nbsp;的员工数数目。比方说&nbsp;<code>n = 3</code>&nbsp;且两个员工要离开楼&nbsp;<code>0</code>&nbsp;，一个员工要离开楼&nbsp;<code>1</code>&nbsp;，一个员工要离开楼 <code>2</code>&nbsp;，如果该请求列表可行，应该要有两个员工搬入楼&nbsp;<code>0</code>&nbsp;，一个员工搬入楼&nbsp;<code>1</code>&nbsp;，一个员工搬入楼&nbsp;<code>2</code>&nbsp;。</p>\n\n<p>请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/move1.jpg\" style=\"height: 406px; width: 600px;\"></p>\n\n<pre><strong>输入：</strong>n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]\n<strong>输出：</strong>5\n<strong>解释：</strong>请求列表如下：\n从楼 0 离开的员工为 x 和 y ，且他们都想要搬到楼 1 。\n从楼 1 离开的员工为 a 和 b ，且他们分别想要搬到楼 2 和 0 。\n从楼 2 离开的员工为 z ，且他想要搬到楼 0 。\n从楼 3 离开的员工为 c ，且他想要搬到楼 4 。\n没有员工从楼 4 离开。\n我们可以让 x 和 b 交换他们的楼，以满足他们的请求。\n我们可以让 y，a 和 z 三人在三栋楼间交换位置，满足他们的要求。\n所以最多可以满足 5 个请求。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/move2.jpg\" style=\"height: 327px; width: 450px;\"></p>\n\n<pre><strong>输入：</strong>n = 3, requests = [[0,0],[1,2],[2,1]]\n<strong>输出：</strong>3\n<strong>解释：</strong>请求列表如下：\n从楼 0 离开的员工为 x ，且他想要回到原来的楼 0 。\n从楼 1 离开的员工为 y ，且他想要搬到楼 2 。\n从楼 2 离开的员工为 z ，且他想要搬到楼 1 。\n我们可以满足所有的请求。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>1 &lt;= requests.length &lt;= 16</code></li>\n\t<li><code>requests[i].length == 2</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1602.找到二叉树中最近的右侧节点",
        "hardRate": "MEDIUM",
        "passRate": "74.60%",
        "problemsUrl": "https://leetcode.cn/problems/find-nearest-right-node-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-nearest-right-node-in-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1603.设计停车系统",
        "hardRate": "EASY",
        "passRate": "83.77%",
        "problemsUrl": "https://leetcode.cn/problems/design-parking-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-parking-system/solution",
        "problemsDesc": "<p>请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。</p>\n\n<p>请你实现 <code>ParkingSystem</code> 类：</p>\n\n<ul>\n\t<li><code>ParkingSystem(int big, int medium, int small)</code> 初始化 <code>ParkingSystem</code> 类，三个参数分别对应每种停车位的数目。</li>\n\t<li><code>bool addCar(int carType)</code> 检查是否有 <code>carType</code> 对应的停车位。 <code>carType</code> 有三种类型：大，中，小，分别用数字 <code>1</code>， <code>2</code> 和 <code>3</code> 表示。<strong>一辆车只能停在</strong> <strong> </strong><code>carType</code> 对应尺寸的停车位中。如果没有空车位，请返回 <code>false</code> ，否则将该车停入车位并返回 <code>true</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"]\n[[1, 1, 0], [1], [2], [3], [1]]\n<strong>输出：</strong>\n[null, true, true, false, false]\n\n<strong>解释：</strong>\nParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);\nparkingSystem.addCar(1); // 返回 true ，因为有 1 个空的大车位\nparkingSystem.addCar(2); // 返回 true ，因为有 1 个空的中车位\nparkingSystem.addCar(3); // 返回 false ，因为没有空的小车位\nparkingSystem.addCar(1); // 返回 false ，因为没有空的大车位，唯一一个大车位已经被占据了\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= big, medium, small <= 1000</code></li>\n\t<li><code>carType</code> 取值为 <code>1</code>， <code>2</code> 或 <code>3</code></li>\n\t<li>最多会调用 <code>addCar</code> 函数 <code>1000</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1604.警告一小时内使用相同员工卡大于等于三次的人",
        "hardRate": "MEDIUM",
        "passRate": "50.38%",
        "problemsUrl": "https://leetcode.cn/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/",
        "solutionsUrl": "https://leetcode.cn/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/solution",
        "problemsDesc": "<p>力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 <strong>警告</strong>&nbsp;。</p>\n\n<p>给你字符串数组&nbsp;<code>keyName</code>&nbsp;和&nbsp;<code>keyTime</code> ，其中&nbsp;<code>[keyName[i], keyTime[i]]</code>&nbsp;对应一个人的名字和他在&nbsp;<strong>某一天</strong> 内使用员工卡的时间。</p>\n\n<p>使用时间的格式是 <strong>24小时制</strong>&nbsp;，形如<strong>&nbsp;\"HH:MM\"</strong>&nbsp;，比方说&nbsp;<code>\"23:51\"</code> 和&nbsp;<code>\"09:49\"</code>&nbsp;。</p>\n\n<p>请你返回去重后的收到系统警告的员工名字，将它们按 <strong>字典序</strong><strong>升序&nbsp;</strong>排序后返回。</p>\n\n<p>请注意&nbsp;<code>\"10:00\"</code> - <code>\"11:00\"</code>&nbsp;视为一个小时时间范围内，而&nbsp;<code>\"22:51\"</code> - <code>\"23:52\"</code>&nbsp;不被视为一小时时间范围内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>keyName = [\"daniel\",\"daniel\",\"daniel\",\"luis\",\"luis\",\"luis\",\"luis\"], keyTime = [\"10:00\",\"10:40\",\"11:00\",\"09:00\",\"11:00\",\"13:00\",\"15:00\"]\n<strong>输出：</strong>[\"daniel\"]\n<strong>解释：</strong>\"daniel\" 在一小时内使用了 3 次员工卡（\"10:00\"，\"10:40\"，\"11:00\"）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>keyName = [\"alice\",\"alice\",\"alice\",\"bob\",\"bob\",\"bob\",\"bob\"], keyTime = [\"12:01\",\"12:00\",\"18:00\",\"21:00\",\"21:20\",\"21:30\",\"23:00\"]\n<strong>输出：</strong>[\"bob\"]\n<strong>解释：</strong>\"bob\" 在一小时内使用了 3 次员工卡（\"21:00\"，\"21:20\"，\"21:30\"）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= keyName.length, keyTime.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>keyName.length == keyTime.length</code></li>\n\t<li><code>keyTime</code> 格式为&nbsp;<strong>\"HH:MM\"&nbsp;</strong>。</li>\n\t<li>保证&nbsp;<code>[keyName[i], keyTime[i]]</code>&nbsp;形成的二元对&nbsp;<strong>互不相同&nbsp;</strong>。</li>\n\t<li><code>1 &lt;= keyName[i].length &lt;= 10</code></li>\n\t<li><code>keyName[i]</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1605.给定行和列的和求可行矩阵",
        "hardRate": "MEDIUM",
        "passRate": "80.86%",
        "problemsUrl": "https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/",
        "solutionsUrl": "https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/solution",
        "problemsDesc": "<p>给你两个非负整数数组&nbsp;<code>rowSum</code> 和&nbsp;<code>colSum</code>&nbsp;，其中&nbsp;<code>rowSum[i]</code>&nbsp;是二维矩阵中第 <code>i</code>&nbsp;行元素的和， <code>colSum[j]</code>&nbsp;是第 <code>j</code>&nbsp;列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。</p>\n\n<p>请找到大小为&nbsp;<code>rowSum.length x colSum.length</code>&nbsp;的任意 <strong>非负整数</strong>&nbsp;矩阵，且该矩阵满足&nbsp;<code>rowSum</code> 和&nbsp;<code>colSum</code>&nbsp;的要求。</p>\n\n<p>请你返回任意一个满足题目要求的二维矩阵，题目保证存在 <strong>至少一个</strong>&nbsp;可行矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [3,8], colSum = [4,7]\n<strong>输出：</strong>[[3,0],\n      [1,7]]\n<strong>解释：</strong>\n第 0 行：3 + 0 = 3 == rowSum[0]\n第 1 行：1 + 7 = 8 == rowSum[1]\n第 0 列：3 + 1 = 4 == colSum[0]\n第 1 列：0 + 7 = 7 == colSum[1]\n行和列的和都满足题目要求，且所有矩阵元素都是非负的。\n另一个可行的矩阵为：[[1,2],\n                  [3,5]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [5,7,10], colSum = [8,6,8]\n<strong>输出：</strong>[[0,5,0],\n      [6,1,0],\n      [2,0,8]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [14,9], colSum = [6,9,8]\n<strong>输出：</strong>[[0,9,5],\n      [6,0,3]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [1,0], colSum = [1]\n<strong>输出：</strong>[[1],\n      [0]]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [0], colSum = [0]\n<strong>输出：</strong>[[0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rowSum.length, colSum.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= rowSum[i], colSum[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>sum(rowSum) == sum(colSum)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1606.找到处理最多请求的服务器",
        "hardRate": "HARD",
        "passRate": "48.42%",
        "problemsUrl": "https://leetcode.cn/problems/find-servers-that-handled-most-number-of-requests/",
        "solutionsUrl": "https://leetcode.cn/problems/find-servers-that-handled-most-number-of-requests/solution",
        "problemsDesc": "<p>你有 <code>k</code>&nbsp;个服务器，编号为 <code>0</code>&nbsp;到 <code>k-1</code>&nbsp;，它们可以同时处理多个请求组。每个服务器有无穷的计算能力但是 <strong>不能同时处理超过一个请求</strong>&nbsp;。请求分配到服务器的规则如下：</p>\n\n<ul>\n\t<li>第&nbsp;<code>i</code>&nbsp;（序号从 0 开始）个请求到达。</li>\n\t<li>如果所有服务器都已被占据，那么该请求被舍弃（完全不处理）。</li>\n\t<li>如果第&nbsp;<code>(i % k)</code>&nbsp;个服务器空闲，那么对应服务器会处理该请求。</li>\n\t<li>否则，将请求安排给下一个空闲的服务器（服务器构成一个环，必要的话可能从第 0 个服务器开始继续找下一个空闲的服务器）。比方说，如果第 <code>i</code>&nbsp;个服务器在忙，那么会查看第 <code>(i+1)</code>&nbsp;个服务器，第 <code>(i+2)</code>&nbsp;个服务器等等。</li>\n</ul>\n\n<p>给你一个 <strong>严格递增</strong>&nbsp;的正整数数组&nbsp;<code>arrival</code>&nbsp;，表示第&nbsp;<code>i</code>&nbsp;个任务的到达时间，和另一个数组&nbsp;<code>load</code>&nbsp;，其中&nbsp;<code>load[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个请求的工作量（也就是服务器完成它所需要的时间）。你的任务是找到 <strong>最繁忙的服务器</strong>&nbsp;。最繁忙定义为一个服务器处理的请求数是所有服务器里最多的。</p>\n\n<p>请你返回包含所有&nbsp;<strong>最繁忙服务器</strong>&nbsp;序号的列表，你可以以任意顺序返回这个列表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/03/load-1.png\" style=\"height: 221px; width: 389px;\" /></p>\n\n<pre>\n<strong>输入：</strong>k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] \n<strong>输出：</strong>[1] \n<strong>解释：</strong>\n所有服务器一开始都是空闲的。\n前 3 个请求分别由前 3 台服务器依次处理。\n请求 3 进来的时候，服务器 0 被占据，所以它被安排到下一台空闲的服务器，也就是服务器 1 。\n请求 4 进来的时候，由于所有服务器都被占据，该请求被舍弃。\n服务器 0 和 2 分别都处理了一个请求，服务器 1 处理了两个请求。所以服务器 1 是最忙的服务器。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, arrival = [1,2,3,4], load = [1,2,1,2]\n<strong>输出：</strong>[0]\n<strong>解释：</strong>\n前 3 个请求分别被前 3 个服务器处理。\n请求 3 进来，由于服务器 0 空闲，它被服务器 0 处理。\n服务器 0 处理了两个请求，服务器 1 和 2 分别处理了一个请求。所以服务器 0 是最忙的服务器。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, arrival = [1,2,3], load = [10,12,11]\n<strong>输出：</strong>[0,1,2]\n<strong>解释：</strong>每个服务器分别处理了一个请求，所以它们都是最忙的服务器。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 1, arrival = [1], load = [1]\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arrival.length, load.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>arrival.length == load.length</code></li>\n\t<li><code>1 &lt;= arrival[i], load[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>arrival</code>&nbsp;保证 <strong>严格递增</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1607.没有卖出的卖家",
        "hardRate": "EASY",
        "passRate": "54.37%",
        "problemsUrl": "https://leetcode.cn/problems/sellers-with-no-sales/",
        "solutionsUrl": "https://leetcode.cn/problems/sellers-with-no-sales/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1608.特殊数组的特征值",
        "hardRate": "EASY",
        "passRate": "61.37%",
        "problemsUrl": "https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/",
        "solutionsUrl": "https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/solution",
        "problemsDesc": "<p>给你一个非负整数数组 <code>nums</code> 。如果存在一个数 <code>x</code> ，使得 <code>nums</code> 中恰好有 <code>x</code> 个元素 <strong>大于或者等于</strong> <code>x</code> ，那么就称 <code>nums</code> 是一个 <strong>特殊数组</strong> ，而 <code>x</code> 是该数组的 <strong>特征值</strong> 。</p>\n\n<p>注意： <code>x</code> <strong>不必</strong> 是 <code>nums</code> 的中的元素。</p>\n\n<p>如果数组 <code>nums</code> 是一个 <strong>特殊数组</strong> ，请返回它的特征值 <code>x</code> 。否则，返回<em> </em><code>-1</code> 。可以证明的是，如果 <code>nums</code> 是特殊数组，那么其特征值 <code>x</code> 是 <strong>唯一的</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,5]\n<strong>输出：</strong>2\n<strong>解释：</strong>有 2 个元素（3 和 5）大于或等于 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,0]\n<strong>输出：</strong>-1\n<strong>解释：</strong>没有满足题目要求的特殊数组，故而也不存在特征值 x 。\n如果 x = 0，应该有 0 个元素 &gt;= x，但实际有 2 个。\n如果 x = 1，应该有 1 个元素 &gt;= x，但实际有 0 个。\n如果 x = 2，应该有 2 个元素 &gt;= x，但实际有 0 个。\nx 不能取更大的值，因为 nums 中只有两个元素。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,4,3,0,4]\n<strong>输出：</strong>3\n<strong>解释：</strong>有 3 个元素大于或等于 3 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,6,7,7,0]\n<strong>输出：</strong>-1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1609.奇偶树",
        "hardRate": "MEDIUM",
        "passRate": "58.06%",
        "problemsUrl": "https://leetcode.cn/problems/even-odd-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/even-odd-tree/solution",
        "problemsDesc": "<p>如果一棵二叉树满足下述几个条件，则可以称为 <strong>奇偶树</strong> ：</p>\n\n<ul>\n\t<li>二叉树根节点所在层下标为 <code>0</code> ，根的子节点所在层下标为 <code>1</code> ，根的孙节点所在层下标为 <code>2</code> ，依此类推。</li>\n\t<li><strong>偶数下标</strong> 层上的所有节点的值都是 <strong>奇</strong> 整数，从左到右按顺序 <strong>严格递增</strong></li>\n\t<li><strong>奇数下标</strong> 层上的所有节点的值都是 <strong>偶</strong> 整数，从左到右按顺序 <strong>严格递减</strong></li>\n</ul>\n\n<p>给你二叉树的根节点，如果二叉树为 <strong>奇偶树 </strong>，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_1966.png\" style=\"height: 229px; width: 362px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,10,4,3,null,7,9,12,8,6,null,null,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>每一层的节点值分别是：\n0 层：[1]\n1 层：[10,4]\n2 层：[3,7,9]\n3 层：[12,8,6,2]\n由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_2_1966.png\" style=\"height: 167px; width: 363px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,4,2,3,3,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>每一层的节点值分别是：\n0 层：[5]\n1 层：[4,2]\n2 层：[3,3,7]\n2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_333_1966.png\" style=\"height: 167px; width: 363px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,9,1,3,5,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>1 层上的节点值应为偶数。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]\n<strong>输出：</strong>true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 <= Node.val <= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1610.可见点的最大数目",
        "hardRate": "HARD",
        "passRate": "44.39%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-visible-points/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-visible-points/solution",
        "problemsDesc": "<p>给你一个点数组 <code>points</code> 和一个表示角度的整数 <code>angle</code> ，你的位置是 <code>location</code> ，其中 <code>location = [pos<sub>x</sub>, pos<sub>y</sub>]</code> 且 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 都表示 X-Y 平面上的整数坐标。</p>\n\n<p>最开始，你面向东方进行观测。你 <strong>不能</strong> 进行移动改变位置，但可以通过 <strong>自转</strong> 调整观测角度。换句话说，<code>pos<sub>x</sub></code> 和 <code>pos<sub>y</sub></code> 不能改变。你的视野范围的角度用 <code>angle</code> 表示， 这决定了你观测任意方向时可以多宽。设 <code>d</code> 为你逆时针自转旋转的度数，那么你的视野就是角度范围 <code>[d - angle/2, d + angle/2]</code> 所指示的那片区域。</p>\n\n<video autoplay=\"\" controls=\"\" height=\"360\" muted=\"\" style=\"max-width:100%;height:auto;\" width=\"750\"><source src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/angle.mp4\" type=\"video/mp4\" />Your browser does not support the video tag or this video format.</video>\n\n<p>对于每个点，如果由该点、你的位置以及从你的位置直接向东的方向形成的角度 <strong>位于你的视野中</strong> ，那么你就可以看到它。</p>\n\n<p>同一个坐标上可以有多个点。你所在的位置也可能存在一些点，但不管你的怎么旋转，总是可以看到这些点。同时，点不会阻碍你看到其他点。</p>\n\n<p>返回你能看到的点的最大数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/89a07e9b-00ab-4967-976a-c723b2aa8656.png\" style=\"height: 300px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入：</strong>points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>阴影区域代表你的视野。在你的视野中，所有的点都清晰可见，尽管 [2,2] 和 [3,3]在同一条直线上，你仍然可以看到 [3,3] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>在你的视野中，所有的点都清晰可见，包括你所在位置的那个点。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/5010bfd3-86e6-465f-ac64-e9df941d2e49.png\" style=\"height: 348px; width: 690px;\" /></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,0],[2,1]], angle = 13, location = [1,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>如图所示，你只能看到两点之一。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= points.length <= 10<sup>5</sup></code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>location.length == 2</code></li>\n\t<li><code>0 <= angle < 360</code></li>\n\t<li><code>0 <= pos<sub>x</sub>, pos<sub>y</sub>, x<sub>i</sub>, y<sub>i</sub> <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1611.使整数变为 0 的最少操作次数",
        "hardRate": "HARD",
        "passRate": "61.15%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-one-bit-operations-to-make-integers-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-one-bit-operations-to-make-integers-zero/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>，你需要重复执行多次下述操作将其转换为 <code>0</code> ：</p>\n\n<ul>\n\t<li>翻转 <code>n</code> 的二进制表示中最右侧位（第 <code>0</code> 位）。</li>\n\t<li>如果第 <code>(i-1)</code> 位为 <code>1</code> 且从第 <code>(i-2)</code> 位到第 <code>0</code> 位都为 <code>0</code>，则翻转 <code>n</code> 的二进制表示中的第 <code>i</code> 位。</li>\n</ul>\n\n<p>返回将 <code>n</code> 转换为 <code>0</code> 的最小操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>3 的二进制表示为 \"11\"\n\"<strong>1</strong>1\" -&gt; \"<strong>0</strong>1\" ，执行的是第 2 种操作，因为第 0 位为 1 。\n\"0<strong>1</strong>\" -&gt; \"0<strong>0</strong>\" ，执行的是第 1 种操作。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6\n<strong>输出：</strong>4\n<strong>解释：</strong>6 的二进制表示为 \"110\".\n\"<strong>1</strong>10\" -&gt; \"<strong>0</strong>10\" ，执行的是第 2 种操作，因为第 1 位为 1 ，第 0 到 0 位为 0 。\n\"01<strong>0</strong>\" -&gt; \"01<strong>1</strong>\" ，执行的是第 1 种操作。\n\"0<strong>1</strong>1\" -&gt; \"0<strong>0</strong>1\" ，执行的是第 2 种操作，因为第 0 位为 1 。\n\"00<strong>1</strong>\" -&gt; \"00<strong>0</strong>\" ，执行的是第 1 种操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1612.检查两棵二叉表达式树是否等价",
        "hardRate": "MEDIUM",
        "passRate": "74.44%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-two-expression-trees-are-equivalent/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-two-expression-trees-are-equivalent/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1613.找到遗失的ID",
        "hardRate": "MEDIUM",
        "passRate": "72.93%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-missing-ids/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-missing-ids/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1614.括号的最大嵌套深度",
        "hardRate": "EASY",
        "passRate": "82.31%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/solution",
        "problemsDesc": "<p>如果字符串满足以下条件之一，则可以称之为 <strong>有效括号字符串</strong><strong>（valid parentheses string</strong>，可以简写为 <strong>VPS</strong>）：</p>\n\n<ul>\n\t<li>字符串是一个空字符串 <code>\"\"</code>，或者是一个不为 <code>\"(\"</code> 或 <code>\")\"</code> 的单字符。</li>\n\t<li>字符串可以写为 <code>AB</code>（<code>A</code> 与 <code>B</code>&nbsp;字符串连接），其中 <code>A</code> 和 <code>B</code> 都是 <strong>有效括号字符串</strong> 。</li>\n\t<li>字符串可以写为 <code>(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong> 。</li>\n</ul>\n\n<p>类似地，可以定义任何有效括号字符串&nbsp;<code>S</code> 的 <strong>嵌套深度</strong> <code>depth(S)</code>：</p>\n\n<ul>\n\t<li><code>depth(\"\") = 0</code></li>\n\t<li><code>depth(C) = 0</code>，其中 <code>C</code> 是单个字符的字符串，且该字符不是 <code>\"(\"</code> 或者 <code>\")\"</code></li>\n\t<li><code>depth(A + B) = max(depth(A), depth(B))</code>，其中 <code>A</code> 和 <code>B</code> 都是 <strong>有效括号字符串</strong></li>\n\t<li><code>depth(\"(\" + A + \")\") = 1 + depth(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong></li>\n</ul>\n\n<p>例如：<code>\"\"</code>、<code>\"()()\"</code>、<code>\"()(()())\"</code> 都是 <strong>有效括号字符串</strong>（嵌套深度分别为 0、1、2），而 <code>\")(\"</code> 、<code>\"(()\"</code> 都不是 <strong>有效括号字符串</strong> 。</p>\n\n<p>给你一个 <strong>有效括号字符串</strong> <code>s</code>，返回该字符串的<em> </em><code>s</code> <strong>嵌套深度</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(1+(2*3)+((<strong>8</strong>)/4))+1\"\n<strong>输出：</strong>3\n<strong>解释：</strong>数字 8 在嵌套的 3 层括号中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(1)+((2))+(((<strong>3</strong>)))\"\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 由数字 <code>0-9</code> 和字符 <code>'+'</code>、<code>'-'</code>、<code>'*'</code>、<code>'/'</code>、<code>'('</code>、<code>')'</code> 组成</li>\n\t<li>题目数据保证括号表达式 <code>s</code> 是 <strong>有效的括号表达式</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1615.最大网络秩",
        "hardRate": "MEDIUM",
        "passRate": "60.14%",
        "problemsUrl": "https://leetcode.cn/problems/maximal-network-rank/",
        "solutionsUrl": "https://leetcode.cn/problems/maximal-network-rank/solution",
        "problemsDesc": "<p><code>n</code> 座城市和一些连接这些城市的道路 <code>roads</code> 共同组成一个基础设施网络。每个 <code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 都表示在城市 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间有一条双向道路。</p>\n\n<p>两座不同城市构成的 <strong>城市对</strong> 的 <strong>网络秩</strong> 定义为：与这两座城市 <strong>直接</strong> 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 <strong>一次</strong> 。</p>\n\n<p>整个基础设施网络的 <strong>最大网络秩</strong> 是所有不同城市对中的 <strong>最大网络秩</strong> 。</p>\n\n<p>给你整数 <code>n</code> 和数组 <code>roads</code>，返回整个基础设施网络的 <strong>最大网络秩</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/ex1.png\" style=\"width: 292px; height: 172px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]\n<strong>输出：</strong>4\n<strong>解释：</strong>城市 0 和 1 的网络秩是 4，因为共有 4 条道路与城市 0 或 1 相连。位于 0 和 1 之间的道路只计算一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/ex2.png\" style=\"width: 292px; height: 172px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]\n<strong>输出：</strong>5\n<strong>解释：</strong>共有 5 条道路与城市 1 或 2 相连。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]\n<strong>输出：</strong>5\n<strong>解释：</strong>2 和 5 的网络秩为 5，注意并非所有的城市都需要连接起来。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 100</code></li>\n\t<li><code>0 <= roads.length <= n * (n - 1) / 2</code></li>\n\t<li><code>roads[i].length == 2</code></li>\n\t<li><code>0 <= a<sub>i</sub>, b<sub>i</sub> <= n-1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>每对城市之间 <strong>最多只有一条</strong> 道路相连</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1616.分割两个字符串得到回文串",
        "hardRate": "MEDIUM",
        "passRate": "37.53%",
        "problemsUrl": "https://leetcode.cn/problems/split-two-strings-to-make-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/split-two-strings-to-make-palindrome/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>a</code> 和&nbsp;<code>b</code>&nbsp;，它们长度相同。请你选择一个下标，将两个字符串都在&nbsp;<strong>相同的下标 </strong>分割开。由&nbsp;<code>a</code>&nbsp;可以得到两个字符串：&nbsp;<code>a<sub>prefix</sub></code>&nbsp;和&nbsp;<code>a<sub>suffix</sub></code>&nbsp;，满足&nbsp;<code>a = a<sub>prefix</sub> + a<sub>suffix</sub></code><sub>&nbsp;</sub>，同理，由&nbsp;<code>b</code> 可以得到两个字符串&nbsp;<code>b<sub>prefix</sub></code> 和&nbsp;<code>b<sub>suffix</sub></code>&nbsp;，满足&nbsp;<code>b = b<sub>prefix</sub> + b<sub>suffix</sub></code>&nbsp;。请你判断&nbsp;<code>a<sub>prefix</sub> + b<sub>suffix</sub></code> 或者&nbsp;<code>b<sub>prefix</sub> + a<sub>suffix</sub></code>&nbsp;能否构成回文串。</p>\n\n<p>当你将一个字符串&nbsp;<code>s</code>&nbsp;分割成&nbsp;<code>s<sub>prefix</sub></code> 和&nbsp;<code>s<sub>suffix</sub></code>&nbsp;时，&nbsp;<code>s<sub>suffix</sub></code> 或者&nbsp;<code>s<sub>prefix</sub></code> 可以为空。比方说，&nbsp;<code>s = \"abc\"</code>&nbsp;那么&nbsp;<code>\"\" + \"abc\"</code>&nbsp;，&nbsp;<code>\"a\" + \"bc\"&nbsp;</code>，&nbsp;<code>\"ab\" + \"c\"</code>&nbsp;和&nbsp;<code>\"abc\" + \"\"</code>&nbsp;都是合法分割。</p>\n\n<p>如果 <strong>能构成回文字符串</strong> ，那么请返回&nbsp;<code>true</code>，否则返回<em>&nbsp;</em><code>false</code>&nbsp;。</p>\n\n<p><strong>注意</strong>，&nbsp;<code>x + y</code>&nbsp;表示连接字符串&nbsp;<code>x</code> 和&nbsp;<code>y</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>a = \"x\", b = \"y\"\n<b>输出：</b>true\n<b>解释：</b>如果 a 或者 b 是回文串，那么答案一定为 true ，因为你可以如下分割：\na<sub>prefix</sub> = \"\", a<sub>suffix</sub> = \"x\"\nb<sub>prefix</sub> = \"\", b<sub>suffix</sub> = \"y\"\n那么 a<sub>prefix</sub> + b<sub>suffix</sub> = \"\" + \"y\" = \"y\" 是回文串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = \"abdef\", b = \"fecab\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>a = \"ulacfd\", b = \"jizalu\"\n<b>输出：</b>true\n<b>解释：</b>在下标为 3 处分割：\na<sub>prefix</sub> = \"ula\", a<sub>suffix</sub> = \"cfd\"\nb<sub>prefix</sub> = \"jiz\", b<sub>suffix</sub> = \"alu\"\n那么 a<sub>prefix</sub> + b<sub>suffix</sub> = \"ula\" + \"alu\" = \"ulaalu\" 是回文串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>a.length == b.length</code></li>\n\t<li><code>a</code> 和&nbsp;<code>b</code>&nbsp;都只包含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1617.统计子树中城市之间最大距离",
        "hardRate": "HARD",
        "passRate": "79.18%",
        "problemsUrl": "https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/",
        "solutionsUrl": "https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/solution",
        "problemsDesc": "<p>给你 <code>n</code> 个城市，编号为从 <code>1</code> 到 <code>n</code> 。同时给你一个大小为 <code>n-1</code> 的数组 <code>edges</code> ，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示城市 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code><sub> </sub>之间有一条双向边。题目保证任意城市之间只有唯一的一条路径。换句话说，所有城市形成了一棵 <strong>树</strong> 。</p>\n\n<p>一棵 <strong>子树</strong> 是城市的一个子集，且子集中任意城市之间可以通过子集中的其他城市和边到达。两个子树被认为不一样的条件是至少有一个城市在其中一棵子树中存在，但在另一棵子树中不存在。</p>\n\n<p>对于 <code>d</code> 从 <code>1</code> 到 <code>n-1</code> ，请你找到城市间 <strong>最大距离</strong> 恰好为 <code>d</code> 的所有子树数目。</p>\n\n<p>请你返回一个大小为 <code>n-1</code> 的数组，其中第<em> </em><code>d</code><em> </em>个元素（<strong>下标从 1 开始</strong>）是城市间 <strong>最大距离</strong> 恰好等于 <code>d</code> 的子树数目。</p>\n\n<p><strong>请注意</strong>，两个城市间距离定义为它们之间需要经过的边的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/p1.png\" style=\"width: 161px; height: 181px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>n = 4, edges = [[1,2],[2,3],[2,4]]\n<b>输出：</b>[3,4,0]\n<strong>解释：\n</strong>子树 {1,2}, {2,3} 和 {2,4} 最大距离都是 1 。\n子树 {1,2,3}, {1,2,4}, {2,3,4} 和 {1,2,3,4} 最大距离都为 2 。\n不存在城市间最大距离为 3 的子树。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 2, edges = [[1,2]]\n<b>输出：</b>[1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, edges = [[1,2],[2,3]]\n<b>输出：</b>[2,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 15</code></li>\n\t<li><code>edges.length == n-1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code></li>\n\t<li>题目保证 <code>(u<sub>i</sub>, v<sub>i</sub>)</code> 所表示的边互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1618.找出适应屏幕的最大字号",
        "hardRate": "MEDIUM",
        "passRate": "62.47%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-font-to-fit-a-sentence-in-a-screen/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-font-to-fit-a-sentence-in-a-screen/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1619.删除某些元素后的数组均值",
        "hardRate": "EASY",
        "passRate": "71.73%",
        "problemsUrl": "https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> ，请你删除最小 <code>5%</code> 的数字和最大 <code>5%</code> 的数字后，剩余数字的平均值。</p>\n\n<p>与 <strong>标准答案</strong> 误差在 <code>10<sup>-5</sup></code> 的结果都被视为正确结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n<b>输出：</b>2.00000\n<b>解释：</b>删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n<b>输出：</b>4.00000\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n<b>输出：</b>4.77778\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n<b>输出：</b>5.27778\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n<b>输出：</b>5.29167\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>20 <= arr.length <= 1000</code></li>\n\t<li><code>arr.length</code><b> </b>是 <code>20</code> 的<strong> 倍数</strong> </li>\n\t<li><code>0 <= arr[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1620.网络信号最好的坐标",
        "hardRate": "MEDIUM",
        "passRate": "46.05%",
        "problemsUrl": "https://leetcode.cn/problems/coordinate-with-maximum-network-quality/",
        "solutionsUrl": "https://leetcode.cn/problems/coordinate-with-maximum-network-quality/solution",
        "problemsDesc": "<p>给你一个数组 <code>towers</code>&nbsp;和一个整数 <code>radius</code> 。</p>\n\n<p>数组&nbsp; <code>towers</code>&nbsp; 中包含一些网络信号塔，其中&nbsp;<code>towers[i] = [x<sub>i</sub>, y<sub>i</sub>, q<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个网络信号塔的坐标是&nbsp;<code>(x<sub>i</sub>, y<sub>i</sub>)</code>&nbsp;且信号强度参数为&nbsp;<code>q<sub>i</sub></code><sub>&nbsp;</sub>。所有坐标都是在&nbsp; X-Y 坐标系内的&nbsp;<strong>整数</strong>&nbsp;坐标。两个坐标之间的距离用 <strong>欧几里得距离</strong>&nbsp;计算。</p>\n\n<p>整数&nbsp;<code>radius</code>&nbsp;表示一个塔 <strong>能到达&nbsp;</strong>的 <strong>最远距离</strong>&nbsp;。如果一个坐标跟塔的距离在 <code>radius</code>&nbsp;以内，那么该塔的信号可以到达该坐标。在这个范围以外信号会很微弱，所以 <code>radius</code>&nbsp;以外的距离该塔是 <strong>不能到达的</strong>&nbsp;。</p>\n\n<p>如果第 <code>i</code>&nbsp;个塔能到达 <code>(x, y)</code>&nbsp;，那么该塔在此处的信号为&nbsp;<code>⌊q<sub>i</sub> / (1 + d)⌋</code>&nbsp;，其中&nbsp;<code>d</code>&nbsp;是塔跟此坐标的距离。一个坐标的 <b>信号强度</b> 是所有 <strong>能到达&nbsp;</strong>该坐标的塔的信号强度之和。</p>\n\n<p>请你返回数组 <code>[c<sub>x</sub>, c<sub>y</sub>]</code> ，表示 <strong>信号强度</strong> 最大的 <strong>整数</strong> 坐标点&nbsp;<code>(c<sub>x</sub>, c<sub>y</sub>)</code> 。如果有多个坐标网络信号一样大，请你返回字典序最小的 <strong>非负</strong> 坐标。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>坐标&nbsp;<code>(x1, y1)</code>&nbsp;字典序比另一个坐标&nbsp;<code>(x2, y2)</code> 小，需满足以下条件之一：\n\n\t<ul>\n\t\t<li>要么&nbsp;<code>x1 &lt; x2</code>&nbsp;，</li>\n\t\t<li>要么&nbsp;<code>x1 == x2</code> 且&nbsp;<code>y1 &lt; y2</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li><code>⌊val⌋</code>&nbsp;表示小于等于&nbsp;<code>val</code>&nbsp;的最大整数（向下取整函数）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/17/untitled-diagram.png\" style=\"width: 176px; height: 176px;\" />\n<pre>\n<b>输入：</b>towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2\n<b>输出：</b>[2,1]\n<strong>解释：</strong>\n坐标 (2, 1) 信号强度之和为 13\n- 塔 (2, 1) 强度参数为 7 ，在该点强度为 ⌊7 / (1 + sqrt(0)⌋ = ⌊7⌋ = 7\n- 塔 (1, 2) 强度参数为 5 ，在该点强度为 ⌊5 / (1 + sqrt(2)⌋ = ⌊2.07⌋ = 2\n- 塔 (3, 1) 强度参数为 9 ，在该点强度为 ⌊9 / (1 + sqrt(1)⌋ = ⌊4.5⌋ = 4\n没有别的坐标有更大的信号强度。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>towers = [[23,11,21]], radius = 9\n<b>输出：</b>[23,11]\n<strong>解释：</strong>由于仅存在一座信号塔，所以塔的位置信号强度最大。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2\n<b>输出：</b>[1,2]\n<strong>解释：</strong>坐标 (1, 2) 的信号强度最大。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= towers.length &lt;= 50</code></li>\n\t<li><code>towers[i].length == 3</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>, q<sub>i</sub> &lt;= 50</code></li>\n\t<li><code>1 &lt;= radius &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1621.大小为 K 的不重叠线段的数目",
        "hardRate": "MEDIUM",
        "passRate": "48.03%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-sets-of-k-non-overlapping-line-segments/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-sets-of-k-non-overlapping-line-segments/solution",
        "problemsDesc": "<p>给你一维空间的 <code>n</code> 个点，其中第 <code>i</code> 个点（编号从 <code>0</code> 到 <code>n-1</code>）位于 <code>x = i</code> 处，请你找到 <strong>恰好</strong> <code>k</code> <strong>个不重叠</strong> 线段且每个线段至少覆盖两个点的方案数。线段的两个端点必须都是 <strong>整数坐标</strong> 。这 <code>k</code> 个线段不需要全部覆盖全部 <code>n</code> 个点，且它们的端点 <strong>可以 </strong>重合。</p>\n\n<p>请你返回 <code>k</code> 个不重叠线段的方案数。由于答案可能很大，请将结果对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/17/ex1.png\" style=\"width: 179px; height: 222px;\" />\n<pre>\n<b>输入：</b>n = 4, k = 2\n<b>输出：</b>5\n<strong>解释：\n</strong>如图所示，两个线段分别用红色和蓝色标出。\n上图展示了 5 种不同的方案 {(0,2),(2,3)}，{(0,1),(1,3)}，{(0,1),(2,3)}，{(1,2),(2,3)}，{(0,1),(1,2)} 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, k = 1\n<b>输出：</b>3\n<strong>解释：</strong>总共有 3 种不同的方案 {(0,1)}, {(0,2)}, {(1,2)} 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 30, k = 7\n<b>输出：</b>796297179\n<strong>解释：</strong>画 7 条线段的总方案数为 3796297200 种。将这个数对 10<sup>9</sup> + 7 取余得到 796297179 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, k = 3\n<b>输出：</b>7\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, k = 2\n<b>输出：</b>1</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 1000</code></li>\n\t<li><code>1 <= k <= n-1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1622.奇妙序列",
        "hardRate": "HARD",
        "passRate": "17.29%",
        "problemsUrl": "https://leetcode.cn/problems/fancy-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/fancy-sequence/solution",
        "problemsDesc": "<p>请你实现三个 API <code>append</code>，<code>addAll</code> 和 <code>multAll</code> 来实现奇妙序列。</p>\n\n<p>请实现 <code>Fancy</code> 类 ：</p>\n\n<ul>\n\t<li><code>Fancy()</code> 初始化一个空序列对象。</li>\n\t<li><code>void append(val)</code> 将整数 <code>val</code> 添加在序列末尾。</li>\n\t<li><code>void addAll(inc)</code> 将所有序列中的现有数值都增加 <code>inc</code> 。</li>\n\t<li><code>void multAll(m)</code> 将序列中的所有现有数值都乘以整数 <code>m</code> 。</li>\n\t<li><code>int getIndex(idx)</code> 得到下标为 <code>idx</code> 处的数值（下标从 0 开始），并将结果对 <code>10<sup>9</sup> + 7</code> 取余。如果下标大于等于序列的长度，请返回 <code>-1</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Fancy\", \"append\", \"addAll\", \"append\", \"multAll\", \"getIndex\", \"addAll\", \"append\", \"multAll\", \"getIndex\", \"getIndex\", \"getIndex\"]\n[[], [2], [3], [7], [2], [0], [3], [10], [2], [0], [1], [2]]\n<strong>输出：</strong>\n[null, null, null, null, null, 10, null, null, null, 26, 34, 20]\n\n<strong>解释：</strong>\nFancy fancy = new Fancy();\nfancy.append(2);   // 奇妙序列：[2]\nfancy.addAll(3);   // 奇妙序列：[2+3] -> [5]\nfancy.append(7);   // 奇妙序列：[5, 7]\nfancy.multAll(2);  // 奇妙序列：[5*2, 7*2] -> [10, 14]\nfancy.getIndex(0); // 返回 10\nfancy.addAll(3);   // 奇妙序列：[10+3, 14+3] -> [13, 17]\nfancy.append(10);  // 奇妙序列：[13, 17, 10]\nfancy.multAll(2);  // 奇妙序列：[13*2, 17*2, 10*2] -> [26, 34, 20]\nfancy.getIndex(0); // 返回 26\nfancy.getIndex(1); // 返回 34\nfancy.getIndex(2); // 返回 20\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= val, inc, m <= 100</code></li>\n\t<li><code>0 <= idx <= 10<sup>5</sup></code></li>\n\t<li>总共最多会有 <code>10<sup>5</sup></code> 次对 <code>append</code>，<code>addAll</code>，<code>multAll</code> 和 <code>getIndex</code> 的调用。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1623.三人国家代表队",
        "hardRate": "EASY",
        "passRate": "78.47%",
        "problemsUrl": "https://leetcode.cn/problems/all-valid-triplets-that-can-represent-a-country/",
        "solutionsUrl": "https://leetcode.cn/problems/all-valid-triplets-that-can-represent-a-country/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1624.两个相同字符之间的最长子字符串",
        "hardRate": "EASY",
        "passRate": "64.43%",
        "problemsUrl": "https://leetcode.cn/problems/largest-substring-between-two-equal-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-substring-between-two-equal-characters/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code>，请你返回 <strong>两个相同字符之间的最长子字符串的长度</strong> <em>，</em>计算长度时不含这两个字符。如果不存在这样的子字符串，返回 <code>-1</code> 。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"aa\"\n<strong>输出：</strong>0\n<strong>解释：</strong>最优的子字符串是两个 'a' 之间的空子字符串。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abca\"\n<strong>输出：</strong>2\n<strong>解释：</strong>最优的子字符串是 \"bc\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"cbzxy\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>s 中不存在出现出现两次的字符，所以返回 -1 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = \"cabbac\"\n<strong>输出：</strong>4\n<strong>解释：</strong>最优的子字符串是 \"abba\" ，其他的非最优解包括 \"bb\" 和 \"\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 300</code></li>\n\t<li><code>s</code> 只含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1625.执行操作后字典序最小的字符串",
        "hardRate": "MEDIUM",
        "passRate": "66.73%",
        "problemsUrl": "https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 以及两个整数 <code>a</code> 和 <code>b</code> 。其中，字符串 <code>s</code> 的长度为偶数，且仅由数字 <code>0</code> 到 <code>9</code> 组成。</p>\n\n<p>你可以在 <code>s</code> 上按任意顺序多次执行下面两个操作之一：</p>\n\n<ul>\n\t<li>累加：将  <code>a</code> 加到 <code>s</code> 中所有下标为奇数的元素上（<strong>下标从 0 开始</strong>）。数字一旦超过 <code>9</code> 就会变成 <code>0</code>，如此循环往复。例如，<code>s = \"3456\"</code> 且 <code>a = 5</code>，则执行此操作后 <code>s</code> 变成 <code>\"3951\"</code>。</li>\n\t<li>轮转：将 <code>s</code> 向右轮转 <code>b</code> 位。例如，<code>s = \"3456\"</code> 且 <code>b = 1</code>，则执行此操作后 <code>s</code> 变成 <code>\"6345\"</code>。</li>\n</ul>\n\n<p>请你返回在 <code>s</code> 上执行上述操作任意次后可以得到的 <strong>字典序最小</strong> 的字符串。</p>\n\n<p>如果两个字符串长度相同，那么字符串 <code>a</code> 字典序比字符串 <code>b</code> 小可以这样定义：在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置上，字符串 <code>a</code> 中的字符出现在字母表中的时间早于 <code>b</code> 中的对应字符。例如，<code>\"0158”</code> 字典序比 <code>\"0190\"</code> 小，因为不同的第一个位置是在第三个字符，显然 <code>'5'</code> 出现在 <code>'9'</code> 之前。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"5525\", a = 9, b = 2\n<strong>输出：</strong>\"2050\"\n<strong>解释：</strong>执行操作如下：\n初态：\"5525\"\n轮转：\"2555\"\n累加：\"2454\"\n累加：\"2353\"\n轮转：\"5323\"\n累加：\"5222\"\n累加：\"5121\"\n轮转：\"2151\"\n累加：\"2050\"​​​​​​​​​​​​\n无法获得字典序小于 \"2050\" 的字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"74\", a = 5, b = 1\n<strong>输出：</strong>\"24\"\n<strong>解释：</strong>执行操作如下：\n初态：\"74\"\n轮转：\"47\"\n累加：\"42\"\n轮转：\"24\"​​​​​​​​​​​​\n无法获得字典序小于 \"24\" 的字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0011\", a = 4, b = 2\n<strong>输出：</strong>\"0011\"\n<strong>解释：</strong>无法获得字典序小于 \"0011\" 的字符串。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"43987654\", a = 7, b = 3\n<strong>输出：</strong>\"00553311\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= s.length <= 100</code></li>\n\t<li><code>s.length</code> 是偶数</li>\n\t<li><code>s</code> 仅由数字 <code>0</code> 到 <code>9</code> 组成</li>\n\t<li><code>1 <= a <= 9</code></li>\n\t<li><code>1 <= b <= s.length - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1626.无矛盾的最佳球队",
        "hardRate": "MEDIUM",
        "passRate": "53.71%",
        "problemsUrl": "https://leetcode.cn/problems/best-team-with-no-conflicts/",
        "solutionsUrl": "https://leetcode.cn/problems/best-team-with-no-conflicts/solution",
        "problemsDesc": "<p>假设你是球队的经理。对于即将到来的锦标赛，你想组合一支总体得分最高的球队。球队的得分是球队中所有球员的分数 <strong>总和</strong> 。</p>\n\n<p>然而，球队中的矛盾会限制球员的发挥，所以必须选出一支 <strong>没有矛盾</strong> 的球队。如果一名年龄较小球员的分数 <strong>严格大于</strong> 一名年龄较大的球员，则存在矛盾。同龄球员之间不会发生矛盾。</p>\n\n<p>给你两个列表 <code>scores</code> 和 <code>ages</code>，其中每组 <code>scores[i]</code> 和 <code>ages[i]</code> 表示第 <code>i</code> 名球员的分数和年龄。请你返回 <strong>所有可能的无矛盾球队中得分最高那支的分数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>scores = [1,3,5,10,15], ages = [1,2,3,4,5]\n<strong>输出：</strong>34\n<strong>解释：</strong>你可以选中所有球员。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>scores = [4,5,6,5], ages = [2,1,2,1]\n<strong>输出：</strong>16\n<strong>解释：</strong>最佳的选择是后 3 名球员。注意，你可以选中多个同龄球员。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>scores = [1,2,3,5], ages = [8,9,10,1]\n<strong>输出：</strong>6\n<strong>解释：</strong>最佳的选择是前 3 名球员。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= scores.length, ages.length &lt;= 1000</code></li>\n\t<li><code>scores.length == ages.length</code></li>\n\t<li><code>1 &lt;= scores[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= ages[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1627.带阈值的图连通性",
        "hardRate": "HARD",
        "passRate": "42.26%",
        "problemsUrl": "https://leetcode.cn/problems/graph-connectivity-with-threshold/",
        "solutionsUrl": "https://leetcode.cn/problems/graph-connectivity-with-threshold/solution",
        "problemsDesc": "<p>有 <code>n</code> 座城市，编号从 <code>1</code> 到 <code>n</code> 。编号为 <code>x</code> 和 <code>y</code> 的两座城市直接连通的前提是： <code>x</code> 和 <code>y</code> 的公因数中，至少有一个 <strong>严格大于</strong> 某个阈值 <code>threshold</code> 。更正式地说，如果存在整数 <code>z</code> ，且满足以下所有条件，则编号 <code>x</code> 和 <code>y</code> 的城市之间有一条道路：</p>\n\n<ul>\n\t<li><code>x % z == 0</code></li>\n\t<li><code>y % z == 0</code></li>\n\t<li><code>z > threshold</code></li>\n</ul>\n\n<p>给你两个整数 <code>n</code> 和 <code>threshold</code> ，以及一个待查询数组，请你判断每个查询<code> queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 指向的城市 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 是否连通（即，它们之间是否存在一条路径）。</p>\n\n<p>返回数组 <code>answer</code> ，其中<code>answer.length == queries.length</code> 。如果第 <code>i</code> 个查询中指向的城市 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 连通，则 <code>answer[i]</code> 为 <code>true</code> ；如果不连通，则 <code>answer[i]</code> 为 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/18/ex1.jpg\" style=\"width: 382px; height: 181px;\" /></p>\n\n<p> </p>\n\n<pre>\n<strong>输入：</strong>n = 6, threshold = 2, queries = [[1,4],[2,5],[3,6]]\n<strong>输出：</strong>[false,false,true]\n<strong>解释：</strong>每个数的因数如下：\n1:   1\n2:   1, 2\n3:   1, <strong>3</strong>\n4:   1, 2, <strong>4</strong>\n5:   1, <strong>5</strong>\n6:   1, 2, <strong>3</strong>, <strong>6</strong>\n所有大于阈值的的因数已经加粗标识，只有城市 3 和 6 共享公约数 3 ，因此结果是： \n[1,4]   1 与 4 不连通\n[2,5]   2 与 5 不连通\n[3,6]   3 与 6 连通，存在路径 3--6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/18/tmp.jpg\" style=\"width: 532px; height: 302px;\" /></p>\n\n<p> </p>\n\n<pre>\n<strong>输入：</strong>n = 6, threshold = 0, queries = [[4,5],[3,4],[3,2],[2,6],[1,3]]\n<strong>输出：</strong>[true,true,true,true,true]\n<strong>解释：</strong>每个数的因数与上一个例子相同。但是，由于阈值为 0 ，所有的因数都大于阈值。因为所有的数字共享公因数 1 ，所以所有的城市都互相连通。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/16/ex3.jpg\" style=\"width: 282px; height: 282px;\" /></p>\n\n<p> </p>\n\n<pre>\n<strong>输入：</strong>n = 5, threshold = 1, queries = [[4,5],[4,5],[3,2],[2,3],[3,4]]\n<strong>输出：</strong>[false,false,false,false,false]\n<strong>解释：</strong>只有城市 2 和 4 共享的公约数 2 严格大于阈值 1 ，所以只有这两座城市是连通的。\n注意，同一对节点 [x, y] 可以有多个查询，并且查询 [x，y] 等同于查询 [y，x] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 10<sup>4</sup></code></li>\n\t<li><code>0 <= threshold <= n</code></li>\n\t<li><code>1 <= queries.length <= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 <= a<sub>i</sub>, b<sub>i</sub> <= cities</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1628.设计带解析函数的表达式树",
        "hardRate": "MEDIUM",
        "passRate": "82.41%",
        "problemsUrl": "https://leetcode.cn/problems/design-an-expression-tree-with-evaluate-function/",
        "solutionsUrl": "https://leetcode.cn/problems/design-an-expression-tree-with-evaluate-function/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1629.按键持续时间最长的键",
        "hardRate": "EASY",
        "passRate": "55.85%",
        "problemsUrl": "https://leetcode.cn/problems/slowest-key/",
        "solutionsUrl": "https://leetcode.cn/problems/slowest-key/solution",
        "problemsDesc": "<p>LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 <code>n</code> 个），每次一个。</p>\n\n<p>给你一个长度为 <code>n</code> 的字符串 <code>keysPressed</code> ，其中 <code>keysPressed[i]</code> 表示测试序列中第 <code>i</code> 个被按下的键。<code>releaseTimes</code> 是一个升序排列的列表，其中 <code>releaseTimes[i]</code> 表示松开第 <code>i</code> 个键的时间。字符串和数组的 <strong>下标都从 0 开始</strong> 。第 <code>0</code> 个键在时间为 <code>0</code> 时被按下，接下来每个键都 <strong>恰好</strong> 在前一个键松开时被按下。</p>\n\n<p>测试人员想要找出按键 <strong>持续时间最长</strong> 的键。第 <code>i</code><sup> </sup>次按键的持续时间为 <code>releaseTimes[i] - releaseTimes[i - 1]</code> ，第 <code>0</code> 次按键的持续时间为 <code>releaseTimes[0]</code> 。</p>\n\n<p>注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。</p>\n\n<p>请返回单次按键 <strong>持续时间最长</strong> 的键，如果有多个这样的键，则返回 <strong>按字母顺序排列最大</strong> 的那个键。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>releaseTimes = [9,29,49,50], keysPressed = \"cbcd\"\n<strong>输出：</strong>\"c\"\n<strong>解释：</strong>按键顺序和持续时间如下：\n按下 'c' ，持续时间 9（时间 0 按下，时间 9 松开）\n按下 'b' ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开）\n按下 'c' ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开）\n按下 'd' ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开）\n按键持续时间最长的键是 'b' 和 'c'（第二次按下时），持续时间都是 20\n'c' 按字母顺序排列比 'b' 大，所以答案是 'c'\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>releaseTimes = [12,23,36,46,62], keysPressed = \"spuda\"\n<strong>输出：</strong>\"a\"\n<strong>解释：</strong>按键顺序和持续时间如下：\n按下 's' ，持续时间 12\n按下 'p' ，持续时间 23 - 12 = 11\n按下 'u' ，持续时间 36 - 23 = 13\n按下 'd' ，持续时间 46 - 36 = 10\n按下 'a' ，持续时间 62 - 46 = 16\n按键持续时间最长的键是 'a' ，持续时间 16</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>releaseTimes.length == n</code></li>\n\t<li><code>keysPressed.length == n</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= releaseTimes[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>releaseTimes[i] &lt; releaseTimes[i+1]</code></li>\n\t<li><code>keysPressed</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1630.等差子数组",
        "hardRate": "MEDIUM",
        "passRate": "76.14%",
        "problemsUrl": "https://leetcode.cn/problems/arithmetic-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/arithmetic-subarrays/solution",
        "problemsDesc": "<p>如果一个数列由至少两个元素组成，且每两个连续元素之间的差值都相同，那么这个序列就是 <strong>等差数列</strong> 。更正式地，数列 <code>s</code> 是等差数列，只需要满足：对于每个有效的 <code>i</code> ， <code>s[i+1] - s[i] == s[1] - s[0]</code> 都成立。</p>\n\n<p>例如，下面这些都是 <strong>等差数列</strong> ：</p>\n\n<pre>1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9</pre>\n\n<p>下面的数列 <strong>不是等差数列</strong> ：</p>\n\n<pre>1, 1, 2, 5, 7</pre>\n\n<p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code>，和两个由 <code>m</code> 个整数组成的数组 <code>l</code> 和 <code>r</code>，后两个数组表示 <code>m</code> 组范围查询，其中第 <code>i</code> 个查询对应范围 <code>[l[i], r[i]]</code> 。所有数组的下标都是 <strong>从 0 开始</strong> 的。</p>\n\n<p>返回<em> </em><code>boolean</code> 元素构成的答案列表 <code>answer</code> 。如果子数组 <code>nums[l[i]], nums[l[i]+1], ... , nums[r[i]]</code> 可以 <strong>重新排列</strong> 形成 <strong>等差数列</strong> ，<code>answer[i]</code> 的值就是 <code>true</code>；否则<code>answer[i]</code> 的值就是 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = <code>[4,6,5,9,3,7]</code>, l = <code>[0,0,2]</code>, r = <code>[2,3,5]</code>\n<strong>输出：</strong><code>[true,false,true]</code>\n<strong>解释：</strong>\n第 0 个查询，对应子数组 [4,6,5] 。可以重新排列为等差数列 [6,5,4] 。\n第 1 个查询，对应子数组 [4,6,5,9] 。无法重新排列形成等差数列。\n第 2 个查询，对应子数组 <code>[5,9,3,7] 。</code>可以重新排列为等差数列 <code>[3,5,7,9] 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]\n<strong>输出：</strong>[false,true,false,false,true,true]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == l.length</code></li>\n\t<li><code>m == r.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= m &lt;= 500</code></li>\n\t<li><code>0 &lt;= l[i] &lt; r[i] &lt; n</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1631.最小体力消耗路径",
        "hardRate": "MEDIUM",
        "passRate": "50.94%",
        "problemsUrl": "https://leetcode.cn/problems/path-with-minimum-effort/",
        "solutionsUrl": "https://leetcode.cn/problems/path-with-minimum-effort/solution",
        "problemsDesc": "<p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p>\n\n<p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p>\n\n<p>请你返回从左上角走到右下角的最小<strong> 体力消耗值</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex1.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<b>输入：</b>heights = [[1,2,2],[3,8,2],[5,3,5]]\n<b>输出：</b>2\n<b>解释：</b>路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。\n这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex2.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<b>输入：</b>heights = [[1,2,3],[3,8,4],[5,3,5]]\n<b>输出：</b>1\n<b>解释：</b>路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex3.png\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<b>输入：</b>heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]\n<b>输出：</b>0\n<b>解释：</b>上图所示路径不需要消耗任何体力。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == heights.length</code></li>\n\t<li><code>columns == heights[i].length</code></li>\n\t<li><code>1 <= rows, columns <= 100</code></li>\n\t<li><code>1 <= heights[i][j] <= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1632.矩阵转换后的秩",
        "hardRate": "HARD",
        "passRate": "57.49%",
        "problemsUrl": "https://leetcode.cn/problems/rank-transform-of-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/rank-transform-of-a-matrix/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> ，请你返回一个新的矩阵<em> </em><code>answer</code> ，其中<em> </em><code>answer[row][col]</code> 是 <code>matrix[row][col]</code> 的秩。</p>\n\n<p>每个元素的 <b>秩</b> 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算：</p>\n\n<ul>\n\t<li>秩是从 1 开始的一个整数。</li>\n\t<li>如果两个元素 <code>p</code> 和 <code>q</code> 在 <strong>同一行</strong> 或者 <strong>同一列</strong> ，那么：\n\t<ul>\n\t\t<li>如果 <code>p < q</code> ，那么 <code>rank(p) < rank(q)</code></li>\n\t\t<li>如果 <code>p == q</code> ，那么 <code>rank(p) == rank(q)</code></li>\n\t\t<li>如果 <code>p > q</code> ，那么 <code>rank(p) > rank(q)</code></li>\n\t</ul>\n\t</li>\n\t<li><b>秩</b> 需要越 <strong>小</strong> 越好。</li>\n</ul>\n\n<p>题目保证按照上面规则 <code>answer</code> 数组是唯一的。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank1.jpg\" style=\"width: 442px; height: 162px;\" />\n<pre>\n<b>输入：</b>matrix = [[1,2],[3,4]]\n<b>输出：</b>[[1,2],[2,3]]\n<strong>解释：</strong>\nmatrix[0][0] 的秩为 1 ，因为它是所在行和列的最小整数。\nmatrix[0][1] 的秩为 2 ，因为 matrix[0][1] > matrix[0][0] 且 matrix[0][0] 的秩为 1 。\nmatrix[1][0] 的秩为 2 ，因为 matrix[1][0] > matrix[0][0] 且 matrix[0][0] 的秩为 1 。\nmatrix[1][1] 的秩为 3 ，因为 matrix[1][1] > matrix[0][1]， matrix[1][1] > matrix[1][0] 且 matrix[0][1] 和 matrix[1][0] 的秩都为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank2.jpg\" style=\"width: 442px; height: 162px;\" />\n<pre>\n<b>输入：</b>matrix = [[7,7],[7,7]]\n<b>输出：</b>[[1,1],[1,1]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank3.jpg\" style=\"width: 601px; height: 322px;\" />\n<pre>\n<b>输入：</b>matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]\n<b>输出：</b>[[4,2,3],[1,3,4],[5,1,6],[1,3,4]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank4.jpg\" style=\"width: 601px; height: 242px;\" />\n<pre>\n<b>输入：</b>matrix = [[7,3,6],[1,4,5],[9,8,2]]\n<b>输出：</b>[[5,1,4],[1,2,3],[6,3,1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 500</code></li>\n\t<li><code>-10<sup>9</sup> <= matrix[row][col] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1633.各赛事的用户注册率",
        "hardRate": "EASY",
        "passRate": "62.68%",
        "problemsUrl": "https://leetcode.cn/problems/percentage-of-users-attended-a-contest/",
        "solutionsUrl": "https://leetcode.cn/problems/percentage-of-users-attended-a-contest/solution",
        "problemsDesc": "<p>用户表：&nbsp;<code>Users</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| user_id     | int     |\n| user_name   | varchar |\n+-------------+---------+\nuser_id 是该表的主键。\n该表中的每行包括用户 ID 和用户名。</pre>\n\n<p>&nbsp;</p>\n\n<p>注册表：&nbsp;<code>Register</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| contest_id  | int     |\n| user_id     | int     |\n+-------------+---------+\n(contest_id, user_id) 是该表的主键。\n该表中的每行包含用户的 ID 和他们注册的赛事。</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条 SQL 语句，查询各赛事的用户注册百分率，保留两位小数。</p>\n\n<p>返回的结果表按&nbsp;<code>percentage</code>&nbsp;的&nbsp;<strong>降序&nbsp;</strong>排序，若相同则按&nbsp;<code>contest_id</code>&nbsp;的&nbsp;<strong>升序&nbsp;</strong>排序。</p>\n\n<p>查询结果如下示例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<code><strong>输入：</strong>\nUsers</code> 表：\n+---------+-----------+\n| user_id | user_name |\n+---------+-----------+\n| 6       | Alice     |\n| 2       | Bob       |\n| 7       | Alex      |\n+---------+-----------+\n\n<code>Register</code> 表：\n+------------+---------+\n| contest_id | user_id |\n+------------+---------+\n| 215        | 6       |\n| 209        | 2       |\n| 208        | 2       |\n| 210        | 6       |\n| 208        | 6       |\n| 209        | 7       |\n| 209        | 6       |\n| 215        | 7       |\n| 208        | 7       |\n| 210        | 2       |\n| 207        | 2       |\n| 210        | 7       |\n+------------+---------+\n<strong>输出：</strong>\n+------------+------------+\n| contest_id | percentage |\n+------------+------------+\n| 208        | 100.0      |\n| 209        | 100.0      |\n| 210        | 100.0      |\n| 215        | 66.67      |\n| 207        | 33.33      |\n+------------+------------+\n<strong>解释：</strong>\n所有用户都注册了 208、209 和 210 赛事，因此这些赛事的注册率为 100% ，我们按 contest_id 的降序排序加入结果表中。\nAlice 和 Alex 注册了 215 赛事，注册率为 ((2/3) * 100) = 66.67%\nBob 注册了 207 赛事，注册率为 ((1/3) * 100) = 33.33%</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1634.求两个多项式链表的和",
        "hardRate": "MEDIUM",
        "passRate": "60.15%",
        "problemsUrl": "https://leetcode.cn/problems/add-two-polynomials-represented-as-linked-lists/",
        "solutionsUrl": "https://leetcode.cn/problems/add-two-polynomials-represented-as-linked-lists/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1635.Hopper 公司查询 I",
        "hardRate": "HARD",
        "passRate": "49.22%",
        "problemsUrl": "https://leetcode.cn/problems/hopper-company-queries-i/",
        "solutionsUrl": "https://leetcode.cn/problems/hopper-company-queries-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1636.按照频率将数组升序排序",
        "hardRate": "EASY",
        "passRate": "74.76%",
        "problemsUrl": "https://leetcode.cn/problems/sort-array-by-increasing-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-array-by-increasing-frequency/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，请你将数组按照每个值的频率 <strong>升序</strong> 排序。如果有多个值的频率相同，请你按照数值本身将它们 <strong>降序</strong> 排序。 </p>\n\n<p>请你返回排序后的数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,2,2,2,3]\n<b>输出：</b>[3,1,1,2,2,2]\n<b>解释：</b>'3' 频率为 1，'1' 频率为 2，'2' 频率为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,1,3,2]\n<b>输出：</b>[1,3,3,2,2]\n<b>解释：</b>'2' 和 '3' 频率都为 2 ，所以它们之间按照数值本身降序排序。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [-1,1,-6,4,5,-6,1,4,1]\n<b>输出：</b>[5,-1,4,4,-6,-6,1,1,1]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1637.两点之间不包含任何点的最宽垂直区域",
        "hardRate": "MEDIUM",
        "passRate": "84.34%",
        "problemsUrl": "https://leetcode.cn/problems/widest-vertical-area-between-two-points-containing-no-points/",
        "solutionsUrl": "https://leetcode.cn/problems/widest-vertical-area-between-two-points-containing-no-points/solution",
        "problemsDesc": "<p>给你&nbsp;<code>n</code>&nbsp;个二维平面上的点 <code>points</code> ，其中&nbsp;<code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;，请你返回两点之间内部不包含任何点的&nbsp;<strong>最宽垂直区域</strong> 的宽度。</p>\n\n<p><strong>垂直区域</strong> 的定义是固定宽度，而 y 轴上无限延伸的一块区域（也就是高度为无穷大）。 <strong>最宽垂直区域</strong> 为宽度最大的一个垂直区域。</p>\n\n<p>请注意，垂直区域&nbsp;<strong>边上</strong>&nbsp;的点&nbsp;<strong>不在</strong>&nbsp;区域内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/31/points3.png\" style=\"width: 276px; height: 371px;\" />​\n<pre>\n<b>输入：</b>points = [[8,7],[9,9],[7,4],[9,7]]\n<b>输出：</b>1\n<b>解释：</b>红色区域和蓝色区域都是最优区域。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\n<b>输出：</b>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == points.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1638.统计只差一个字符的子串数目",
        "hardRate": "MEDIUM",
        "passRate": "77.64%",
        "problemsUrl": "https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/",
        "solutionsUrl": "https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s</code> 和&nbsp;<code>t</code>&nbsp;，请你找出 <code>s</code>&nbsp;中的非空子串的数目，这些子串满足替换 <strong>一个不同字符</strong>&nbsp;以后，是 <code>t</code>&nbsp;串的子串。换言之，请你找到 <code>s</code>&nbsp;和 <code>t</code>&nbsp;串中 <strong>恰好</strong>&nbsp;只有一个字符不同的子字符串对的数目。</p>\n\n<p>比方说，&nbsp;<code>\"<u>compute</u>r\"</code>&nbsp;and&nbsp;<code>\"<u>computa</u>tion\"&nbsp;</code>只有一个字符不同：&nbsp;<code>'e'</code>/<code>'a'</code>&nbsp;，所以这一对子字符串会给答案加 1 。</p>\n\n<p>请你返回满足上述条件的不同子字符串对数目。</p>\n\n<p>一个 <strong>子字符串</strong>&nbsp;是一个字符串中连续的字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aba\", t = \"baba\"\n<b>输出：</b>6\n<strong>解释：</strong>以下为只相差 1 个字符的 s 和 t 串的子字符串对：\n(\"<strong>a</strong>ba\", \"<strong>b</strong>aba\")\n(\"<strong>a</strong>ba\", \"ba<strong>b</strong>a\")\n(\"ab<strong>a</strong>\", \"<strong>b</strong>aba\")\n(\"ab<strong>a</strong>\", \"ba<strong>b</strong>a\")\n(\"a<strong>b</strong>a\", \"b<strong>a</strong>ba\")\n(\"a<strong>b</strong>a\", \"bab<strong>a</strong>\")\n加粗部分分别表示 s 和 t 串选出来的子字符串。\n</pre>\n<strong>示例 2：</strong>\n\n<pre>\n<b>输入：</b>s = \"ab\", t = \"bb\"\n<b>输出：</b>3\n<strong>解释：</strong>以下为只相差 1 个字符的 s 和 t 串的子字符串对：\n(\"<strong>a</strong>b\", \"<strong>b</strong>b\")\n(\"<strong>a</strong>b\", \"b<strong>b</strong>\")\n(\"<strong>ab</strong>\", \"<strong>bb</strong>\")\n加粗部分分别表示 s 和 t 串选出来的子字符串。\n</pre>\n<strong>示例 3：</strong>\n\n<pre>\n<b>输入：</b>s = \"a\", t = \"a\"\n<b>输出：</b>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abe\", t = \"bbc\"\n<b>输出：</b>10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 100</code></li>\n\t<li><code>s</code> 和&nbsp;<code>t</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1639.通过给定词典构造目标字符串的方案数",
        "hardRate": "HARD",
        "passRate": "46.91%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solution",
        "problemsDesc": "<p>给你一个字符串列表 <code>words</code> 和一个目标字符串 <code>target</code> 。<code>words</code> 中所有字符串都 <strong>长度相同</strong>  。</p>\n\n<p>你的目标是使用给定的 <code>words</code> 字符串列表按照下述规则构造 <code>target</code> ：</p>\n\n<ul>\n\t<li>从左到右依次构造 <code>target</code> 的每一个字符。</li>\n\t<li>为了得到 <code>target</code> 第 <code>i</code> 个字符（下标从 <strong>0</strong> 开始），当 <code>target[i] = words[j][k]</code> 时，你可以使用 <code>words</code> 列表中第 <code>j</code> 个字符串的第 <code>k</code> 个字符。</li>\n\t<li>一旦你使用了 <code>words</code> 中第 <code>j</code> 个字符串的第 <code>k</code> 个字符，你不能再使用 <code>words</code> 字符串列表中任意单词的第 <code>x</code> 个字符（<code>x <= k</code>）。也就是说，所有单词下标小于等于 <code>k</code> 的字符都不能再被使用。</li>\n\t<li>请你重复此过程直到得到目标字符串 <code>target</code> 。</li>\n</ul>\n\n<p><strong>请注意</strong>， 在构造目标字符串的过程中，你可以按照上述规定使用 <code>words</code> 列表中 <strong>同一个字符串</strong> 的 <strong>多个字符</strong> 。</p>\n\n<p>请你返回使用 <code>words</code> 构造 <code>target</code> 的方案数。由于答案可能会很大，请对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后返回。</p>\n\n<p>（译者注：此题目求的是有多少个不同的 <code>k</code> 序列，详情请见示例。）</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"acca\",\"bbbb\",\"caca\"], target = \"aba\"\n<b>输出：</b>6\n<b>解释：</b>总共有 6 种方法构造目标串。\n\"aba\" -> 下标为 0 (\"<strong>a</strong>cca\")，下标为 1 (\"b<strong>b</strong>bb\")，下标为 3 (\"cac<strong>a</strong>\")\n\"aba\" -> 下标为 0 (\"<strong>a</strong>cca\")，下标为 2 (\"bb<strong>b</strong>b\")，下标为 3 (\"cac<strong>a</strong>\")\n\"aba\" -> 下标为 0 (\"<strong>a</strong>cca\")，下标为 1 (\"b<strong>b</strong>bb\")，下标为 3 (\"acc<strong>a</strong>\")\n\"aba\" -> 下标为 0 (\"<strong>a</strong>cca\")，下标为 2 (\"bb<strong>b</strong>b\")，下标为 3 (\"acc<strong>a</strong>\")\n\"aba\" -> 下标为 1 (\"c<strong>a</strong>ca\")，下标为 2 (\"bb<strong>b</strong>b\")，下标为 3 (\"acc<strong>a</strong>\")\n\"aba\" -> 下标为 1 (\"c<strong>a</strong>ca\")，下标为 2 (\"bb<strong>b</strong>b\")，下标为 3 (\"cac<strong>a</strong>\")\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"abba\",\"baab\"], target = \"bab\"\n<b>输出：</b>4\n<b>解释：</b>总共有 4 种不同形成 target 的方法。\n\"bab\" -> 下标为 0 (\"<strong>b</strong>aab\")，下标为 1 (\"b<strong>a</strong>ab\")，下标为 2 (\"ab<strong>b</strong>a\")\n\"bab\" -> 下标为 0 (\"<strong>b</strong>aab\")，下标为 1 (\"b<strong>a</strong>ab\")，下标为 3 (\"baa<strong>b</strong>\")\n\"bab\" -> 下标为 0 (\"<strong>b</strong>aab\")，下标为 2 (\"ba<strong>a</strong>b\")，下标为 3 (\"baa<strong>b</strong>\")\n\"bab\" -> 下标为 1 (\"a<strong>b</strong>ba\")，下标为 2 (\"ba<strong>a</strong>b\")，下标为 3 (\"baa<strong>b</strong>\")\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"abcd\"], target = \"abcd\"\n<b>输出：</b>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"abab\",\"baba\",\"abba\",\"baab\"], target = \"abba\"\n<b>输出：</b>16\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 1000</code></li>\n\t<li><code>1 <= words[i].length <= 1000</code></li>\n\t<li><code>words</code> 中所有单词长度相同。</li>\n\t<li><code>1 <= target.length <= 1000</code></li>\n\t<li><code>words[i]</code> 和 <code>target</code> 都仅包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1640.能否连接形成数组",
        "hardRate": "EASY",
        "passRate": "60.95%",
        "problemsUrl": "https://leetcode.cn/problems/check-array-formation-through-concatenation/",
        "solutionsUrl": "https://leetcode.cn/problems/check-array-formation-through-concatenation/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> ，数组中的每个整数 <strong>互不相同</strong> 。另有一个由整数数组构成的数组 <code>pieces</code>，其中的整数也 <strong>互不相同</strong> 。请你以 <strong>任意顺序</strong> 连接 <code>pieces</code> 中的数组以形成 <code>arr</code> 。但是，<strong>不允许</strong> 对每个数组 <code>pieces[i]</code> 中的整数重新排序。</p>\n\n<p>如果可以连接<em> </em><code>pieces</code> 中的数组形成 <code>arr</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [15,88], pieces = [[88],[15]]\n<strong>输出：</strong>true\n<strong>解释：</strong>依次连接 <code>[15]</code> 和 <code>[88]</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [49,18,16], pieces = [[16,18,49]]\n<strong>输出：</strong>false\n<strong>解释：</strong>即便数字相符，也不能重新排列 pieces[0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [91,4,64,78], pieces = [[78],[4,64],[91]]\n<strong>输出：</strong>true\n<strong>解释：</strong>依次连接 <code>[91]</code>、<code>[4,64]</code> 和 <code>[78]</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pieces.length &lt;= arr.length &lt;= 100</code></li>\n\t<li><code>sum(pieces[i].length) == arr.length</code></li>\n\t<li><code>1 &lt;= pieces[i].length &lt;= arr.length</code></li>\n\t<li><code>1 &lt;= arr[i], pieces[i][j] &lt;= 100</code></li>\n\t<li><code>arr</code> 中的整数 <strong>互不相同</strong></li>\n\t<li><code>pieces</code> 中的整数 <strong>互不相同</strong>（也就是说，如果将 <code>pieces</code> 扁平化成一维数组，数组中的所有整数互不相同）</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1641.统计字典序元音字符串的数目",
        "hardRate": "MEDIUM",
        "passRate": "82.37%",
        "problemsUrl": "https://leetcode.cn/problems/count-sorted-vowel-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/count-sorted-vowel-strings/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>，请返回长度为 <code>n</code> 、仅由元音 (<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>) 组成且按 <strong>字典序排列</strong> 的字符串数量。</p>\n\n<p>字符串 <code>s</code> 按 <strong>字典序排列</strong> 需要满足：对于所有有效的 <code>i</code>，<code>s[i]</code> 在字母表中的位置总是与 <code>s[i+1]</code> 相同或在 <code>s[i+1]</code> 之前。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>5\n<strong>解释：</strong>仅由元音组成的 5 个字典序字符串为 <code>[\"a\",\"e\",\"i\",\"o\",\"u\"]</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>15\n<strong>解释：</strong>仅由元音组成的 15 个字典序字符串为\n[\"aa\",\"ae\",\"ai\",\"ao\",\"au\",\"ee\",\"ei\",\"eo\",\"eu\",\"ii\",\"io\",\"iu\",\"oo\",\"ou\",\"uu\"]\n注意，\"ea\" 不是符合题意的字符串，因为 'e' 在字母表中的位置比 'a' 靠后\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 33\n<strong>输出：</strong>66045\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 50</code> </li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1642.可以到达的最远建筑",
        "hardRate": "MEDIUM",
        "passRate": "45.32%",
        "problemsUrl": "https://leetcode.cn/problems/furthest-building-you-can-reach/",
        "solutionsUrl": "https://leetcode.cn/problems/furthest-building-you-can-reach/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>heights</code> ，表示建筑物的高度。另有一些砖块 <code>bricks</code> 和梯子 <code>ladders</code> 。</p>\n\n<p>你从建筑物 <code>0</code> 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。</p>\n\n<p>当从建筑物 <code>i</code> 移动到建筑物 <code>i+1</code>（下标<strong> 从 0 开始 </strong>）时：</p>\n\n<ul>\n\t<li>如果当前建筑物的高度 <strong>大于或等于</strong> 下一建筑物的高度，则不需要梯子或砖块</li>\n\t<li>如果当前建筑的高度 <strong>小于</strong> 下一个建筑的高度，您可以使用 <strong>一架梯子</strong> 或 <strong><code>(h[i+1] - h[i])</code> 个砖块</strong></li>\n</ul>\n如果以最佳方式使用给定的梯子和砖块，返回你可以到达的最远建筑物的下标（下标<strong> 从 0 开始 </strong>）。\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/31/q4.gif\" style=\"width: 562px; height: 561px;\" />\n<pre>\n<strong>输入：</strong>heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>从建筑物 0 出发，你可以按此方案完成旅程：\n- 不使用砖块或梯子到达建筑物 1 ，因为 4 >= 2\n- 使用 5 个砖块到达建筑物 2 。你必须使用砖块或梯子，因为 2 < 7\n- 不使用砖块或梯子到达建筑物 3 ，因为 7 >= 6\n- 使用唯一的梯子到达建筑物 4 。你必须使用砖块或梯子，因为 6 < 9\n无法越过建筑物 4 ，因为没有更多砖块或梯子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2\n<strong>输出：</strong>7\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>heights = [14,3,19,3], bricks = 17, ladders = 0\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= heights.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= heights[i] <= 10<sup>6</sup></code></li>\n\t<li><code>0 <= bricks <= 10<sup>9</sup></code></li>\n\t<li><code>0 <= ladders <= heights.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1643.第 K 条最小指令",
        "hardRate": "HARD",
        "passRate": "48.06%",
        "problemsUrl": "https://leetcode.cn/problems/kth-smallest-instructions/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-smallest-instructions/solution",
        "problemsDesc": "<p>Bob 站在单元格 <code>(0, 0)</code> ，想要前往目的地 <code>destination</code> ：<code>(row, column)</code> 。他只能向 <strong>右</strong> 或向 <strong>下</strong> 走。你可以为 Bob 提供导航 <strong>指令</strong> 来帮助他到达目的地 <code>destination</code> 。</p>\n\n<p><strong>指令</strong> 用字符串表示，其中每个字符：</p>\n\n<ul>\n\t<li><code>'H'</code> ，意味着水平向右移动</li>\n\t<li><code>'V'</code> ，意味着竖直向下移动</li>\n</ul>\n\n<p>能够为 Bob 导航到目的地 <code>destination</code> 的指令可以有多种，例如，如果目的地 <code>destination</code> 是 <code>(2, 3)</code>，<code>\"HHHVV\"</code> 和 <code>\"HVHVH\"</code> 都是有效<strong> 指令</strong> 。</p>\n\n<ul>\n</ul>\n\n<p>然而，Bob 很挑剔。因为他的幸运数字是 <code>k</code>，他想要遵循 <strong>按字典序排列后的第 <code>k</code> 条最小指令 </strong>的导航前往目的地 <code>destination</code> 。<code>k</code>  的编号 <strong>从 1 开始</strong> 。</p>\n\n<p>给你一个整数数组 <code>destination</code> 和一个整数 <code>k</code> ，请你返回可以为<em> </em>Bob<em> </em>提供前往目的地 <code>destination</code> 导航的<strong> 按字典序排列后的第 <code>k</code> 条最小指令 </strong>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/01/ex1.png\" style=\"width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>destination = [2,3], k = 1\n<strong>输出：</strong>\"HHHVV\"\n<strong>解释：</strong>能前往 (2, 3) 的所有导航指令 <strong>按字典序排列后</strong> 如下所示：\n[\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\", \"VHHHV\", \"VHHVH\", \"VHVHH\", \"VVHHH\"].\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/01/ex2.png\" style=\"width: 300px; height: 229px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>destination = [2,3], k = 2\n<strong>输出：</strong>\"HHVHV\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/01/ex3.png\" style=\"width: 300px; height: 229px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>destination = [2,3], k = 3\n<strong>输出：</strong>\"HHVVH\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>destination.length == 2</code></li>\n\t<li><code>1 <= row, column <= 15</code></li>\n\t<li><code>1 <= k <= nCr(row + column, row)</code>，其中 <code>nCr(a, b)</code> 表示组合数，即从 <code>a</code> 个物品中选 <code>b</code> 个物品的不同方案数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1644.二叉树的最近公共祖先 II",
        "hardRate": "MEDIUM",
        "passRate": "56.13%",
        "problemsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1645.1645.Hopper 公司查询 II",
        "hardRate": "HARD",
        "passRate": "41.78%",
        "problemsUrl": "https://leetcode.cn/problems/hopper-company-queries-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/hopper-company-queries-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1646.获取生成数组中的最大值",
        "hardRate": "EASY",
        "passRate": "51.87%",
        "problemsUrl": "https://leetcode.cn/problems/get-maximum-in-generated-array/",
        "solutionsUrl": "https://leetcode.cn/problems/get-maximum-in-generated-array/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> 。按下述规则生成一个长度为 <code>n + 1</code> 的数组 <code>nums</code> ：</p>\n\n<ul>\n\t<li><code>nums[0] = 0</code></li>\n\t<li><code>nums[1] = 1</code></li>\n\t<li>当 <code>2 <= 2 * i <= n</code> 时，<code>nums[2 * i] = nums[i]</code></li>\n\t<li>当 <code>2 <= 2 * i + 1 <= n</code> 时，<code>nums[2 * i + 1] = nums[i] + nums[i + 1]</code></li>\n</ul>\n\n<p>返回生成数组 <code>nums</code> 中的 <strong>最大</strong> 值。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7\n<strong>输出：</strong>3\n<strong>解释：</strong>根据规则：\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\n因此，nums = [0,1,1,2,1,3,2,3]，最大值 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= n <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1647.字符频次唯一的最小删除次数",
        "hardRate": "MEDIUM",
        "passRate": "54.53%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-character-frequencies-unique/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-character-frequencies-unique/solution",
        "problemsDesc": "<p>如果字符串 <code>s</code> 中 <strong>不存在</strong> 两个不同字符 <strong>频次</strong> 相同的情况，就称 <code>s</code> 是 <strong>优质字符串</strong> 。</p>\n\n<p>给你一个字符串 <code>s</code>，返回使 <code>s</code> 成为 <strong>优质字符串</strong> 需要删除的 <strong>最小</strong> 字符数。</p>\n\n<p>字符串中字符的 <strong>频次</strong> 是该字符在字符串中的出现次数。例如，在字符串 <code>\"aab\"</code> 中，<code>'a'</code> 的频次是 <code>2</code>，而 <code>'b'</code> 的频次是 <code>1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aab\"\n<strong>输出：</strong>0\n<strong>解释：</strong><code>s</code> 已经是优质字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaabbbcc\"\n<strong>输出：</strong>2\n<strong>解释：</strong>可以删除两个 'b' , 得到优质字符串 \"aaabcc\" 。\n另一种方式是删除一个 'b' 和一个 'c' ，得到优质字符串 \"aaabbc\" 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ceabaacb\"\n<strong>输出：</strong>2\n<strong>解释：</strong>可以删除两个 'c' 得到优质字符串 \"eabaab\" 。\n注意，只需要关注结果字符串中仍然存在的字符。（即，频次为 0 的字符会忽略不计。）\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1648.销售价值减少的颜色球",
        "hardRate": "MEDIUM",
        "passRate": "31.57%",
        "problemsUrl": "https://leetcode.cn/problems/sell-diminishing-valued-colored-balls/",
        "solutionsUrl": "https://leetcode.cn/problems/sell-diminishing-valued-colored-balls/solution",
        "problemsDesc": "<p>你有一些球的库存 <code>inventory</code> ，里面包含着不同颜色的球。一个顾客想要 <strong>任意颜色</strong> 总数为 <code>orders</code> 的球。</p>\n\n<p>这位顾客有一种特殊的方式衡量球的价值：每个球的价值是目前剩下的 <strong>同色球</strong> 的数目。比方说还剩下 <code>6</code> 个黄球，那么顾客买第一个黄球的时候该黄球的价值为 <code>6</code> 。这笔交易以后，只剩下 <code>5</code> 个黄球了，所以下一个黄球的价值为 <code>5</code> （也就是球的价值随着顾客购买同色球是递减的）</p>\n\n<p>给你整数数组 <code>inventory</code> ，其中 <code>inventory[i]</code> 表示第 <code>i</code> 种颜色球一开始的数目。同时给你整数 <code>orders</code> ，表示顾客总共想买的球数目。你可以按照 <strong>任意顺序</strong> 卖球。</p>\n\n<p>请你返回卖了 <code>orders</code> 个球以后 <strong>最大</strong> 总价值之和。由于答案可能会很大，请你返回答案对 <code>10<sup>9</sup> + 7</code> <strong>取余数</strong> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/08/jj.gif\" style=\"width: 480px; height: 270px;\" />\n<pre>\n<b>输入：</b>inventory = [2,5], orders = 4\n<b>输出：</b>14\n<b>解释：</b>卖 1 个第一种颜色的球（价值为 2 )，卖 3 个第二种颜色的球（价值为 5 + 4 + 3）。\n最大总和为 2 + 5 + 4 + 3 = 14 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>inventory = [3,5], orders = 6\n<b>输出：</b>19\n<strong>解释：</strong>卖 2 个第一种颜色的球（价值为 3 + 2），卖 4 个第二种颜色的球（价值为 5 + 4 + 3 + 2）。\n最大总和为 3 + 2 + 5 + 4 + 3 + 2 = 19 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>inventory = [2,8,4,10,6], orders = 20\n<b>输出：</b>110\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>inventory = [1000000000], orders = 1000000000\n<b>输出：</b>21\n<strong>解释：</strong>卖 1000000000 次第一种颜色的球，总价值为 500000000500000000 。 500000000500000000 对 10<sup>9 </sup>+ 7 取余为 21 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= inventory.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= inventory[i] <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= orders <= min(sum(inventory[i]), 10<sup>9</sup>)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1649.通过指令创建有序数组",
        "hardRate": "HARD",
        "passRate": "49.30%",
        "problemsUrl": "https://leetcode.cn/problems/create-sorted-array-through-instructions/",
        "solutionsUrl": "https://leetcode.cn/problems/create-sorted-array-through-instructions/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>instructions</code> ，你需要根据 <code>instructions</code> 中的元素创建一个有序数组。一开始你有一个空的数组 <code>nums</code> ，你需要 <strong>从左到右</strong> 遍历 <code>instructions</code> 中的元素，将它们依次插入 <code>nums</code> 数组中。每一次插入操作的 <strong>代价</strong> 是以下两者的 <strong>较小值</strong> ：</p>\n\n<ul>\n\t<li><code>nums</code> 中 <strong>严格小于 </strong> <code>instructions[i]</code> 的数字数目。</li>\n\t<li><code>nums</code> 中 <strong>严格大于 </strong> <code>instructions[i]</code> 的数字数目。</li>\n</ul>\n\n<p>比方说，如果要将 <code>3</code> 插入到 <code>nums = [1,2,3,5]</code> ，那么插入操作的 <strong>代价</strong> 为 <code>min(2, 1)</code> (元素 <code>1</code> 和  <code>2</code> 小于 <code>3</code> ，元素 <code>5</code> 大于 <code>3</code> ），插入后 <code>nums</code> 变成 <code>[1,2,3,3,5]</code> 。</p>\n\n<p>请你返回将 <code>instructions</code> 中所有元素依次插入 <code>nums</code> 后的 <strong>总最小代价 </strong>。由于答案会很大，请将它对 <code>10<sup>9</sup> + 7</code> <b>取余</b> 后返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>instructions = [1,5,6,2]\n<b>输出：</b>1\n<b>解释：</b>一开始 nums = [] 。\n插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。\n插入 5 ，代价为 min(1, 0) = 0 ，现在 nums = [1,5] 。\n插入 6 ，代价为 min(2, 0) = 0 ，现在 nums = [1,5,6] 。\n插入 2 ，代价为 min(1, 2) = 1 ，现在 nums = [1,2,5,6] 。\n总代价为 0 + 0 + 0 + 1 = 1 。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><b>输入：</b>instructions = [1,2,3,6,5,4]\n<b>输出：</b>3\n<b>解释：</b>一开始 nums = [] 。\n插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。\n插入 2 ，代价为 min(1, 0) = 0 ，现在 nums = [1,2] 。\n插入 3 ，代价为 min(2, 0) = 0 ，现在 nums = [1,2,3] 。\n插入 6 ，代价为 min(3, 0) = 0 ，现在 nums = [1,2,3,6] 。\n插入 5 ，代价为 min(3, 1) = 1 ，现在 nums = [1,2,3,5,6] 。\n插入 4 ，代价为 min(3, 2) = 2 ，现在 nums = [1,2,3,4,5,6] 。\n总代价为 0 + 0 + 0 + 0 + 1 + 2 = 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>instructions = [1,3,3,3,2,4,2,1,2]\n<b>输出：</b>4\n<b>解释：</b>一开始 nums = [] 。\n插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。\n插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3] 。\n插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3,3] 。\n插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3,3,3] 。\n插入 2 ，代价为 min(1, 3) = 1 ，现在 nums = [1,2,3,3,3] 。\n插入 4 ，代价为 min(5, 0) = 0 ，现在 nums = [1,2,3,3,3,4] 。\n​​​​​插入 2 ，代价为 min(1, 4) = 1 ，现在 nums = [1,2,2,3,3,3,4] 。\n插入 1 ，代价为 min(0, 6) = 0 ，现在 nums = [1,1,2,2,3,3,3,4] 。\n插入 2 ，代价为 min(2, 4) = 2 ，现在 nums = [1,1,2,2,2,3,3,3,4] 。\n总代价为 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= instructions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= instructions[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1650.二叉树的最近公共祖先 III",
        "hardRate": "MEDIUM",
        "passRate": "80.00%",
        "problemsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    }
]