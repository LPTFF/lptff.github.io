[
    {
        "problemsName": " 1051.高度检查器",
        "hardRate": "EASY",
        "passRate": "80.04%",
        "problemsUrl": "https://leetcode.cn/problems/height-checker/",
        "solutionsUrl": "https://leetcode.cn/problems/height-checker/solution",
        "problemsDesc": "<p>学校打算为全体学生拍一张年度纪念照。根据要求，学生需要按照 <strong>非递减</strong> 的高度顺序排成一行。</p>\n\n<p>排序后的高度情况用整数数组 <code>expected</code> 表示，其中 <code>expected[i]</code> 是预计排在这一行中第 <code>i</code> 位的学生的高度（<strong>下标从 0 开始</strong>）。</p>\n\n<p>给你一个整数数组 <code>heights</code> ，表示 <strong>当前学生站位</strong> 的高度情况。<code>heights[i]</code> 是这一行中第 <code>i</code> 位学生的高度（<strong>下标从 0 开始</strong>）。</p>\n\n<p>返回满足<em> </em><code>heights[i] != expected[i]</code> 的 <strong>下标数量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>heights =&nbsp;[1,1,4,2,1,3]\n<strong>输出：</strong>3 \n<strong>解释：</strong>\n高度：[1,1,<em><strong>4</strong></em>,2,<em><strong>1</strong></em>,<em><strong>3</strong></em>]\n预期：[1,1,<em><strong>1</strong></em>,2,<em><strong>3</strong></em>,<em><strong>4</strong></em>]\n下标 2 、4 、5 处的学生高度不匹配。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>heights = [5,1,2,3,4]\n<strong>输出：</strong>5\n<strong>解释：</strong>\n高度：[<em><strong>5</strong></em>,<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>,<em><strong>4</strong></em>]\n预期：[<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>,<em><strong>4</strong></em>,<em><strong>5</strong></em>]\n所有下标的对应学生高度都不匹配。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>heights = [1,2,3,4,5]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n高度：[1,2,3,4,5]\n预期：[1,2,3,4,5]\n所有下标的对应学生高度都匹配。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= heights.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= heights[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1052.爱生气的书店老板",
        "hardRate": "MEDIUM",
        "passRate": "58.00%",
        "problemsUrl": "https://leetcode.cn/problems/grumpy-bookstore-owner/",
        "solutionsUrl": "https://leetcode.cn/problems/grumpy-bookstore-owner/solution",
        "problemsDesc": "<p>有一个书店老板，他的书店开了&nbsp;<code>n</code>&nbsp;分钟。每分钟都有一些顾客进入这家商店。给定一个长度为 <code>n</code> 的整数数组 <code>customers</code> ，其中 <code>customers[i]</code> 是在第 <code>i</code> 分钟开始时进入商店的顾客数量，所有这些顾客在第 <code>i</code> 分钟结束后离开。</p>\n\n<p>在某些时候，书店老板会生气。 如果书店老板在第 <code>i</code> 分钟生气，那么 <code>grumpy[i] = 1</code>，否则 <code>grumpy[i] = 0</code>。</p>\n\n<p>当书店老板生气时，那一分钟的顾客就会不满意，若老板不生气则顾客是满意的。</p>\n\n<p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续&nbsp;<code>minutes</code>&nbsp;分钟不生气，但却只能使用一次。</p>\n\n<p>请你返回 <em>这一天营业下来，最多有多少客户能够感到满意</em> 。<br />\n&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\n<strong>输出：</strong>16\n<strong>解释：</strong>书店老板在最后 3 分钟保持冷静。\n感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>customers = [1], grumpy = [0], minutes = 1\n<strong>输出：</strong>1</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == customers.length == grumpy.length</code></li>\n\t<li><code>1 &lt;= minutes &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= customers[i] &lt;= 1000</code></li>\n\t<li><code>grumpy[i] == 0 or 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1053.交换一次的先前排列",
        "hardRate": "MEDIUM",
        "passRate": "48.32%",
        "problemsUrl": "https://leetcode.cn/problems/previous-permutation-with-one-swap/",
        "solutionsUrl": "https://leetcode.cn/problems/previous-permutation-with-one-swap/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>arr</code>（可能存在重复的元素），请你返回可在&nbsp;<strong>一次交换</strong>（交换两数字 <code>arr[i]</code> 和 <code>arr[j]</code> 的位置）后得到的、按字典序排列小于 <code>arr</code> 的最大排列。</p>\n\n<p>如果无法这么操作，就请返回原数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,2,1]\n<strong>输出：</strong>[3,1,2]\n<strong>解释：</strong>交换 2 和 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,1,5]\n<strong>输出：</strong>[1,1,5]\n<strong>解释：</strong>已经是最小排列\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,9,4,6,7]\n<strong>输出：</strong>[1,7,4,6,9]\n<strong>解释：</strong>交换 9 和 7\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1054.距离相等的条形码",
        "hardRate": "MEDIUM",
        "passRate": "44.83%",
        "problemsUrl": "https://leetcode.cn/problems/distant-barcodes/",
        "solutionsUrl": "https://leetcode.cn/problems/distant-barcodes/solution",
        "problemsDesc": "<p>在一个仓库里，有一排条形码，其中第 <code>i</code> 个条形码为&nbsp;<code>barcodes[i]</code>。</p>\n\n<p>请你重新排列这些条形码，使其中任意两个相邻的条形码不能相等。 你可以返回任何满足该要求的答案，此题保证存在答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>barcodes = [1,1,1,2,2,2]\n<strong>输出：</strong>[2,1,2,1,2,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>barcodes = [1,1,1,1,2,2,3,3]\n<strong>输出：</strong>[1,3,1,3,2,1,2,1]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= barcodes.length &lt;= 10000</code></li>\n\t<li><code>1 &lt;= barcodes[i] &lt;= 10000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1055.形成字符串的最短路径",
        "hardRate": "MEDIUM",
        "passRate": "60.54%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-way-to-form-string/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-way-to-form-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1056.易混淆数",
        "hardRate": "EASY",
        "passRate": "43.63%",
        "problemsUrl": "https://leetcode.cn/problems/confusing-number/",
        "solutionsUrl": "https://leetcode.cn/problems/confusing-number/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1057.校园自行车分配",
        "hardRate": "MEDIUM",
        "passRate": "51.07%",
        "problemsUrl": "https://leetcode.cn/problems/campus-bikes/",
        "solutionsUrl": "https://leetcode.cn/problems/campus-bikes/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1058.最小化舍入误差以满足目标",
        "hardRate": "MEDIUM",
        "passRate": "37.37%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-rounding-error-to-meet-target/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-rounding-error-to-meet-target/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1059.从始点到终点的所有路径",
        "hardRate": "MEDIUM",
        "passRate": "35.69%",
        "problemsUrl": "https://leetcode.cn/problems/all-paths-from-source-lead-to-destination/",
        "solutionsUrl": "https://leetcode.cn/problems/all-paths-from-source-lead-to-destination/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1060.有序数组中的缺失元素",
        "hardRate": "MEDIUM",
        "passRate": "54.74%",
        "problemsUrl": "https://leetcode.cn/problems/missing-element-in-sorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/missing-element-in-sorted-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1061.按字典序排列最小的等效字符串",
        "hardRate": "MEDIUM",
        "passRate": "64.58%",
        "problemsUrl": "https://leetcode.cn/problems/lexicographically-smallest-equivalent-string/",
        "solutionsUrl": "https://leetcode.cn/problems/lexicographically-smallest-equivalent-string/solution",
        "problemsDesc": "<p>给出长度相同的两个字符串<code>s1</code> 和&nbsp;<code>s2</code>&nbsp;，还有一个字符串&nbsp;<code>baseStr</code>&nbsp;。</p>\n\n<p>其中 &nbsp;<code>s1[i]</code>&nbsp;和&nbsp;<code>s2[i]</code>&nbsp; 是一组等价字符。</p>\n\n<ul>\n\t<li>举个例子，如果&nbsp;<code>s1 = \"abc\"</code> 且&nbsp;<code>s2 = \"cde\"</code>，那么就有&nbsp;<code>'a' == 'c', 'b' == 'd', 'c' == 'e'</code>。</li>\n</ul>\n\n<p>等价字符遵循任何等价关系的一般规则：</p>\n\n<ul>\n\t<li><strong>&nbsp;自反性&nbsp;</strong>：<code>'a' == 'a'</code></li>\n\t<li>&nbsp;<strong>对称性&nbsp;</strong>：<code>'a' == 'b'</code> 则必定有 <code>'b' == 'a'</code></li>\n\t<li>&nbsp;<strong>传递性</strong> ：<code>'a' == 'b'</code> 且 <code>'b' == 'c'</code> 就表明 <code>'a' == 'c'</code></li>\n</ul>\n\n<p>例如，&nbsp;<code>s1 = \"abc\"</code>&nbsp;和&nbsp;<code>s2 = \"cde\"</code>&nbsp;的等价信息和之前的例子一样，那么&nbsp;<code>baseStr = \"eed\"</code>&nbsp;, <code>\"acd\"</code>&nbsp;或&nbsp;<code>\"aab\"</code>，这三个字符串都是等价的，而&nbsp;<code>\"aab\"</code>&nbsp;是&nbsp;<code>baseStr</code>&nbsp;的按字典序最小的等价字符串</p>\n\n<p>利用<em>&nbsp;</em><code>s1</code>&nbsp;和&nbsp;<code>s2</code>&nbsp;的等价信息，找出并返回<em>&nbsp;</em><code>baseStr</code><em>&nbsp;</em>的按字典序排列最小的等价字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\n<strong>输出：</strong>\"makkek\"\n<strong>解释：</strong>根据 <code>A</code> 和 <code>B 中的等价信息，</code>我们可以将这些字符分为 <code>[m,p]</code>, <code>[a,o]</code>, <code>[k,r,s]</code>, <code>[e,i] 共 4 组</code>。每组中的字符都是等价的，并按字典序排列。所以答案是 <code>\"makkek\"</code>。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"hello\", s2 = \"world\", baseStr = \"hold\"\n<strong>输出：</strong>\"hdld\"\n<strong>解释：</strong>根据 <code>A</code> 和 <code>B 中的等价信息，</code>我们可以将这些字符分为 <code>[h,w]</code>, <code>[d,e,o]</code>, <code>[l,r] 共 3 组</code>。所以只有 S 中的第二个字符 <code>'o'</code> 变成 <code>'d'，最后答案为 </code><code>\"hdld\"</code>。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"leetcode\", s2 = \"programs\", baseStr = \"sourcecode\"\n<strong>输出：</strong>\"aauaaaaada\"\n<strong>解释：</strong>我们可以把 A 和 B 中的等价字符分为 <code>[a,o,e,r,s,c]</code>, <code>[l,p]</code>, <code>[g,t]</code> 和 <code>[d,m] 共 4 组</code>，因此 <code>S</code> 中除了 <code>'u'</code> 和 <code>'d'</code> 之外的所有字母都转化成了 <code>'a'</code>，最后答案为 <code>\"aauaaaaada\"</code>。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length, baseStr &lt;= 1000</code></li>\n\t<li><code>s1.length == s2.length</code></li>\n\t<li>字符串<code>s1</code>,&nbsp;<code>s2</code>, and&nbsp;<code>baseStr</code>&nbsp;仅由从&nbsp;<code>'a'</code> 到&nbsp;<code>'z'</code>&nbsp;的小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1062.最长重复子串",
        "hardRate": "MEDIUM",
        "passRate": "56.96%",
        "problemsUrl": "https://leetcode.cn/problems/longest-repeating-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-repeating-substring/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1063.有效子数组的数目",
        "hardRate": "HARD",
        "passRate": "73.84%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-valid-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-valid-subarrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1064.不动点",
        "hardRate": "EASY",
        "passRate": "64.64%",
        "problemsUrl": "https://leetcode.cn/problems/fixed-point/",
        "solutionsUrl": "https://leetcode.cn/problems/fixed-point/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1065.字符串的索引对",
        "hardRate": "EASY",
        "passRate": "56.40%",
        "problemsUrl": "https://leetcode.cn/problems/index-pairs-of-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/index-pairs-of-a-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1066.校园自行车分配 II",
        "hardRate": "MEDIUM",
        "passRate": "51.28%",
        "problemsUrl": "https://leetcode.cn/problems/campus-bikes-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/campus-bikes-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1067.范围内的数字计数",
        "hardRate": "HARD",
        "passRate": "48.30%",
        "problemsUrl": "https://leetcode.cn/problems/digit-count-in-range/",
        "solutionsUrl": "https://leetcode.cn/problems/digit-count-in-range/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1068.产品销售分析 I",
        "hardRate": "EASY",
        "passRate": "86.68%",
        "problemsUrl": "https://leetcode.cn/problems/product-sales-analysis-i/",
        "solutionsUrl": "https://leetcode.cn/problems/product-sales-analysis-i/solution",
        "problemsDesc": "<p>销售表&nbsp;<code>Sales</code>：</p>\n\n<pre>\n+-------------+-------+\n| Column Name | Type  |\n+-------------+-------+\n| sale_id     | int   |\n| product_id  | int   |\n| year        | int   |\n| quantity    | int   |\n| price       | int   |\n+-------------+-------+\n(sale_id, year) 是销售表 Sales 的主键.\nproduct_id 是关联到产品表 Product 的外键.\n注意: price 表示每单位价格\n</pre>\n\n<p>产品表&nbsp;<code>Product</code>：</p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| product_id   | int     |\n| product_name | varchar |\n+--------------+---------+\nproduct_id&nbsp;是表的主键.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条SQL&nbsp;查询语句获取 <code>Sales</code>&nbsp;表中所有产品对应的 <strong>产品名称 product_name</strong> 以及该产品的所有 <strong>售卖年份 year</strong>&nbsp;和 <strong>价格 price</strong> 。</p>\n\n<p>查询结果中的顺序无特定要求。</p>\n\n<p>查询结果格式示例如下：</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code>Sales</code> 表：\n+---------+------------+------+----------+-------+\n| sale_id | product_id | year | quantity | price |\n+---------+------------+------+----------+-------+ \n| 1       | 100        | 2008 | 10       | 5000  |\n| 2       | 100        | 2009 | 12       | 5000  |\n| 7       | 200        | 2011 | 15       | 9000  |\n+---------+------------+------+----------+-------+\n\nProduct 表：\n+------------+--------------+\n| product_id | product_name |\n+------------+--------------+\n| 100        | Nokia        |\n| 200        | Apple        |\n| 300        | Samsung      |\n+------------+--------------+\n\nResult 表：\n+--------------+-------+-------+\n| product_name | year  | price |\n+--------------+-------+-------+\n| Nokia        | 2008  | 5000  |\n| Nokia        | 2009  | 5000  |\n| Apple        | 2011  | 9000  |\n+--------------+-------+-------+\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1069.产品销售分析 II",
        "hardRate": "EASY",
        "passRate": "81.77%",
        "problemsUrl": "https://leetcode.cn/problems/product-sales-analysis-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/product-sales-analysis-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1070.产品销售分析 III",
        "hardRate": "MEDIUM",
        "passRate": "47.81%",
        "problemsUrl": "https://leetcode.cn/problems/product-sales-analysis-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/product-sales-analysis-iii/solution",
        "problemsDesc": "<p>销售表&nbsp;<code>Sales</code>：</p>\n\n<pre>\n+-------------+-------+\n| Column Name | Type  |\n+-------------+-------+\n| sale_id     | int   |\n| product_id  | int   |\n| year        | int   |\n| quantity    | int   |\n| price       | int   |\n+-------------+-------+\n(sale_id, year) 是这张表的主键。\nproduct_id 是产品表的外键。\n这张表的每一行都表示：编号 product_id 的产品在某一年的销售额。\n请注意，价格是按每单位计的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>产品表&nbsp;<code>Product</code>：</p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| product_id   | int     |\n| product_name | varchar |\n+--------------+---------+\nproduct_id 是这张表的主键。\n这张表的每一行都标识：每个产品的 id 和 产品名称。</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询，选出每个销售产品&nbsp;<strong>第一年</strong> 销售的 <strong>产品 id</strong>、<strong>年份</strong>、<strong>数量&nbsp;</strong>和 <strong>价格</strong>。</p>\n\n<p>结果表中的条目可以按 <strong>任意顺序</strong> 排列。</p>\n\n<p>查询结果格式如下例所示：</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nSales 表：\n+---------+------------+------+----------+-------+\n| sale_id | product_id | year | quantity | price |\n+---------+------------+------+----------+-------+ \n| 1       | 100        | 2008 | 10       | 5000  |\n| 2       | 100        | 2009 | 12       | 5000  |\n| 7       | 200        | 2011 | 15       | 9000  |\n+---------+------------+------+----------+-------+\nProduct 表：\n+------------+--------------+\n| product_id | product_name |\n+------------+--------------+\n| 100        | Nokia        |\n| 200        | Apple        |\n| 300        | Samsung      |\n+------------+--------------+\n<strong>输出：</strong>\n+------------+------------+----------+-------+\n| product_id | first_year | quantity | price |\n+------------+------------+----------+-------+ \n| 100        | 2008       | 10       | 5000  |\n| 200        | 2011       | 15       | 9000  |\n+------------+------------+----------+-------+</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1071.字符串的最大公因子",
        "hardRate": "EASY",
        "passRate": "57.74%",
        "problemsUrl": "https://leetcode.cn/problems/greatest-common-divisor-of-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/greatest-common-divisor-of-strings/solution",
        "problemsDesc": "<p>对于字符串&nbsp;<code>s</code> 和&nbsp;<code>t</code>，只有在&nbsp;<code>s = t + ... + t</code>（<code>t</code> 自身连接 1 次或多次）时，我们才认定&nbsp;“<code>t</code> 能除尽 <code>s</code>”。</p>\n\n<p>给定两个字符串&nbsp;<code>str1</code>&nbsp;和&nbsp;<code>str2</code>&nbsp;。返回 <em>最长字符串&nbsp;<code>x</code>，要求满足&nbsp;<code>x</code> 能除尽 <code>str1</code> 且 <code>x</code> 能除尽 <code>str2</code></em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>str1 = \"ABCABC\", str2 = \"ABC\"\n<strong>输出：</strong>\"ABC\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>str1 = \"ABABAB\", str2 = \"ABAB\"\n<strong>输出：</strong>\"AB\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>str1 = \"LEET\", str2 = \"CODE\"\n<strong>输出：</strong>\"\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= str1.length, str2.length &lt;= 1000</code></li>\n\t<li><code>str1</code>&nbsp;和&nbsp;<code>str2</code>&nbsp;由大写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1072.按列翻转得到最大值等行数",
        "hardRate": "MEDIUM",
        "passRate": "71.31%",
        "problemsUrl": "https://leetcode.cn/problems/flip-columns-for-maximum-number-of-equal-rows/",
        "solutionsUrl": "https://leetcode.cn/problems/flip-columns-for-maximum-number-of-equal-rows/solution",
        "problemsDesc": "<p>给定&nbsp;<code>m x n</code>&nbsp;矩阵&nbsp;<code>matrix</code>&nbsp;。</p>\n\n<p>你可以从中选出任意数量的列并翻转其上的&nbsp;<strong>每个&nbsp;</strong>单元格。（即翻转后，单元格的值从 <code>0</code> 变成 <code>1</code>，或者从 <code>1</code> 变为 <code>0</code> 。）</p>\n\n<p>返回 <em>经过一些翻转后，行内所有值都相等的最大行数</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[0,1],[1,1]]\n<strong>输出：</strong>1\n<strong>解释：</strong>不进行翻转，有 1 行所有值都相等。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[0,1],[1,0]]\n<strong>输出：</strong>2\n<strong>解释：</strong>翻转第一列的值之后，这两行都由相等的值组成。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[0,0,0],[0,0,1],[1,1,0]]\n<strong>输出：</strong>2\n<strong>解释：</strong>翻转前两列的值之后，后两行由相等的值组成。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>matrix[i][j] == 0</code> 或&nbsp;<code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1073.负二进制数相加",
        "hardRate": "MEDIUM",
        "passRate": "41.60%",
        "problemsUrl": "https://leetcode.cn/problems/adding-two-negabinary-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/adding-two-negabinary-numbers/solution",
        "problemsDesc": "<p>给出基数为 <strong>-2</strong>&nbsp;的两个数&nbsp;<code>arr1</code> 和&nbsp;<code>arr2</code>，返回两数相加的结果。</p>\n\n<p>数字以&nbsp;<em>数组形式</em><strong>&nbsp;</strong>给出：数组由若干 0 和 1 组成，按最高有效位到最低有效位的顺序排列。例如，<code>arr&nbsp;= [1,1,0,1]</code>&nbsp;表示数字&nbsp;<code>(-2)^3&nbsp;+ (-2)^2 + (-2)^0 = -3</code>。<em>数组形式</em>&nbsp;中的数字 <code>arr</code> 也同样不含前导零：即&nbsp;<code>arr == [0]</code>&nbsp;或&nbsp;<code>arr[0] == 1</code>。</p>\n\n<p>返回相同表示形式的 <code>arr1</code> 和 <code>arr2</code> 相加的结果。两数的表示形式为：不含前导零、由若干 0 和 1 组成的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [1,1,1,1,1], arr2 = [1,0,1]\n<strong>输出：</strong>[1,0,0,0,0]\n<strong>解释：</strong>arr1 表示 11，arr2 表示 5，输出表示 16 。\n</pre>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [0], arr2 = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [0], arr2 = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>1 &lt;= arr1.length,&nbsp;arr2.length &lt;= 1000</code></li>\n\t<li><code>arr1[i]</code>&nbsp;和&nbsp;<code>arr2[i]</code>&nbsp;都是&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code></li>\n\t<li><code>arr1</code>&nbsp;和&nbsp;<code>arr2</code>&nbsp;都没有前导0</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1074.元素和为目标值的子矩阵数量",
        "hardRate": "HARD",
        "passRate": "67.39%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-submatrices-that-sum-to-target/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-submatrices-that-sum-to-target/solution",
        "problemsDesc": "<p>给出矩阵 <code>matrix</code> 和目标值 <code>target</code>，返回元素总和等于目标值的非空子矩阵的数量。</p>\n\n<p>子矩阵 <code>x1, y1, x2, y2</code> 是满足 <code>x1 <= x <= x2</code> 且 <code>y1 <= y <= y2</code> 的所有单元 <code>matrix[x][y]</code> 的集合。</p>\n\n<p>如果 <code>(x1, y1, x2, y2)</code> 和 <code>(x1', y1', x2', y2')</code> 两个子矩阵中部分坐标不同（如：<code>x1 != x1'</code>），那么这两个子矩阵也不同。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/02/mate1.jpg\" style=\"width: 242px; height: 242px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0\n<strong>输出：</strong>4\n<strong>解释：</strong>四个只含 0 的 1x1 子矩阵。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,-1],[-1,1]], target = 0\n<strong>输出：</strong>5\n<strong>解释：</strong>两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[904]], target = 0\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong><strong>提示：</strong></strong></p>\n\n<ul>\n\t<li><code>1 <= matrix.length <= 100</code></li>\n\t<li><code>1 <= matrix[0].length <= 100</code></li>\n\t<li><code>-1000 <= matrix[i] <= 1000</code></li>\n\t<li><code>-10^8 <= target <= 10^8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1075.项目员工 I",
        "hardRate": "EASY",
        "passRate": "70.07%",
        "problemsUrl": "https://leetcode.cn/problems/project-employees-i/",
        "solutionsUrl": "https://leetcode.cn/problems/project-employees-i/solution",
        "problemsDesc": "<p>项目表&nbsp;<code>Project</code>：&nbsp;</p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| project_id  | int     |\n| employee_id | int     |\n+-------------+---------+\n主键为 (project_id, employee_id)。\nemployee_id 是员工表 <code>Employee 表的外键。</code>\n</pre>\n\n<p>员工表&nbsp;<code>Employee</code>：</p>\n\n<pre>\n+------------------+---------+\n| Column Name      | Type    |\n+------------------+---------+\n| employee_id      | int     |\n| name             | varchar |\n| experience_years | int     |\n+------------------+---------+\n主键是 employee_id。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>请写一个 SQL&nbsp;语句，查询每一个项目中员工的&nbsp;<strong>平均&nbsp;</strong>工作年限，<strong>精确到小数点后两位</strong>。</p>\n\n<p>查询结果的格式如下：</p>\n\n<pre>\nProject 表：\n+-------------+-------------+\n| project_id  | employee_id |\n+-------------+-------------+\n| 1           | 1           |\n| 1           | 2           |\n| 1           | 3           |\n| 2           | 1           |\n| 2           | 4           |\n+-------------+-------------+\n\nEmployee 表：\n+-------------+--------+------------------+\n| employee_id | name   | experience_years |\n+-------------+--------+------------------+\n| 1           | Khaled | 3                |\n| 2           | Ali    | 2                |\n| 3           | John   | 1                |\n| 4           | Doe    | 2                |\n+-------------+--------+------------------+\n\nResult 表：\n+-------------+---------------+\n| project_id  | average_years |\n+-------------+---------------+\n| 1           | 2.00          |\n| 2           | 2.50          |\n+-------------+---------------+\n第一个项目中，员工的平均工作年限是 (3 + 2 + 1) / 3 = 2.00；第二个项目中，员工的平均工作年限是 (3 + 2) / 2 = 2.50\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1076.项目员工II",
        "hardRate": "EASY",
        "passRate": "49.38%",
        "problemsUrl": "https://leetcode.cn/problems/project-employees-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/project-employees-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1077.项目员工 III",
        "hardRate": "MEDIUM",
        "passRate": "72.33%",
        "problemsUrl": "https://leetcode.cn/problems/project-employees-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/project-employees-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1078.Bigram 分词",
        "hardRate": "EASY",
        "passRate": "65.16%",
        "problemsUrl": "https://leetcode.cn/problems/occurrences-after-bigram/",
        "solutionsUrl": "https://leetcode.cn/problems/occurrences-after-bigram/solution",
        "problemsDesc": "<p>给出第一个词&nbsp;<code>first</code> 和第二个词&nbsp;<code>second</code>，考虑在某些文本&nbsp;<code>text</code>&nbsp;中可能以 <code>\"first second third\"</code> 形式出现的情况，其中&nbsp;<code>second</code>&nbsp;紧随&nbsp;<code>first</code>&nbsp;出现，<code>third</code>&nbsp;紧随&nbsp;<code>second</code>&nbsp;出现。</p>\n\n<p>对于每种这样的情况，将第三个词 \"<code>third</code>\" 添加到答案中，并返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\"\n<strong>输出：</strong>[\"girl\",\"student\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = \"we will we will rock you\", first = \"we\", second = \"will\"\n<strong>输出：</strong>[\"we\",\"rock\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 1000</code></li>\n\t<li><code>text</code>&nbsp;由小写英文字母和空格组成</li>\n\t<li><code>text</code> 中的所有单词之间都由 <strong>单个空格字符</strong> 分隔</li>\n\t<li><code>1 &lt;= first.length, second.length &lt;= 10</code></li>\n\t<li><code>first</code> 和&nbsp;<code>second</code>&nbsp;由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1079.活字印刷",
        "hardRate": "MEDIUM",
        "passRate": "79.08%",
        "problemsUrl": "https://leetcode.cn/problems/letter-tile-possibilities/",
        "solutionsUrl": "https://leetcode.cn/problems/letter-tile-possibilities/solution",
        "problemsDesc": "<p>你有一套活字字模&nbsp;<code>tiles</code>，其中每个字模上都刻有一个字母&nbsp;<code>tiles[i]</code>。返回你可以印出的非空字母序列的数目。</p>\n\n<p><strong>注意：</strong>本题中，每个活字字模只能使用一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\"AAB\"\n<strong>输出：</strong>8\n<strong>解释：</strong>可能的序列为 \"A\", \"B\", \"AA\", \"AB\", \"BA\", \"AAB\", \"ABA\", \"BAA\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\"AAABBC\"\n<strong>输出：</strong>188\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>\"V\"\n<strong>输出：</strong>1</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tiles.length &lt;= 7</code></li>\n\t<li><code>tiles</code> 由大写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1080.根到叶路径上的不足节点",
        "hardRate": "MEDIUM",
        "passRate": "61.41%",
        "problemsUrl": "https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/",
        "solutionsUrl": "https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/solution",
        "problemsDesc": "<p>给你二叉树的根节点 <code>root</code> 和一个整数 <code>limit</code> ，请你同时删除树中所有 <strong>不足节点 </strong>，并返回最终二叉树的根节点。</p>\n\n<p>假如通过节点 <code>node</code> 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 <code>limit</code>，则该节点被称之为<strong> 不足节点 </strong>，需要被删除。</p>\n\n<p><strong>叶子节点</strong>，就是没有子节点的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/06/05/insufficient-11.png\" style=\"width: 500px; height: 207px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1\n<strong>输出：</strong>[1,2,3,4,null,null,7,8,9,null,14]\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/06/05/insufficient-3.png\" style=\"width: 400px; height: 274px;\" />\n<pre>\n<strong>输入：</strong>root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22\n<strong>输出：</strong>[5,4,8,11,null,17,4,7,null,null,null,5]\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/06/11/screen-shot-2019-06-11-at-83301-pm.png\" style=\"width: 250px; height: 199px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,-3,-5,null,4,null], limit = -1\n<strong>输出：</strong>[1,null,-3,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 5000]</code> 内</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= limit &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1081.不同字符的最小子序列",
        "hardRate": "MEDIUM",
        "passRate": "58.40%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/solution",
        "problemsDesc": "<p>返回 <code>s</code> 字典序最小的子序列，该子序列包含 <code>s</code> 的所有不同字符，且只包含一次。</p>\n\n<p><strong>注意：</strong>该题与 316 <a href=\"https://leetcode.com/problems/remove-duplicate-letters/\">https://leetcode.com/problems/remove-duplicate-letters/</a> 相同</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>s = \"bcabc\"</code>\n<strong>输出<code>：</code></strong><code>\"abc\"</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>s = \"cbacdcbc\"</code>\n<strong>输出：</strong><code>\"acdb\"</code></pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 1000</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1082.销售分析 I ",
        "hardRate": "EASY",
        "passRate": "76.55%",
        "problemsUrl": "https://leetcode.cn/problems/sales-analysis-i/",
        "solutionsUrl": "https://leetcode.cn/problems/sales-analysis-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1083.销售分析 II",
        "hardRate": "EASY",
        "passRate": "52.98%",
        "problemsUrl": "https://leetcode.cn/problems/sales-analysis-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/sales-analysis-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1084.销售分析III",
        "hardRate": "EASY",
        "passRate": "52.18%",
        "problemsUrl": "https://leetcode.cn/problems/sales-analysis-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/sales-analysis-iii/solution",
        "problemsDesc": "<p>Table:&nbsp;<code>Product</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| product_id   | int     |\n| product_name | varchar |\n| unit_price   | int     |\n+--------------+---------+\nProduct_id是该表的主键。\n该表的每一行显示每个产品的名称和价格。\n</pre>\n\n<p>Table:&nbsp;<code>Sales</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| seller_id   | int     |\n| product_id  | int     |\n| buyer_id    | int     |\n| sale_date   | date    |\n| quantity    | int     |\n| price       | int     |\n+------ ------+---------+\n这个表没有主键，它可以有重复的行。\nproduct_id 是 Product 表的外键。\n该表的每一行包含关于一个销售的一些信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个SQL查询，报告<code>2019年春季</code>才售出的产品。即<strong>仅</strong>在<code><strong>2019-01-01</strong></code>至<code><strong>2019-03-31</strong></code>（含）之间出售的商品。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nProduct table:\n+------------+--------------+------------+\n| product_id | product_name | unit_price |\n+------------+--------------+------------+\n| 1          | S8           | 1000       |\n| 2          | G4           | 800        |\n| 3          | iPhone       | 1400       |\n+------------+--------------+------------+\n<code>Sales </code>table:\n+-----------+------------+----------+------------+----------+-------+\n| seller_id | product_id | buyer_id | sale_date  | quantity | price |\n+-----------+------------+----------+------------+----------+-------+\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\n| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |\n| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |\n+-----------+------------+----------+------------+----------+-------+\n<strong>输出：</strong>\n+-------------+--------------+\n| product_id  | product_name |\n+-------------+--------------+\n| 1           | S8           |\n+-------------+--------------+\n<strong>解释:</strong>\nid为1的产品仅在2019年春季销售。\nid为2的产品在2019年春季销售，但也在2019年春季之后销售。\nid 3的产品在2019年春季之后销售。\n我们只退回产品1，因为它是2019年春季才销售的产品。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1085.最小元素各数位之和",
        "hardRate": "EASY",
        "passRate": "77.93%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-digits-in-the-minimum-number/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-digits-in-the-minimum-number/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1086.前五科的均分",
        "hardRate": "EASY",
        "passRate": "67.87%",
        "problemsUrl": "https://leetcode.cn/problems/high-five/",
        "solutionsUrl": "https://leetcode.cn/problems/high-five/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1087.花括号展开",
        "hardRate": "MEDIUM",
        "passRate": "56.81%",
        "problemsUrl": "https://leetcode.cn/problems/brace-expansion/",
        "solutionsUrl": "https://leetcode.cn/problems/brace-expansion/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1088.易混淆数 II",
        "hardRate": "HARD",
        "passRate": "49.89%",
        "problemsUrl": "https://leetcode.cn/problems/confusing-number-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/confusing-number-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1089.复写零",
        "hardRate": "EASY",
        "passRate": "60.05%",
        "problemsUrl": "https://leetcode.cn/problems/duplicate-zeros/",
        "solutionsUrl": "https://leetcode.cn/problems/duplicate-zeros/solution",
        "problemsDesc": "<p>给你一个长度固定的整数数组&nbsp;<code>arr</code> ，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。</p>\n\n<p>注意：请不要在超过该数组长度的位置写入元素。请对输入的数组&nbsp;<strong>就地&nbsp;</strong>进行上述修改，不要从函数返回任何东西。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,0,2,3,0,4,5,0]\n<strong>输出：</strong>[1,0,0,2,3,0,0,4]\n<strong>解释：</strong>调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3]\n<strong>输出：</strong>[1,2,3]\n<strong>解释：</strong>调用函数后，输入的数组将被修改为：[1,2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1090.受标签影响的最大值",
        "hardRate": "MEDIUM",
        "passRate": "66.84%",
        "problemsUrl": "https://leetcode.cn/problems/largest-values-from-labels/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-values-from-labels/solution",
        "problemsDesc": "<p>我们有一个&nbsp;<code>n</code>&nbsp;项的集合。给出两个整数数组&nbsp;<code>values</code>&nbsp;和 <code>labels</code>&nbsp;，第 <code>i</code> 个元素的值和标签分别是&nbsp;<code>values[i]</code>&nbsp;和&nbsp;<code>labels[i]</code>。还会给出两个整数&nbsp;<code>numWanted</code>&nbsp;和 <code>useLimit</code> 。</p>\n\n<p>从 <code>n</code> 个元素中选择一个子集 <code>s</code> :</p>\n\n<ul>\n\t<li>子集 <code>s</code> 的大小&nbsp;<strong>小于或等于</strong> <code>numWanted</code> 。</li>\n\t<li><code>s</code> 中 <strong>最多</strong> 有相同标签的 <code>useLimit</code> 项。</li>\n</ul>\n\n<p>一个子集的&nbsp;<strong>分数&nbsp;</strong>是该子集的值之和。</p>\n\n<p>返回子集&nbsp;<code>s</code> 的最大 <strong>分数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [5,4,3,2,1], labels = [1,1,2,2,3], numWanted = 3, useLimit = 1\n<strong>输出：</strong>9\n<strong>解释：</strong>选出的子集是第一项，第三项和第五项。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [5,4,3,2,1], labels = [1,3,3,3,2], numWanted = 3, useLimit = 2\n<strong>输出：</strong>12\n<strong>解释：</strong>选出的子集是第一项，第二项和第三项。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [9,8,8,7,6], labels = [0,0,0,1,1], numWanted = 3, useLimit = 1\n<strong>输出：</strong>16\n<strong>解释：</strong>选出的子集是第一项和第四项。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == values.length == labels.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= values[i], labels[i] &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= numWanted, useLimit &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1091.二进制矩阵中的最短路径",
        "hardRate": "MEDIUM",
        "passRate": "40.37%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-in-binary-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-in-binary-matrix/solution",
        "problemsDesc": "<p>给你一个 <code>n x n</code> 的二进制矩阵 <code>grid</code> 中，返回矩阵中最短 <strong>畅通路径</strong> 的长度。如果不存在这样的路径，返回 <code>-1</code> 。</p>\n\n<p>二进制矩阵中的 畅通路径 是一条从 <strong>左上角</strong> 单元格（即，<code>(0, 0)</code>）到 右下角 单元格（即，<code>(n - 1, n - 1)</code>）的路径，该路径同时满足下述要求：</p>\n\n<ul>\n\t<li>路径途经的所有单元格的值都是 <code>0</code> 。</li>\n\t<li>路径中所有相邻的单元格应当在 <strong>8 个方向之一</strong> 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。</li>\n</ul>\n\n<p><strong>畅通路径的长度</strong> 是该路径途经的单元格总数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/example1_1.png\" style=\"width: 500px; height: 234px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,1],[1,0]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/example2_1.png\" style=\"height: 216px; width: 500px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,0,0],[1,1,0],[1,1,0]]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,0,0],[1,1,0],[1,1,0]]\n<strong>输出：</strong>-1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1092.最短公共超序列",
        "hardRate": "HARD",
        "passRate": "58.41%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-common-supersequence/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-common-supersequence/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>str1</code> 和&nbsp;<code>str2</code>，返回同时以&nbsp;<code>str1</code>&nbsp;和&nbsp;<code>str2</code>&nbsp;作为 <strong>子序列</strong> 的最短字符串。如果答案不止一个，则可以返回满足条件的 <strong>任意一个</strong> 答案。</p>\n\n<p>如果从字符串 <code>t</code> 中删除一些字符（也可能不删除），可以得到字符串 <code>s</code> ，那么 <code>s</code> 就是 t 的一个子序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>str1 = \"abac\", str2 = \"cab\"\n<strong>输出：</strong>\"cabac\"\n<strong>解释：</strong>\nstr1 = \"abac\" 是 \"cabac\" 的一个子串，因为我们可以删去 \"cabac\" 的第一个 \"c\"得到 \"abac\"。 \nstr2 = \"cab\" 是 \"cabac\" 的一个子串，因为我们可以删去 \"cabac\" 末尾的 \"ac\" 得到 \"cab\"。\n最终我们给出的答案是满足上述属性的最短字符串。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>str1 = \"aaaaaaaa\", str2 = \"aaaaaaaa\"\n<strong>输出：</strong>\"aaaaaaaa\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= str1.length, str2.length &lt;= 1000</code></li>\n\t<li><code>str1</code> 和&nbsp;<code>str2</code>&nbsp;都由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1093.大样本统计",
        "hardRate": "MEDIUM",
        "passRate": "41.91%",
        "problemsUrl": "https://leetcode.cn/problems/statistics-from-a-large-sample/",
        "solutionsUrl": "https://leetcode.cn/problems/statistics-from-a-large-sample/solution",
        "problemsDesc": "<p>我们对&nbsp;<code>0</code>&nbsp;到&nbsp;<code>255</code>&nbsp;之间的整数进行采样，并将结果存储在数组&nbsp;<code>count</code>&nbsp;中：<code>count[k]</code>&nbsp;就是整数&nbsp;<code>k</code> 在样本中出现的次数。</p>\n\n<p>计算以下统计数据:</p>\n\n<ul>\n\t<li><code>minimum</code>&nbsp;：样本中的最小元素。</li>\n\t<li><code>maximum</code>&nbsp;：样品中的最大元素。</li>\n\t<li><code>mean</code>&nbsp;：样本的平均值，计算为所有元素的总和除以元素总数。</li>\n\t<li><code>median</code>&nbsp;：\n\t<ul>\n\t\t<li>如果样本的元素个数是奇数，那么一旦样本排序后，中位数 <code>median</code> 就是中间的元素。</li>\n\t\t<li>如果样本中有偶数个元素，那么中位数<code>median</code> 就是样本排序后中间两个元素的平均值。</li>\n\t</ul>\n\t</li>\n\t<li><code>mode</code>&nbsp;：样本中出现次数最多的数字。保众数是 <strong>唯一</strong> 的。</li>\n</ul>\n\n<p>以浮点数数组的形式返回样本的统计信息<em>&nbsp;</em><code>[minimum, maximum, mean, median, mode]</code>&nbsp;。与真实答案误差在<em>&nbsp;</em><code>10<sup>-5</sup></code><em>&nbsp;</em>内的答案都可以通过。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n<strong>输出：</strong>[1.00000,3.00000,2.37500,2.50000,3.00000]\n<strong>解释：</strong>用count表示的样本为[1,2,2,2,3,3,3,3]。\n最小值和最大值分别为1和3。\n均值是(1+2+2+2+3+3+3+3) / 8 = 19 / 8 = 2.375。\n因为样本的大小是偶数，所以中位数是中间两个元素2和3的平均值，也就是2.5。\n众数为3，因为它在样本中出现的次数最多。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n<strong>输出：</strong>[1.00000,4.00000,2.18182,2.00000,1.00000]\n<strong>解释：</strong>用count表示的样本为[1,1,1,1,2,2,3,3,3,4,4]。\n最小值为1，最大值为4。\n平均数是(1+1+1+1+2+2+2+3+3+4+4)/ 11 = 24 / 11 = 2.18181818…(为了显示，输出显示了整数2.18182)。\n因为样本的大小是奇数，所以中值是中间元素2。\n众数为1，因为它在样本中出现的次数最多。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>count.length == 256</code></li>\n\t<li><code>0 &lt;= count[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= sum(count) &lt;= 10<sup>9</sup></code></li>\n\t<li>&nbsp;<code>count</code>&nbsp;的众数是 <strong>唯一</strong> 的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1094.拼车",
        "hardRate": "MEDIUM",
        "passRate": "51.73%",
        "problemsUrl": "https://leetcode.cn/problems/car-pooling/",
        "solutionsUrl": "https://leetcode.cn/problems/car-pooling/solution",
        "problemsDesc": "<p>车上最初有&nbsp;<code>capacity</code>&nbsp;个空座位。车&nbsp;<strong>只能&nbsp;</strong>向一个方向行驶（也就是说，<strong>不允许掉头或改变方向</strong>）</p>\n\n<p>给定整数&nbsp;<code>capacity</code>&nbsp;和一个数组 <code>trips</code> , &nbsp;<code>trip[i] = [numPassengers<sub>i</sub>, from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;表示第 <code>i</code> 次旅行有&nbsp;<code>numPassengers<sub>i</sub></code>&nbsp;乘客，接他们和放他们的位置分别是&nbsp;<code>from<sub>i</sub></code>&nbsp;和&nbsp;<code>to<sub>i</sub></code>&nbsp;。这些位置是从汽车的初始位置向东的公里数。</p>\n\n<p>当且仅当你可以在所有给定的行程中接送所有乘客时，返回&nbsp;<code>true</code>，否则请返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>trips = [[2,1,5],[3,3,7]], capacity = 4\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>trips = [[2,1,5],[3,3,7]], capacity = 5\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= trips.length &lt;= 1000</code></li>\n\t<li><code>trips[i].length == 3</code></li>\n\t<li><code>1 &lt;= numPassengers<sub>i</sub>&nbsp;&lt;= 100</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>&nbsp;&lt; to<sub>i</sub>&nbsp;&lt;= 1000</code></li>\n\t<li><code>1 &lt;= capacity &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1095.山脉数组中查找目标值",
        "hardRate": "HARD",
        "passRate": "37.73%",
        "problemsUrl": "https://leetcode.cn/problems/find-in-mountain-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-in-mountain-array/solution",
        "problemsDesc": "<p>（这是一个 <strong>交互式问题&nbsp;</strong>）</p>\n\n<p>给你一个 <strong>山脉数组</strong>&nbsp;<code>mountainArr</code>，请你返回能够使得&nbsp;<code>mountainArr.get(index)</code>&nbsp;<strong>等于</strong>&nbsp;<code>target</code>&nbsp;<strong>最小</strong>&nbsp;的下标 <code>index</code>&nbsp;值。</p>\n\n<p>如果不存在这样的下标 <code>index</code>，就请返回&nbsp;<code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p>何为山脉数组？如果数组&nbsp;<code>A</code> 是一个山脉数组的话，那它满足如下条件：</p>\n\n<p><strong>首先</strong>，<code>A.length &gt;= 3</code></p>\n\n<p><strong>其次</strong>，在&nbsp;<code>0 &lt; i&nbsp;&lt; A.length - 1</code>&nbsp;条件下，存在 <code>i</code> 使得：</p>\n\n<ul>\n\t<li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li>\n\t<li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>你将&nbsp;<strong>不能直接访问该山脉数组</strong>，必须通过&nbsp;<code>MountainArray</code>&nbsp;接口来获取数据：</p>\n\n<ul>\n\t<li><code>MountainArray.get(k)</code>&nbsp;- 会返回数组中索引为<code>k</code>&nbsp;的元素（下标从 0 开始）</li>\n\t<li><code>MountainArray.length()</code>&nbsp;- 会返回该数组的长度</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<p>对&nbsp;<code>MountainArray.get</code>&nbsp;发起超过 <code>100</code> 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。</p>\n\n<p>为了帮助大家更好地理解交互式问题，我们准备了一个样例 &ldquo;<strong>答案</strong>&rdquo;：<a href=\"https://leetcode-cn.com/playground/RKhe3ave\" target=\"_blank\">https://leetcode-cn.com/playground/RKhe3ave</a>，请注意这 <strong>不是一个正确答案</strong>。</p>\n\n<ol>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>array = [1,2,3,4,5,3,1], target = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>array = [0,1,2,4,2,1], target = 3\n<strong>输出：</strong>-1\n<strong>解释：</strong>3 在数组中没有出现，返回 -1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= mountain_arr.length() &lt;= 10000</code></li>\n\t<li><code>0 &lt;= target &lt;= 10^9</code></li>\n\t<li><code>0 &lt;= mountain_arr.get(index) &lt;=&nbsp;10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1096.花括号展开 II",
        "hardRate": "HARD",
        "passRate": "73.54%",
        "problemsUrl": "https://leetcode.cn/problems/brace-expansion-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/brace-expansion-ii/solution",
        "problemsDesc": "<p>如果你熟悉 Shell 编程，那么一定了解过花括号展开，它可以用来生成任意字符串。</p>\n\n<p>花括号展开的表达式可以看作一个由 <strong>花括号</strong>、<strong>逗号</strong> 和 <strong>小写英文字母</strong> 组成的字符串，定义下面几条语法规则：</p>\n\n<ul>\n\t<li>如果只给出单一的元素&nbsp;<code>x</code>，那么表达式表示的字符串就只有&nbsp;<code>\"x\"</code>。<code>R(x) = {x}</code>\n\n\t<ul>\n\t\t<li>例如，表达式 <code>\"a\"</code> 表示字符串 <code>\"a\"</code>。</li>\n\t\t<li>而表达式 <code>\"w\"</code> 就表示字符串 <code>\"w\"</code>。</li>\n\t</ul>\n\t</li>\n\t<li>当两个或多个表达式并列，以逗号分隔，我们取这些表达式中元素的并集。<code>R({e_1,e_2,...}) = R(e_1)&nbsp;∪ R(e_2)&nbsp;∪ ...</code>\n\t<ul>\n\t\t<li>例如，表达式 <code>\"{a,b,c}\"</code> 表示字符串&nbsp;<code>\"a\",\"b\",\"c\"</code>。</li>\n\t\t<li>而表达式 <code>\"{{a,b},{b,c}}\"</code> 也可以表示字符串&nbsp;<code>\"a\",\"b\",\"c\"</code>。</li>\n\t</ul>\n\t</li>\n\t<li>要是两个或多个表达式相接，中间没有隔开时，我们从这些表达式中各取一个元素依次连接形成字符串。<code>R(e_1 + e_2) = {a + b for (a, b) in&nbsp;R(e_1)&nbsp;× R(e_2)}</code>\n\t<ul>\n\t\t<li>例如，表达式 <code>\"{a,b}{c,d}\"</code> 表示字符串&nbsp;<code>\"ac\",\"ad\",\"bc\",\"bd\"</code>。</li>\n\t</ul>\n\t</li>\n\t<li>表达式之间允许嵌套，单一元素与表达式的连接也是允许的。\n\t<ul>\n\t\t<li>例如，表达式 <code>\"a{b,c,d}\"</code> 表示字符串&nbsp;<code>\"ab\",\"ac\",\"ad\"​​​​​​</code>。</li>\n\t\t<li>例如，表达式 <code>\"a{b,c}{d,e}f{g,h}\"</code> 可以表示字符串&nbsp;<code>\"abdfg\", \"abdfh\", \"abefg\", \"abefh\", \"acdfg\", \"acdfh\", \"acefg\", \"acefh\"</code>。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>给出表示基于给定语法规则的表达式&nbsp;<code>expression</code>，返回它所表示的所有字符串组成的有序列表。</p>\n\n<p>假如你希望以「集合」的概念了解此题，也可以通过点击 “<strong>显示英文描述</strong>” 获取详情。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"{a,b}{c,{d,e}}\"\n<strong>输出：</strong>[\"ac\",\"ad\",\"ae\",\"bc\",\"bd\",\"be\"]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"{{a,z},a{b,c},{ab,z}}\"\n<strong>输出：</strong>[\"a\",\"ab\",\"ac\",\"z\"]\n<strong>解释：</strong>输出中 <strong>不应 </strong>出现重复的组合结果。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 60</code></li>\n\t<li><code>expression[i]</code> 由 <code>'{'</code>，<code>'}'</code>，<code>','</code>&nbsp;或小写英文字母组成</li>\n\t<li>给出的表达式&nbsp;<code>expression</code>&nbsp;用以表示一组基于题目描述中语法构造的字符串</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1097.游戏玩法分析 V",
        "hardRate": "HARD",
        "passRate": "52.42%",
        "problemsUrl": "https://leetcode.cn/problems/game-play-analysis-v/",
        "solutionsUrl": "https://leetcode.cn/problems/game-play-analysis-v/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1098.小众书籍",
        "hardRate": "MEDIUM",
        "passRate": "47.17%",
        "problemsUrl": "https://leetcode.cn/problems/unpopular-books/",
        "solutionsUrl": "https://leetcode.cn/problems/unpopular-books/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1099.小于 K 的两数之和",
        "hardRate": "EASY",
        "passRate": "59.87%",
        "problemsUrl": "https://leetcode.cn/problems/two-sum-less-than-k/",
        "solutionsUrl": "https://leetcode.cn/problems/two-sum-less-than-k/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1100.长度为 K 的无重复字符子串",
        "hardRate": "MEDIUM",
        "passRate": "69.83%",
        "problemsUrl": "https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1101.彼此熟识的最早时间",
        "hardRate": "MEDIUM",
        "passRate": "68.79%",
        "problemsUrl": "https://leetcode.cn/problems/the-earliest-moment-when-everyone-become-friends/",
        "solutionsUrl": "https://leetcode.cn/problems/the-earliest-moment-when-everyone-become-friends/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1102.得分最高的路径",
        "hardRate": "MEDIUM",
        "passRate": "40.18%",
        "problemsUrl": "https://leetcode.cn/problems/path-with-maximum-minimum-value/",
        "solutionsUrl": "https://leetcode.cn/problems/path-with-maximum-minimum-value/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1103.分糖果 II",
        "hardRate": "EASY",
        "passRate": "63.74%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-candies-to-people/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-candies-to-people/solution",
        "problemsDesc": "<p>排排坐，分糖果。</p>\n\n<p>我们买了一些糖果 <code>candies</code>，打算把它们分给排好队的 <strong><code>n = num_people</code></strong> 个小朋友。</p>\n\n<p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 <code>n</code>&nbsp;颗糖果。</p>\n\n<p>然后，我们再回到队伍的起点，给第一个小朋友 <code>n&nbsp;+ 1</code> 颗糖果，第二个小朋友 <code>n&nbsp;+ 2</code> 颗，依此类推，直到给最后一个小朋友 <code>2 * n</code>&nbsp;颗糖果。</p>\n\n<p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p>\n\n<p>返回一个长度为 <code>num_people</code>、元素之和为 <code>candies</code> 的数组，以表示糖果的最终分发情况（即 <code>ans[i]</code> 表示第 <code>i</code> 个小朋友分到的糖果数）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>candies = 7, num_people = 4\n<strong>输出：</strong>[1,2,3,1]\n<strong>解释：</strong>\n第一次，ans[0] += 1，数组变为 [1,0,0,0]。\n第二次，ans[1] += 2，数组变为 [1,2,0,0]。\n第三次，ans[2] += 3，数组变为 [1,2,3,0]。\n第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>candies = 10, num_people = 3\n<strong>输出：</strong>[5,2,3]\n<strong>解释：</strong>\n第一次，ans[0] += 1，数组变为 [1,0,0]。\n第二次，ans[1] += 2，数组变为 [1,2,0]。\n第三次，ans[2] += 3，数组变为 [1,2,3]。\n第四次，ans[0] += 4，最终数组变为 [5,2,3]。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candies &lt;= 10^9</code></li>\n\t<li><code>1 &lt;= num_people &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1104.二叉树寻路",
        "hardRate": "MEDIUM",
        "passRate": "75.85%",
        "problemsUrl": "https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree/solution",
        "problemsDesc": "<p>在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 <strong>逐行</strong> 依次按&nbsp;&ldquo;之&rdquo; 字形进行标记。</p>\n\n<p>如下图所示，在奇数行（即，第一行、第三行、第五行&hellip;&hellip;）中，按从左到右的顺序进行标记；</p>\n\n<p>而偶数行（即，第二行、第四行、第六行&hellip;&hellip;）中，按从右到左的顺序进行标记。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/06/28/tree.png\" style=\"height: 138px; width: 300px;\"></p>\n\n<p>给你树上某一个节点的标号 <code>label</code>，请你返回从根节点到该标号为 <code>label</code> 节点的路径，该路径是由途经的节点标号所组成的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>label = 14\n<strong>输出：</strong>[1,3,4,14]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>label = 26\n<strong>输出：</strong>[1,2,6,10,26]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= label &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1105.填充书架",
        "hardRate": "MEDIUM",
        "passRate": "67.25%",
        "problemsUrl": "https://leetcode.cn/problems/filling-bookcase-shelves/",
        "solutionsUrl": "https://leetcode.cn/problems/filling-bookcase-shelves/solution",
        "problemsDesc": "<p>给定一个数组 <code>books</code> ，其中&nbsp;<code>books[i] = [thickness<sub>i</sub>, height<sub>i</sub>]</code>&nbsp;表示第 <code>i</code> 本书的厚度和高度。你也会得到一个整数 <code>shelfWidth</code> 。</p>\n\n<p><strong>按顺序</strong>&nbsp;将这些书摆放到总宽度为 <code>shelfWidth</code> 的书架上。</p>\n\n<p>先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 <code>shelfWidth</code> ），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。</p>\n\n<p>需要注意的是，在上述过程的每个步骤中，<strong>摆放书的顺序与给定图书数组 </strong><code>books</code><strong> 顺序相同</strong>。</p>\n\n<ul>\n\t<li>例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。</li>\n</ul>\n\n<p>每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。</p>\n\n<p>以这种方式布置书架，返回书架整体可能的最小高度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2019/06/24/shelves.png\" style=\"width: 337px; height: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth = 4\n<strong>输出：</strong>6\n<strong>解释：</strong>\n3 层书架的高度和为 1 + 3 + 2 = 6 。\n第 2 本书不必放在第一层书架上。\n</pre>\n\n<p><strong class=\"example\">示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> books = [[1,3],[2,4],[3,2]], shelfWidth = 6\n<strong>输出:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= books.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= thickness<sub>i</sub>&nbsp;&lt;= shelfWidth &lt;= 1000</code></li>\n\t<li><code>1 &lt;= height<sub>i</sub>&nbsp;&lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1106.解析布尔表达式",
        "hardRate": "HARD",
        "passRate": "68.53%",
        "problemsUrl": "https://leetcode.cn/problems/parsing-a-boolean-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/parsing-a-boolean-expression/solution",
        "problemsDesc": "<p><strong>布尔表达式</strong> 是计算结果不是 <code>true</code> 就是 <code>false</code> 的表达式。有效的表达式需遵循以下约定：</p>\n\n<ul>\n\t<li><code>'t'</code>，运算结果为 <code>true</code></li>\n\t<li><code>'f'</code>，运算结果为 <code>false</code></li>\n\t<li><code>'!(subExpr)'</code>，运算过程为对内部表达式 <code>subExpr</code> 进行 <strong>逻辑非</strong>（NOT）运算</li>\n\t<li><code>'&amp;(subExpr<sub>1</sub>, subExpr<sub>2</sub>, ..., subExpr<sub>n</sub>)'</code>，运算过程为对 2 个或以上内部表达式 <code>subExpr<sub>1</sub>, subExpr<sub>2</sub>, ..., subExpr<sub>n</sub></code> 进行 <strong>逻辑与</strong>（AND）运算</li>\n\t<li><code>'|(subExpr<sub>1</sub>, subExpr<sub>2</sub>, ..., subExpr<sub>n</sub>)'</code>，运算过程为对 2 个或以上内部表达式 <code>subExpr<sub>1</sub>, subExpr<sub>2</sub>, ..., subExpr<sub>n</sub></code> 进行 <strong>逻辑或</strong>（OR）运算</li>\n</ul>\n\n<p>给你一个以字符串形式表述的&nbsp;<a href=\"https://baike.baidu.com/item/%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F/1574380?fr=aladdin\" target=\"_blank\">布尔表达式</a> <code>expression</code>，返回该式的运算结果。</p>\n\n<p>题目测试用例所给出的表达式均为有效的布尔表达式，遵循上述约定。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"&amp;(|(f))\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\n首先，计算 |(f) --&gt; f ，表达式变为 \"&amp;(f)\" 。\n接着，计算 &amp;(f) --&gt; f ，表达式变为 \"f\" 。\n最后，返回 false 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"|(f,f,f,t)\"\n<strong>输出：</strong>true\n<strong>解释：</strong>计算 (false OR false OR false OR true) ，结果为 true 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"!(&amp;(f,t))\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\n首先，计算 &amp;(f,t) --&gt; (false AND true) --&gt; false --&gt; f ，表达式变为 \"!(f)\" 。\n接着，计算 !(f) --&gt; NOT false --&gt; true ，返回 true 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>expression[i]</code> 为 <code>'('</code>、<code>')'</code>、<code>'&amp;'</code>、<code>'|'</code>、<code>'!'</code>、<code>'t'</code>、<code>'f'</code> 和 <code>','</code> 之一</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1107.每日新用户统计",
        "hardRate": "MEDIUM",
        "passRate": "41.18%",
        "problemsUrl": "https://leetcode.cn/problems/new-users-daily-count/",
        "solutionsUrl": "https://leetcode.cn/problems/new-users-daily-count/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1108.IP 地址无效化",
        "hardRate": "EASY",
        "passRate": "85.39%",
        "problemsUrl": "https://leetcode.cn/problems/defanging-an-ip-address/",
        "solutionsUrl": "https://leetcode.cn/problems/defanging-an-ip-address/solution",
        "problemsDesc": "<p>给你一个有效的 <a href=\"https://baike.baidu.com/item/IPv4\" target=\"_blank\">IPv4</a> 地址&nbsp;<code>address</code>，返回这个 IP 地址的无效化版本。</p>\n\n<p>所谓无效化&nbsp;IP 地址，其实就是用&nbsp;<code>&quot;[.]&quot;</code>&nbsp;代替了每个 <code>&quot;.&quot;</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>address = &quot;1.1.1.1&quot;\n<strong>输出：</strong>&quot;1[.]1[.]1[.]1&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>address = &quot;255.100.50.0&quot;\n<strong>输出：</strong>&quot;255[.]100[.]50[.]0&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给出的&nbsp;<code>address</code>&nbsp;是一个有效的 IPv4 地址</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1109.航班预订统计",
        "hardRate": "MEDIUM",
        "passRate": "63.64%",
        "problemsUrl": "https://leetcode.cn/problems/corporate-flight-bookings/",
        "solutionsUrl": "https://leetcode.cn/problems/corporate-flight-bookings/solution",
        "problemsDesc": "<p>这里有&nbsp;<code>n</code>&nbsp;个航班，它们分别从 <code>1</code> 到 <code>n</code> 进行编号。</p>\n\n<p>有一份航班预订表&nbsp;<code>bookings</code> ，表中第&nbsp;<code>i</code>&nbsp;条预订记录&nbsp;<code>bookings[i] = [first<sub>i</sub>, last<sub>i</sub>, seats<sub>i</sub>]</code>&nbsp;意味着在从 <code>first<sub>i</sub></code>&nbsp;到 <code>last<sub>i</sub></code> （<strong>包含</strong> <code>first<sub>i</sub></code> 和 <code>last<sub>i</sub></code> ）的 <strong>每个航班</strong> 上预订了 <code>seats<sub>i</sub></code>&nbsp;个座位。</p>\n\n<p>请你返回一个长度为 <code>n</code> 的数组&nbsp;<code>answer</code>，里面的元素是每个航班预定的座位总数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\n<strong>输出：</strong>[10,55,45,25,25]\n<strong>解释：</strong>\n航班编号        1   2   3   4   5\n预订记录 1 ：   10  10\n预订记录 2 ：       20  20\n预订记录 3 ：       25  25  25  25\n总座位数：      10  55  45  25  25\n因此，answer = [10,55,45,25,25]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>bookings = [[1,2,10],[2,2,15]], n = 2\n<strong>输出：</strong>[10,25]\n<strong>解释：</strong>\n航班编号        1   2\n预订记录 1 ：   10  10\n预订记录 2 ：       15\n总座位数：      10  25\n因此，answer = [10,25]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= bookings.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>bookings[i].length == 3</code></li>\n\t<li><code>1 &lt;= first<sub>i</sub> &lt;= last<sub>i</sub> &lt;= n</code></li>\n\t<li><code>1 &lt;= seats<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1110.删点成林",
        "hardRate": "MEDIUM",
        "passRate": "69.39%",
        "problemsUrl": "https://leetcode.cn/problems/delete-nodes-and-return-forest/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-nodes-and-return-forest/solution",
        "problemsDesc": "<p>给出二叉树的根节点&nbsp;<code>root</code>，树上每个节点都有一个不同的值。</p>\n\n<p>如果节点值在&nbsp;<code>to_delete</code>&nbsp;中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。</p>\n\n<p>返回森林中的每棵树。你可以按任意顺序组织答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/05/screen-shot-2019-07-01-at-53836-pm.png\" style=\"height: 150px; width: 237px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,6,7], to_delete = [3,5]\n<strong>输出：</strong>[[1,2,null,4],[6],[7]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,4,null,3], to_delete = [3]\n<strong>输出：</strong>[[1,2,4]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数最大为&nbsp;<code>1000</code>。</li>\n\t<li>每个节点都有一个介于&nbsp;<code>1</code> 到&nbsp;<code>1000</code>&nbsp;之间的值，且各不相同。</li>\n\t<li><code>to_delete.length &lt;= 1000</code></li>\n\t<li><code>to_delete</code> 包含一些从&nbsp;<code>1</code> 到&nbsp;<code>1000</code>、各不相同的值。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1111.有效括号的嵌套深度",
        "hardRate": "MEDIUM",
        "passRate": "76.79%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solution",
        "problemsDesc": "<p><strong>有效括号字符串 </strong>定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「<strong>有效括号字符串</strong>」部分。</p>\n\n<p><strong>嵌套深度</strong> <code>depth</code> 定义：即有效括号字符串嵌套的层数，<code>depth(A)</code> 表示有效括号字符串 <code>A</code> 的嵌套深度。详情参见题末「<strong>嵌套深度</strong>」部分。</p>\n\n<p>有效括号字符串类型与对应的嵌套深度计算方法如下图所示：</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/01/1111.png\" style=\"height: 152px; width: 600px;\"></p>\n\n<p>&nbsp;</p>\n\n<p>给你一个「有效括号字符串」 <code>seq</code>，请你将其分成两个不相交的有效括号字符串，<code>A</code> 和&nbsp;<code>B</code>，并使这两个字符串的深度最小。</p>\n\n<ul>\n\t<li>不相交：每个 <code>seq[i]</code> 只能分给 <code>A</code> 和 <code>B</code> 二者中的一个，不能既属于 <code>A</code> 也属于 <code>B</code> 。</li>\n\t<li><code>A</code> 或 <code>B</code> 中的元素在原字符串中可以不连续。</li>\n\t<li><code>A.length + B.length = seq.length</code></li>\n\t<li>深度最小：<code>max(depth(A), depth(B))</code>&nbsp;的可能取值最小。&nbsp;</li>\n</ul>\n\n<p>划分方案用一个长度为 <code>seq.length</code> 的答案数组 <code>answer</code> 表示，编码规则如下：</p>\n\n<ul>\n\t<li><code>answer[i] = 0</code>，<code>seq[i]</code> 分给 <code>A</code> 。</li>\n\t<li><code>answer[i] = 1</code>，<code>seq[i]</code> 分给 <code>B</code> 。</li>\n</ul>\n\n<p>如果存在多个满足要求的答案，只需返回其中任意 <strong>一个 </strong>即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>seq = &quot;(()())&quot;\n<strong>输出：</strong>[0,1,1,1,1,0]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>seq = &quot;()(())()&quot;\n<strong>输出：</strong>[0,0,0,1,1,0,1,1]\n<strong>解释：</strong>本示例答案不唯一。\n按此输出 A = &quot;()()&quot;, B = &quot;()()&quot;, max(depth(A), depth(B)) = 1，它们的深度最小。\n像 [1,1,1,0,0,1,1,1]，也是正确结果，其中 A = &quot;()()()&quot;, B = &quot;()&quot;, max(depth(A), depth(B)) = 1 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;&nbsp;seq.size &lt;= 10000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>有效括号字符串：</strong></p>\n\n<pre>仅由&nbsp;<code>&quot;(&quot;</code> 和&nbsp;<code>&quot;)&quot;</code>&nbsp;构成的字符串，对于每个左括号，都能找到与之对应的右括号，反之亦然。\n下述几种情况同样属于有效括号字符串：\n\n  1. 空字符串\n  2. 连接，可以记作&nbsp;<code>AB</code>（<code>A</code> 与 <code>B</code> 连接），其中&nbsp;<code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;都是有效括号字符串\n  3. 嵌套，可以记作&nbsp;<code>(A)</code>，其中&nbsp;<code>A</code>&nbsp;是有效括号字符串\n</pre>\n\n<p><strong>嵌套深度：</strong></p>\n\n<pre>类似地，我们可以定义任意有效括号字符串 <code>s</code> 的 <strong>嵌套深度</strong>&nbsp;<code>depth(S)</code>：\n\n  1.<code> s</code> 为空时，<code>depth(&quot;&quot;) = 0</code>\n<code>  2. s</code> 为 <code>A</code> 与 <code>B</code> 连接时，<code>depth(A + B) = max(depth(A), depth(B))</code>，其中&nbsp;<code>A</code> 和&nbsp;<code>B</code>&nbsp;都是有效括号字符串\n<code>  3. s</code> 为嵌套情况，<code>depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)</code>，其中 <code>A</code> 是有效括号字符串\n\n例如：<code>&quot;&quot;</code>，<code>&quot;()()&quot;</code>，和&nbsp;<code>&quot;()(()())&quot;</code>&nbsp;都是有效括号字符串，嵌套深度分别为 0，1，2，而&nbsp;<code>&quot;)(&quot;</code> 和&nbsp;<code>&quot;(()&quot;</code>&nbsp;都不是有效括号字符串。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1112.每位学生的最高成绩",
        "hardRate": "MEDIUM",
        "passRate": "65.97%",
        "problemsUrl": "https://leetcode.cn/problems/highest-grade-for-each-student/",
        "solutionsUrl": "https://leetcode.cn/problems/highest-grade-for-each-student/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1113.报告的记录",
        "hardRate": "EASY",
        "passRate": "53.41%",
        "problemsUrl": "https://leetcode.cn/problems/reported-posts/",
        "solutionsUrl": "https://leetcode.cn/problems/reported-posts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1114.按序打印",
        "hardRate": "EASY",
        "passRate": "65.19%",
        "problemsUrl": "https://leetcode.cn/problems/print-in-order/",
        "solutionsUrl": "https://leetcode.cn/problems/print-in-order/solution",
        "problemsDesc": "<p>给你一个类：</p>\n\n<pre>\npublic class Foo {\n&nbsp; public void first() { print(\"first\"); }\n&nbsp; public void second() { print(\"second\"); }\n&nbsp; public void third() { print(\"third\"); }\n}</pre>\n\n<p>三个不同的线程 A、B、C 将会共用一个&nbsp;<code>Foo</code>&nbsp;实例。</p>\n\n<ul>\n\t<li>线程 A 将会调用 <code>first()</code> 方法</li>\n\t<li>线程 B 将会调用&nbsp;<code>second()</code> 方法</li>\n\t<li>线程 C 将会调用 <code>third()</code> 方法</li>\n</ul>\n\n<p>请设计修改程序，以确保 <code>second()</code> 方法在 <code>first()</code> 方法之后被执行，<code>third()</code> 方法在 <code>second()</code> 方法之后被执行。</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。</li>\n\t<li>你看到的输入格式主要是为了确保测试的全面性。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>\"firstsecondthird\"\n<strong>解释：</strong>\n有三个线程会被异步启动。输入 [1,2,3] 表示线程 A 将会调用 first() 方法，线程 B 将会调用 second() 方法，线程 C 将会调用 third() 方法。正确的输出是 \"firstsecondthird\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,2]\n<strong>输出：</strong>\"firstsecondthird\"\n<strong>解释：</strong>\n输入 [1,3,2] 表示线程 A 将会调用 first() 方法，线程 B 将会调用 third() 方法，线程 C 将会调用 second() 方法。正确的输出是 \"firstsecondthird\"。</pre>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n<strong>提示：</strong>\n\n<ul>\n\t<li><code>nums</code> 是 <code>[1, 2, 3]</code> 的一组排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1115.交替打印 FooBar",
        "hardRate": "MEDIUM",
        "passRate": "57.06%",
        "problemsUrl": "https://leetcode.cn/problems/print-foobar-alternately/",
        "solutionsUrl": "https://leetcode.cn/problems/print-foobar-alternately/solution",
        "problemsDesc": "<p>给你一个类：</p>\n\n<pre>\nclass FooBar {\n  public void foo() {\n&nbsp; &nbsp; for (int i = 0; i &lt; n; i++) {\n&nbsp; &nbsp; &nbsp; print(\"foo\");\n&nbsp;   }\n  }\n\n  public void bar() {\n&nbsp; &nbsp; for (int i = 0; i &lt; n; i++) {\n&nbsp; &nbsp; &nbsp; print(\"bar\");\n&nbsp; &nbsp; }\n  }\n}\n</pre>\n\n<p>两个不同的线程将会共用一个 <code>FooBar</code>&nbsp;实例：</p>\n\n<ul>\n\t<li>线程 A 将会调用&nbsp;<code>foo()</code>&nbsp;方法，而</li>\n\t<li>线程 B 将会调用&nbsp;<code>bar()</code>&nbsp;方法</li>\n</ul>\n\n<p>请设计修改程序，以确保 <code>\"foobar\"</code> 被输出 <code>n</code> 次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>\"foobar\"\n<strong>解释：</strong>这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 bar() 方法，\"foobar\" 将被输出一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>\"foobarfoobar\"\n<strong>解释：</strong>\"foobar\" 将被输出两次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1116.打印零与奇偶数",
        "hardRate": "MEDIUM",
        "passRate": "54.30%",
        "problemsUrl": "https://leetcode.cn/problems/print-zero-even-odd/",
        "solutionsUrl": "https://leetcode.cn/problems/print-zero-even-odd/solution",
        "problemsDesc": "<p>现有函数 <code>printNumber</code> 可以用一个整数参数调用，并输出该整数到控制台。</p>\n\n<ul>\n\t<li>例如，调用 <code>printNumber(7)</code> 将会输出 <code>7</code> 到控制台。</li>\n</ul>\n\n<p>给你类 <code>ZeroEvenOdd</code> 的一个实例，该类中有三个函数：<code>zero</code>、<code>even</code> 和 <code>odd</code> 。<code>ZeroEvenOdd</code> 的相同实例将会传递给三个不同线程：</p>\n\n<ul>\n\t<li><strong>线程 A：</strong>调用 <code>zero()</code> ，只输出 <code>0</code></li>\n\t<li><strong>线程 B：</strong>调用 <code>even()</code> ，只输出偶数</li>\n\t<li><strong>线程 C：</strong>调用 <code>odd()</code> ，只输出奇数</li>\n</ul>\n\n<p>修改给出的类，以输出序列 <code>\"010203040506...\"</code> ，其中序列的长度必须为 <code>2n</code> 。</p>\n\n<p>实现 <code>ZeroEvenOdd</code> 类：</p>\n\n<ul>\n\t<li><code>ZeroEvenOdd(int n)</code> 用数字 <code>n</code> 初始化对象，表示需要输出的数。</li>\n\t<li><code>void zero(printNumber)</code> 调用 <code>printNumber</code> 以输出一个 0 。</li>\n\t<li><code>void even(printNumber)</code> 调用<code>printNumber</code> 以输出偶数。</li>\n\t<li><code>void odd(printNumber)</code> 调用 <code>printNumber</code> 以输出奇数。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>\"0102\"\n<strong>解释：</strong>三条线程异步执行，其中一个调用 zero()，另一个线程调用 even()，最后一个线程调用odd()。正确的输出为 \"0102\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>\"0102030405\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1117.H2O 生成",
        "hardRate": "MEDIUM",
        "passRate": "53.96%",
        "problemsUrl": "https://leetcode.cn/problems/building-h2o/",
        "solutionsUrl": "https://leetcode.cn/problems/building-h2o/solution",
        "problemsDesc": "<p>现在有两种线程，氧 <code>oxygen</code> 和氢 <code>hydrogen</code>，你的目标是组织这两种线程来产生水分子。</p>\n\n<p>存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。</p>\n\n<p>氢和氧线程会被分别给予 <code>releaseHydrogen</code> 和 <code>releaseOxygen</code> 方法来允许它们突破屏障。</p>\n\n<p>这些线程应该三三成组突破屏障并能立即组合产生一个水分子。</p>\n\n<p>你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。</p>\n\n<p>换句话说:</p>\n\n<ul>\n\t<li>如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。</li>\n\t<li>如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。</li>\n</ul>\n\n<p>书写满足这些限制条件的氢、氧线程同步代码。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>water = \"HOH\"\n<strong>输出: </strong>\"HHO\"\n<strong>解释:</strong> \"HOH\" 和 \"OHH\" 依然都是有效解。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>water = \"OOHHHH\"\n<strong>输出: </strong>\"HHOHHO\"\n<strong>解释:</strong> \"HOHHHO\", \"OHHHHO\", \"HHOHOH\", \"HOHHOH\", \"OHHHOH\", \"HHOOHH\", \"HOHOHH\" 和 \"OHHOHH\" 依然都是有效解。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 * n == water.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>water[i] == 'O' or 'H'</code></li>\n\t<li>输入字符串&nbsp;<code>water</code>&nbsp;中的 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'H'</span></span></font></font>&nbsp;总数将会是 <code>2 * n</code> 。</li>\n\t<li>输入字符串&nbsp;<code>water</code>&nbsp;中的 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'O'</span></span></font></font>&nbsp;总数将会是 <code>n</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1118.一月有多少天",
        "hardRate": "EASY",
        "passRate": "64.96%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-days-in-a-month/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-days-in-a-month/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1119.删去字符串中的元音",
        "hardRate": "EASY",
        "passRate": "87.18%",
        "problemsUrl": "https://leetcode.cn/problems/remove-vowels-from-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-vowels-from-a-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1120.子树的最大平均值",
        "hardRate": "MEDIUM",
        "passRate": "62.95%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-average-subtree/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-average-subtree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1121.将数组分成几个递增序列",
        "hardRate": "HARD",
        "passRate": "60.68%",
        "problemsUrl": "https://leetcode.cn/problems/divide-array-into-increasing-sequences/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-array-into-increasing-sequences/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1122.数组的相对排序",
        "hardRate": "EASY",
        "passRate": "70.54%",
        "problemsUrl": "https://leetcode.cn/problems/relative-sort-array/",
        "solutionsUrl": "https://leetcode.cn/problems/relative-sort-array/solution",
        "problemsDesc": "<p>给你两个数组，<code>arr1</code> 和&nbsp;<code>arr2</code>，<code>arr2</code>&nbsp;中的元素各不相同，<code>arr2</code> 中的每个元素都出现在&nbsp;<code>arr1</code>&nbsp;中。</p>\n\n<p>对 <code>arr1</code>&nbsp;中的元素进行排序，使 <code>arr1</code> 中项的相对顺序和&nbsp;<code>arr2</code>&nbsp;中的相对顺序相同。未在&nbsp;<code>arr2</code>&nbsp;中出现过的元素需要按照升序放在&nbsp;<code>arr1</code>&nbsp;的末尾。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]\n<strong>输出：</strong>[2,2,2,1,4,3,3,9,6,7,19]\n</pre>\n\n<p><strong>示例 &nbsp;2:</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]\n<strong>输出：</strong>[22,28,8,6,17,44]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr1.length, arr2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 1000</code></li>\n\t<li><code>arr2</code>&nbsp;中的元素&nbsp;<code>arr2[i]</code>&nbsp;&nbsp;<strong>各不相同</strong>&nbsp;</li>\n\t<li><code>arr2</code> 中的每个元素&nbsp;<code>arr2[i]</code>&nbsp;都出现在&nbsp;<code>arr1</code>&nbsp;中</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1123.最深叶节点的最近公共祖先",
        "hardRate": "MEDIUM",
        "passRate": "71.77%",
        "problemsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/",
        "solutionsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/solution",
        "problemsDesc": "<p>给你一个有根节点<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;的二叉树，返回它&nbsp;<em>最深的叶节点的最近公共祖先</em>&nbsp;。</p>\n\n<p>回想一下：</p>\n\n<ul>\n\t<li><strong>叶节点</strong> 是二叉树中没有子节点的节点</li>\n\t<li>树的根节点的&nbsp;<strong>深度&nbsp;</strong>为&nbsp;<code>0</code>，如果某一节点的深度为&nbsp;<code>d</code>，那它的子节点的深度就是&nbsp;<code>d+1</code></li>\n\t<li>如果我们假定 <code>A</code> 是一组节点&nbsp;<code>S</code>&nbsp;的 <strong>最近公共祖先</strong>，<code>S</code>&nbsp;中的每个节点都在以 <code>A</code> 为根节点的子树中，且 <code>A</code>&nbsp;的深度达到此条件下可能的最大值。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png\" style=\"height: 340px; width: 400px;\" />\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4]\n<strong>输出：</strong>[2,7,4]\n<strong>解释：</strong>我们返回值为 2 的节点，在图中用黄色标记。\n在图中用蓝色标记的是树的最深的节点。\n注意，节点 6、0 和 8 也是叶节点，但是它们的深度是 2 ，而节点 7 和 4 的深度是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n<strong>解释：</strong>根节点是树中最深的节点，它是它本身的最近公共祖先。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0,1,3,null,2]\n<strong>输出：</strong>[2]\n<strong>解释：</strong>树中最深的叶节点是 2 ，最近公共祖先是它自己。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数将在<meta charset=\"UTF-8\" />&nbsp;<code>[1, 1000]</code>&nbsp;的范围内。</li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>每个节点的值都是&nbsp;<strong>独一无二</strong>&nbsp;的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与力扣 865 重复：<a href=\"https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/\">https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1124.表现良好的最长时间段",
        "hardRate": "MEDIUM",
        "passRate": "39.22%",
        "problemsUrl": "https://leetcode.cn/problems/longest-well-performing-interval/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-well-performing-interval/solution",
        "problemsDesc": "<p>给你一份工作时间表&nbsp;<code>hours</code>，上面记录着某一位员工每天的工作小时数。</p>\n\n<p>我们认为当员工一天中的工作小时数大于&nbsp;<code>8</code> 小时的时候，那么这一天就是「<strong>劳累的一天</strong>」。</p>\n\n<p>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格<strong> 大于</strong>「不劳累的天数」。</p>\n\n<p>请你返回「表现良好时间段」的最大长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>hours = [9,9,6,0,6,6,9]\n<strong>输出：</strong>3\n<strong>解释：</strong>最长的表现良好时间段是 [9,9,6]。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>hours = [6,6,6]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= hours.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= hours[i] &lt;= 16</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1125.最小的必要团队",
        "hardRate": "HARD",
        "passRate": "61.03%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-sufficient-team/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-sufficient-team/solution",
        "problemsDesc": "<p>作为项目经理，你规划了一份需求的技能清单 <code>req_skills</code>，并打算从备选人员名单 <code>people</code> 中选出些人组成一个「必要团队」（ 编号为 <code>i</code> 的备选人员 <code>people[i]</code> 含有一份该备选人员掌握的技能列表）。</p>\n\n<p>所谓「必要团队」，就是在这个团队中，对于所需求的技能列表 <code>req_skills</code> 中列出的每项技能，团队中至少有一名成员已经掌握。可以用每个人的编号来表示团队中的成员：</p>\n\n<ul>\n\t<li>例如，团队 <code>team = [0, 1, 3]</code> 表示掌握技能分别为 <code>people[0]</code>，<code>people[1]</code>，和 <code>people[3]</code> 的备选人员。</li>\n</ul>\n\n<p>请你返回 <strong>任一</strong> 规模最小的必要团队，团队成员用人员编号表示。你可以按 <strong>任意顺序</strong> 返回答案，题目数据保证答案存在。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>req_skills = [\"java\",\"nodejs\",\"reactjs\"], people = [[\"java\"],[\"nodejs\"],[\"nodejs\",\"reactjs\"]]\n<strong>输出：</strong>[0,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>req_skills = [\"algorithms\",\"math\",\"java\",\"reactjs\",\"csharp\",\"aws\"], people = [[\"algorithms\",\"math\",\"java\"],[\"algorithms\",\"math\",\"reactjs\"],[\"java\",\"csharp\",\"aws\"],[\"reactjs\",\"csharp\"],[\"csharp\",\"math\"],[\"aws\",\"java\"]]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= req_skills.length <= 16</code></li>\n\t<li><code>1 <= req_skills[i].length <= 16</code></li>\n\t<li><code>req_skills[i]</code> 由小写英文字母组成</li>\n\t<li><code>req_skills</code> 中的所有字符串 <strong>互不相同</strong></li>\n\t<li><code>1 <= people.length <= 60</code></li>\n\t<li><code>0 <= people[i].length <= 16</code></li>\n\t<li><code>1 <= people[i][j].length <= 16</code></li>\n\t<li><code>people[i][j]</code> 由小写英文字母组成</li>\n\t<li><code>people[i]</code> 中的所有字符串 <strong>互不相同</strong></li>\n\t<li><code>people[i]</code> 中的每个技能是 <code>req_skills</code> 中的技能</li>\n\t<li>题目数据保证「必要团队」一定存在</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1126.查询活跃业务",
        "hardRate": "MEDIUM",
        "passRate": "68.06%",
        "problemsUrl": "https://leetcode.cn/problems/active-businesses/",
        "solutionsUrl": "https://leetcode.cn/problems/active-businesses/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1127.用户购买平台",
        "hardRate": "HARD",
        "passRate": "42.97%",
        "problemsUrl": "https://leetcode.cn/problems/user-purchase-platform/",
        "solutionsUrl": "https://leetcode.cn/problems/user-purchase-platform/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1128.等价多米诺骨牌对的数量",
        "hardRate": "EASY",
        "passRate": "54.12%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-equivalent-domino-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-equivalent-domino-pairs/solution",
        "problemsDesc": "<p>给你一个由一些多米诺骨牌组成的列表&nbsp;<code>dominoes</code>。</p>\n\n<p>如果其中某一张多米诺骨牌可以通过旋转 <code>0</code>&nbsp;度或 <code>180</code> 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。</p>\n\n<p>形式上，<code>dominoes[i] = [a, b]</code>&nbsp;和&nbsp;<code>dominoes[j] = [c, d]</code>&nbsp;等价的前提是&nbsp;<code>a==c</code>&nbsp;且&nbsp;<code>b==d</code>，或是&nbsp;<code>a==d</code> 且&nbsp;<code>b==c</code>。</p>\n\n<p>在&nbsp;<code>0 &lt;= i &lt; j &lt; dominoes.length</code>&nbsp;的前提下，找出满足&nbsp;<code>dominoes[i]</code> 和&nbsp;<code>dominoes[j]</code>&nbsp;等价的骨牌对 <code>(i, j)</code> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>dominoes = [[1,2],[2,1],[3,4],[5,6]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= dominoes.length &lt;= 40000</code></li>\n\t<li><code>1 &lt;= dominoes[i][j] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1129.颜色交替的最短路径",
        "hardRate": "MEDIUM",
        "passRate": "48.70%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-with-alternating-colors/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-with-alternating-colors/solution",
        "problemsDesc": "<p>给定一个整数 <code>n</code>，即有向图中的节点数，其中节点标记为 <code>0</code> 到 <code>n - 1</code>。图中的每条边为红色或者蓝色，并且可能存在自环或平行边。</p>\n\n<p>给定两个数组&nbsp;<code>redEdges</code>&nbsp;和&nbsp;<code>blueEdges</code>，其中：</p>\n\n<ul>\n\t<li><code>redEdges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示图中存在一条从节点&nbsp;<code>a<sub>i</sub></code>&nbsp;到节点&nbsp;<code>b<sub>i</sub></code>&nbsp;的红色有向边，</li>\n\t<li><code>blueEdges[j] = [u<sub>j</sub>, v<sub>j</sub>]</code>&nbsp;表示图中存在一条从节点&nbsp;<code>u<sub>j</sub></code>&nbsp;到节点&nbsp;<code>v<sub>j</sub></code>&nbsp;的蓝色有向边。</li>\n</ul>\n\n<p>返回长度为 <code>n</code> 的数组&nbsp;<code>answer</code>，其中&nbsp;<code>answer[X]</code>&nbsp;是从节点&nbsp;<code>0</code>&nbsp;到节点&nbsp;<code>X</code>&nbsp;的红色边和蓝色边交替出现的最短路径的长度。如果不存在这样的路径，那么 <code>answer[x] = -1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, red_edges = [[0,1],[1,2]], blue_edges = []\n<strong>输出：</strong>[0,1,-1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]\n<strong>输出：</strong>[0,1,-1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= redEdges.length,&nbsp;blueEdges.length &lt;= 400</code></li>\n\t<li><code>redEdges[i].length == blueEdges[j].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub>, u<sub>j</sub>, v<sub>j</sub>&nbsp;&lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1130.叶值的最小代价生成树",
        "hardRate": "MEDIUM",
        "passRate": "70.82%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-tree-from-leaf-values/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-tree-from-leaf-values/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>arr</code>，考虑所有满足以下条件的二叉树：</p>\n\n<ul>\n\t<li>每个节点都有 <code>0</code> 个或是 <code>2</code> 个子节点。</li>\n\t<li>数组&nbsp;<code>arr</code>&nbsp;中的值与树的中序遍历中每个叶节点的值一一对应。</li>\n\t<li>每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。</li>\n</ul>\n\n<p>在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个&nbsp;32 位整数。</p>\n\n<p>如果一个节点有 0 个子节点，那么该节点为叶节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/10/tree1.jpg\" style=\"width: 500px; height: 169px;\" />\n<pre>\n<strong>输入：</strong>arr = [6,2,4]\n<strong>输出：</strong>32\n<strong>解释：</strong>有两种可能的树，第一种的非叶节点的总和为 36 ，第二种非叶节点的总和为 32 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/10/tree2.jpg\" style=\"width: 224px; height: 145px;\" />\n<pre>\n<strong>输入：</strong>arr = [4,11]\n<strong>输出：</strong>44\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 40</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 15</code></li>\n\t<li>答案保证是一个 32 位带符号整数，即小于&nbsp;<code>2<sup>31</sup></code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1131.绝对值表达式的最大值",
        "hardRate": "MEDIUM",
        "passRate": "47.48%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-of-absolute-value-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-of-absolute-value-expression/solution",
        "problemsDesc": "<p>给你两个长度相等的整数数组，返回下面表达式的最大值：</p>\n\n<p><code>|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|</code></p>\n\n<p>其中下标 <code>i</code>，<code>j</code> 满足&nbsp;<code>0 &lt;= i, j &lt; arr1.length</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [1,2,3,4], arr2 = [-1,4,5,6]\n<strong>输出：</strong>13\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]\n<strong>输出：</strong>20</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr1.length == arr2.length &lt;= 40000</code></li>\n\t<li><code>-10^6 &lt;= arr1[i], arr2[i] &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1132.报告的记录 II",
        "hardRate": "MEDIUM",
        "passRate": "38.63%",
        "problemsUrl": "https://leetcode.cn/problems/reported-posts-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/reported-posts-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1133.最大唯一数",
        "hardRate": "EASY",
        "passRate": "65.80%",
        "problemsUrl": "https://leetcode.cn/problems/largest-unique-number/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-unique-number/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1134.阿姆斯特朗数",
        "hardRate": "EASY",
        "passRate": "77.28%",
        "problemsUrl": "https://leetcode.cn/problems/armstrong-number/",
        "solutionsUrl": "https://leetcode.cn/problems/armstrong-number/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1135.最低成本联通所有城市",
        "hardRate": "MEDIUM",
        "passRate": "57.86%",
        "problemsUrl": "https://leetcode.cn/problems/connecting-cities-with-minimum-cost/",
        "solutionsUrl": "https://leetcode.cn/problems/connecting-cities-with-minimum-cost/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1136.并行课程",
        "hardRate": "MEDIUM",
        "passRate": "60.41%",
        "problemsUrl": "https://leetcode.cn/problems/parallel-courses/",
        "solutionsUrl": "https://leetcode.cn/problems/parallel-courses/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1137.第 N 个泰波那契数",
        "hardRate": "EASY",
        "passRate": "61.02%",
        "problemsUrl": "https://leetcode.cn/problems/n-th-tribonacci-number/",
        "solutionsUrl": "https://leetcode.cn/problems/n-th-tribonacci-number/solution",
        "problemsDesc": "<p>泰波那契序列&nbsp;T<sub>n</sub>&nbsp;定义如下：&nbsp;</p>\n\n<p>T<sub>0</sub> = 0, T<sub>1</sub> = 1, T<sub>2</sub> = 1, 且在 n &gt;= 0&nbsp;的条件下 T<sub>n+3</sub> = T<sub>n</sub> + T<sub>n+1</sub> + T<sub>n+2</sub></p>\n\n<p>给你整数&nbsp;<code>n</code>，请返回第 n 个泰波那契数&nbsp;T<sub>n </sub>的值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 25\n<strong>输出：</strong>1389537\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 37</code></li>\n\t<li>答案保证是一个 32 位整数，即&nbsp;<code>answer &lt;= 2^31 - 1</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1138.字母板上的路径",
        "hardRate": "MEDIUM",
        "passRate": "51.76%",
        "problemsUrl": "https://leetcode.cn/problems/alphabet-board-path/",
        "solutionsUrl": "https://leetcode.cn/problems/alphabet-board-path/solution",
        "problemsDesc": "<p>我们从一块字母板上的位置&nbsp;<code>(0, 0)</code>&nbsp;出发，该坐标对应的字符为&nbsp;<code>board[0][0]</code>。</p>\n\n<p>在本题里，字母板为<code>board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]</code>，如下所示。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/07/28/azboard.png\" style=\"width: 300px;\" /></p>\n\n<p>我们可以按下面的指令规则行动：</p>\n\n<ul>\n\t<li>如果方格存在，<code>'U'</code>&nbsp;意味着将我们的位置上移一行；</li>\n\t<li>如果方格存在，<code>'D'</code>&nbsp;意味着将我们的位置下移一行；</li>\n\t<li>如果方格存在，<code>'L'</code>&nbsp;意味着将我们的位置左移一列；</li>\n\t<li>如果方格存在，<code>'R'</code>&nbsp;意味着将我们的位置右移一列；</li>\n\t<li><code>'!'</code>&nbsp;会把在我们当前位置 <code>(r, c)</code> 的字符&nbsp;<code>board[r][c]</code>&nbsp;添加到答案中。</li>\n</ul>\n\n<p>（注意，字母板上只存在有字母的位置。）</p>\n\n<p>返回指令序列，用最小的行动次数让答案和目标&nbsp;<code>target</code>&nbsp;相同。你可以返回任何达成目标的路径。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = \"leet\"\n<strong>输出：</strong>\"DDR!UURRR!!DDD!\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = \"code\"\n<strong>输出：</strong>\"RR!DDRR!UUL!R!\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target.length &lt;= 100</code></li>\n\t<li><code>target</code>&nbsp;仅含有小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1139.最大的以 1 为边界的正方形",
        "hardRate": "MEDIUM",
        "passRate": "56.09%",
        "problemsUrl": "https://leetcode.cn/problems/largest-1-bordered-square/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-1-bordered-square/solution",
        "problemsDesc": "<p>给你一个由若干 <code>0</code> 和 <code>1</code> 组成的二维网格&nbsp;<code>grid</code>，请你找出边界全部由 <code>1</code> 组成的最大 <strong>正方形</strong> 子网格，并返回该子网格中的元素数量。如果不存在，则返回 <code>0</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>输出：</strong>9\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,0,0]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= grid.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= grid[0].length &lt;= 100</code></li>\n\t<li><code>grid[i][j]</code> 为&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1140.石子游戏 II",
        "hardRate": "MEDIUM",
        "passRate": "70.45%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-ii/solution",
        "problemsDesc": "<p>爱丽丝和鲍勃继续他们的石子游戏。许多堆石子&nbsp;<strong>排成一行</strong>，每堆都有正整数颗石子&nbsp;<code>piles[i]</code>。游戏以谁手中的石子最多来决出胜负。</p>\n\n<p>爱丽丝和鲍勃轮流进行，爱丽丝先开始。最初，<code>M = 1</code>。</p>\n\n<p>在每个玩家的回合中，该玩家可以拿走剩下的&nbsp;<strong>前</strong>&nbsp;<code>X</code>&nbsp;堆的所有石子，其中&nbsp;<code>1 &lt;= X &lt;= 2M</code>。然后，令&nbsp;<code>M = max(M, X)</code>。</p>\n\n<p>游戏一直持续到所有石子都被拿走。</p>\n\n<p>假设爱丽丝和鲍勃都发挥出最佳水平，返回爱丽丝可以得到的最大数量的石头。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [2,7,9,4,4]\n<strong>输出：</strong>10\n<strong>解释：</strong>如果一开始Alice取了一堆，Bob取了两堆，然后Alice再取两堆。爱丽丝可以得到2 + 4 + 4 = 10堆。如果Alice一开始拿走了两堆，那么Bob可以拿走剩下的三堆。在这种情况下，Alice得到2 + 7 = 9堆。返回10，因为它更大。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [1,2,3,4,5,100]\n<strong>输出：</strong>104\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= piles.length &lt;= 100</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>1 &lt;= piles[i]&nbsp;&lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1141.查询近30天活跃用户数",
        "hardRate": "EASY",
        "passRate": "44.93%",
        "problemsUrl": "https://leetcode.cn/problems/user-activity-for-the-past-30-days-i/",
        "solutionsUrl": "https://leetcode.cn/problems/user-activity-for-the-past-30-days-i/solution",
        "problemsDesc": "<p>活动记录表：<code>Activity</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| user_id       | int     |\n| session_id    | int     |\n| activity_date | date    |\n| activity_type | enum    |\n+---------------+---------+\n该表是用户在社交网站的活动记录。\n该表没有主键，可能包含重复数据。\nactivity_type 字段为以下四种值 ('open_session', 'end_session', 'scroll_down', 'send_message')。\n每个 session_id 只属于一个用户。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>请写SQL查询出截至&nbsp;<code>2019-07-27</code>（包含2019-07-27），近<strong>&nbsp;</strong><code>30</code> 天的每日活跃用户数（当天只要有一条活动记录，即为活跃用户）。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果示例如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nActivity table:\n+---------+------------+---------------+---------------+\n| user_id | session_id | activity_date | activity_type |\n+---------+------------+---------------+---------------+\n| 1       | 1          | 2019-07-20    | open_session  |\n| 1       | 1          | 2019-07-20    | scroll_down   |\n| 1       | 1          | 2019-07-20    | end_session   |\n| 2       | 4          | 2019-07-20    | open_session  |\n| 2       | 4          | 2019-07-21    | send_message  |\n| 2       | 4          | 2019-07-21    | end_session   |\n| 3       | 2          | 2019-07-21    | open_session  |\n| 3       | 2          | 2019-07-21    | send_message  |\n| 3       | 2          | 2019-07-21    | end_session   |\n| 4       | 3          | 2019-06-25    | open_session  |\n| 4       | 3          | 2019-06-25    | end_session   |\n+---------+------------+---------------+---------------+\n<strong>输出：</strong>\n+------------+--------------+ \n| day        | active_users |\n+------------+--------------+ \n| 2019-07-20 | 2            |\n| 2019-07-21 | 2            |\n+------------+--------------+ <strong>\n解释：</strong>注意非活跃用户的记录不需要展示。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1142.过去30天的用户活动 II",
        "hardRate": "EASY",
        "passRate": "37.19%",
        "problemsUrl": "https://leetcode.cn/problems/user-activity-for-the-past-30-days-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/user-activity-for-the-past-30-days-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1143.最长公共子序列",
        "hardRate": "MEDIUM",
        "passRate": "64.88%",
        "problemsUrl": "https://leetcode.cn/problems/longest-common-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-common-subsequence/solution",
        "problemsDesc": "<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>\n\n<p>一个字符串的 <strong>子序列</strong><em> </em>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>\n\n<ul>\n\t<li>例如，<code>\"ace\"</code> 是 <code>\"abcde\"</code> 的子序列，但 <code>\"aec\"</code> 不是 <code>\"abcde\"</code> 的子序列。</li>\n</ul>\n\n<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>text1 = \"abcde\", text2 = \"ace\" \n<strong>输出：</strong>3  \n<strong>解释：</strong>最长公共子序列是 \"ace\" ，它的长度为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>text1 = \"abc\", text2 = \"abc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>最长公共子序列是 \"abc\" ，它的长度为 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>text1 = \"abc\", text2 = \"def\"\n<strong>输出：</strong>0\n<strong>解释：</strong>两个字符串没有公共子序列，返回 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= text1.length, text2.length <= 1000</code></li>\n\t<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1144.递减元素使数组呈锯齿状",
        "hardRate": "MEDIUM",
        "passRate": "50.53%",
        "problemsUrl": "https://leetcode.cn/problems/decrease-elements-to-make-array-zigzag/",
        "solutionsUrl": "https://leetcode.cn/problems/decrease-elements-to-make-array-zigzag/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>，每次 <strong>操作</strong>&nbsp;会从中选择一个元素并 <strong>将该元素的值减少&nbsp;1</strong>。</p>\n\n<p>如果符合下列情况之一，则数组&nbsp;<code>A</code>&nbsp;就是 <strong>锯齿数组</strong>：</p>\n\n<ul>\n\t<li>每个偶数索引对应的元素都大于相邻的元素，即&nbsp;<code>A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; ...</code></li>\n\t<li>或者，每个奇数索引对应的元素都大于相邻的元素，即&nbsp;<code>A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; ...</code></li>\n</ul>\n\n<p>返回将数组&nbsp;<code>nums</code>&nbsp;转换为锯齿数组所需的最小操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>我们可以把 2 递减到 0，或把 3 递减到 1。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [9,6,1,6,2]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1145.二叉树着色游戏",
        "hardRate": "MEDIUM",
        "passRate": "55.40%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-coloring-game/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-coloring-game/solution",
        "problemsDesc": "<p>有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点&nbsp;<code>root</code>，树上总共有 <code>n</code> 个节点，且 <code>n</code> 为奇数，其中每个节点上的值从&nbsp;<code>1</code> 到&nbsp;<code>n</code>&nbsp;各不相同。</p>\n\n<p>最开始时：</p>\n\n<ul>\n\t<li>「一号」玩家从 <code>[1, n]</code>&nbsp;中取一个值&nbsp;<code>x</code>（<code>1 &lt;= x &lt;= n</code>）；</li>\n\t<li>「二号」玩家也从&nbsp;<code>[1, n]</code>&nbsp;中取一个值&nbsp;<code>y</code>（<code>1 &lt;= y &lt;= n</code>）且&nbsp;<code>y != x</code>。</li>\n</ul>\n\n<p>「一号」玩家给值为&nbsp;<code>x</code>&nbsp;的节点染上红色，而「二号」玩家给值为&nbsp;<code>y</code>&nbsp;的节点染上蓝色。</p>\n\n<p>之后两位玩家轮流进行操作，「一号」玩家先手。每一回合，玩家选择一个被他染过色的节点，将所选节点一个 <strong>未着色 </strong>的邻节点（即左右子节点、或父节点）进行染色（「一号」玩家染红色，「二号」玩家染蓝色）。</p>\n\n<p>如果（且仅在此种情况下）当前玩家无法找到这样的节点来染色时，其回合就会被跳过。</p>\n\n<p>若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利 ✌️。</p>\n\n<p>现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个&nbsp;<code>y</code>&nbsp;值可以确保你赢得这场游戏，则返回&nbsp;<code>true</code> ；若无法获胜，就请返回 <code>false</code> 。</p>\n&nbsp;\n\n<p><strong class=\"example\">示例 1 ：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/08/01/1480-binary-tree-coloring-game.png\" style=\"width: 500px; height: 310px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3\n<strong>输出：</strong>true\n<strong>解释：</strong>第二个玩家可以选择值为 2 的节点。</pre>\n\n<p><strong class=\"example\">示例 2 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3], n = 3, x = 1\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目为 <code>n</code></li>\n\t<li><code>1 &lt;= x &lt;= n &lt;= 100</code></li>\n\t<li><code>n</code> 是奇数</li>\n\t<li><code>1 &lt;= Node.val &lt;= n</code></li>\n\t<li>树中所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1146.快照数组",
        "hardRate": "MEDIUM",
        "passRate": "33.49%",
        "problemsUrl": "https://leetcode.cn/problems/snapshot-array/",
        "solutionsUrl": "https://leetcode.cn/problems/snapshot-array/solution",
        "problemsDesc": "<p>实现支持下列接口的「快照数组」-&nbsp;SnapshotArray：</p>\n\n<ul>\n\t<li><code>SnapshotArray(int length)</code>&nbsp;- 初始化一个与指定长度相等的 类数组 的数据结构。<strong>初始时，每个元素都等于</strong><strong>&nbsp;0</strong>。</li>\n\t<li><code>void set(index, val)</code>&nbsp;- 会将指定索引&nbsp;<code>index</code>&nbsp;处的元素设置为&nbsp;<code>val</code>。</li>\n\t<li><code>int snap()</code>&nbsp;- 获取该数组的快照，并返回快照的编号&nbsp;<code>snap_id</code>（快照号是调用&nbsp;<code>snap()</code>&nbsp;的总次数减去&nbsp;<code>1</code>）。</li>\n\t<li><code>int get(index, snap_id)</code>&nbsp;- 根据指定的&nbsp;<code>snap_id</code>&nbsp;选择快照，并返回该快照指定索引 <code>index</code>&nbsp;的值。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;SnapshotArray&quot;,&quot;set&quot;,&quot;snap&quot;,&quot;set&quot;,&quot;get&quot;]\n     [[3],[0,5],[],[0,6],[0,0]]\n<strong>输出：</strong>[null,null,0,null,5]\n<strong>解释：\n</strong>SnapshotArray snapshotArr = new SnapshotArray(3); // 初始化一个长度为 3 的快照数组\nsnapshotArr.set(0,5);  // 令 array[0] = 5\nsnapshotArr.snap();  // 获取快照，返回 snap_id = 0\nsnapshotArr.set(0,6);\nsnapshotArr.get(0,0);  // 获取 snap_id = 0 的快照中 array[0] 的值，返回 5</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= length&nbsp;&lt;= 50000</code></li>\n\t<li>题目最多进行<code>50000</code> 次<code>set</code>，<code>snap</code>，和&nbsp;<code>get</code>的调用 。</li>\n\t<li><code>0 &lt;= index&nbsp;&lt;&nbsp;length</code></li>\n\t<li><code>0 &lt;=&nbsp;snap_id &lt;&nbsp;</code>我们调用&nbsp;<code>snap()</code>&nbsp;的总次数</li>\n\t<li><code>0 &lt;=&nbsp;val &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1147.段式回文",
        "hardRate": "HARD",
        "passRate": "58.99%",
        "problemsUrl": "https://leetcode.cn/problems/longest-chunked-palindrome-decomposition/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-chunked-palindrome-decomposition/solution",
        "problemsDesc": "<p>你会得到一个字符串&nbsp;<code>text</code>&nbsp;。你应该把它分成 <code>k</code>&nbsp;个子字符串&nbsp;<code>(subtext1, subtext2，…， subtextk)</code>&nbsp;，要求满足:</p>\n\n<ul>\n\t<li><code>subtext<sub>i</sub></code><sub>&nbsp;</sub>是 <strong>非空&nbsp;</strong>字符串</li>\n\t<li>所有子字符串的连接等于 <code>text</code> ( 即<code>subtext<sub>1</sub>&nbsp;+ subtext<sub>2</sub>&nbsp;+ ... + subtext<sub>k</sub>&nbsp;== text</code>&nbsp;)</li>\n\t<li>对于所有 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">i</span></span></font></font>&nbsp;的有效值( 即&nbsp;<code>1 &lt;= i&nbsp;&lt;= k</code> ) ，<code>subtext<sub>i</sub>&nbsp;== subtext<sub>k - i + 1</sub></code> 均成立</li>\n</ul>\n\n<p>返回<code>k</code>可能最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = \"ghiabcdefhelloadamhelloabcdefghi\"\n<strong>输出：</strong>7\n<strong>解释：</strong>我们可以把字符串拆分成 \"(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = \"merchant\"\n<strong>输出：</strong>1\n<strong>解释：</strong>我们可以把字符串拆分成 \"(merchant)\"。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = \"antaprezatepzapreanta\"\n<strong>输出：</strong>11\n<strong>解释：</strong>我们可以把字符串拆分成 \"(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)\"。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 1000</code></li>\n\t<li><code>text</code>&nbsp;仅由小写英文字符组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1148.文章浏览 I",
        "hardRate": "EASY",
        "passRate": "71.26%",
        "problemsUrl": "https://leetcode.cn/problems/article-views-i/",
        "solutionsUrl": "https://leetcode.cn/problems/article-views-i/solution",
        "problemsDesc": "<p><code>Views</code>&nbsp;表：</p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| article_id    | int     |\n| author_id     | int     |\n| viewer_id     | int     |\n| view_date     | date    |\n+---------------+---------+\n此表无主键，因此可能会存在重复行。\n此表的每一行都表示某人在某天浏览了某位作者的某篇文章。\n请注意，同一人的 author_id 和 viewer_id 是相同的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>请编写一条 SQL 查询以找出所有浏览过自己文章的作者，结果按照 id 升序排列。</p>\n\n<p>查询结果的格式如下所示：</p>\n\n<pre>\nViews 表：\n+------------+-----------+-----------+------------+\n| article_id | author_id | viewer_id | view_date  |\n+------------+-----------+-----------+------------+\n| 1          | 3         | 5         | 2019-08-01 |\n| 1          | 3         | 6         | 2019-08-02 |\n| 2          | 7         | 7         | 2019-08-01 |\n| 2          | 7         | 6         | 2019-08-02 |\n| 4          | 7         | 1         | 2019-07-22 |\n| 3          | 4         | 4         | 2019-07-21 |\n| 3          | 4         | 4         | 2019-07-21 |\n+------------+-----------+-----------+------------+\n\n结果表：\n+------+\n| id   |\n+------+\n| 4    |\n| 7    |\n+------+\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1149.文章浏览 II",
        "hardRate": "MEDIUM",
        "passRate": "44.45%",
        "problemsUrl": "https://leetcode.cn/problems/article-views-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/article-views-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1150.检查一个数是否在数组中占绝大多数",
        "hardRate": "EASY",
        "passRate": "59.53%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-number-is-majority-element-in-a-sorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-number-is-majority-element-in-a-sorted-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1151.最少交换次数来组合所有的 1",
        "hardRate": "MEDIUM",
        "passRate": "52.81%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1152.用户网站访问行为分析",
        "hardRate": "MEDIUM",
        "passRate": "41.44%",
        "problemsUrl": "https://leetcode.cn/problems/analyze-user-website-visit-pattern/",
        "solutionsUrl": "https://leetcode.cn/problems/analyze-user-website-visit-pattern/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1153.字符串转化",
        "hardRate": "HARD",
        "passRate": "37.78%",
        "problemsUrl": "https://leetcode.cn/problems/string-transforms-into-another-string/",
        "solutionsUrl": "https://leetcode.cn/problems/string-transforms-into-another-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1154.一年中的第几天",
        "hardRate": "EASY",
        "passRate": "62.46%",
        "problemsUrl": "https://leetcode.cn/problems/day-of-the-year/",
        "solutionsUrl": "https://leetcode.cn/problems/day-of-the-year/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>date</code> ，按 <code>YYYY-MM-DD</code> 格式表示一个 <a href=\"https://baike.baidu.com/item/公元/17855\" target=\"_blank\">现行公元纪年法</a> 日期。返回该日期是当年的第几天。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>date = \"2019-01-09\"\n<strong>输出：</strong>9\n<strong>解释：</strong>给定日期是2019年的第九天。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>date = \"2019-02-10\"\n<strong>输出：</strong>41\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>date.length == 10</code></li>\n\t<li><code>date[4] == date[7] == '-'</code>，其他的&nbsp;<code>date[i]</code>&nbsp;都是数字</li>\n\t<li><code>date</code> 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1155.掷骰子等于目标和的方法数",
        "hardRate": "MEDIUM",
        "passRate": "50.95%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/solution",
        "problemsDesc": "<p>这里有&nbsp;<code>n</code>&nbsp;个一样的骰子，每个骰子上都有&nbsp;<code>k</code>&nbsp;个面，分别标号为&nbsp;<code>1</code>&nbsp;到 <code>k</code> 。</p>\n\n<p>给定三个整数 <code>n</code> ,&nbsp; <code>k</code> 和&nbsp;<code>target</code>&nbsp;，返回可能的方式(从总共<em>&nbsp;</em><code>k<sup>n</sup></code><em>&nbsp;</em>种方式中)滚动骰子的数量，使正面朝上的数字之和等于<em>&nbsp;</em><code>target</code>&nbsp;。</p>\n\n<p>答案可能很大，你需要对&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code> <strong>取模</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, k = 6, target = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>你扔一个有6张脸的骰子。\n得到3的和只有一种方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 6, target = 7\n<strong>输出：</strong>6\n<strong>解释：</strong>你扔两个骰子，每个骰子有6个面。\n得到7的和有6种方法1+6 2+5 3+4 4+3 5+2 6+1。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 30, k = 30, target = 500\n<strong>输出：</strong>222616187\n<strong>解释：</strong>返回的结果必须是对 10<sup>9</sup> + 7 取模。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, k &lt;= 30</code></li>\n\t<li><code>1 &lt;= target &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1156.单字符重复子串的最大长度",
        "hardRate": "MEDIUM",
        "passRate": "51.26%",
        "problemsUrl": "https://leetcode.cn/problems/swap-for-longest-repeated-character-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/swap-for-longest-repeated-character-substring/solution",
        "problemsDesc": "<p>如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字符串。</p>\n\n<p>给你一个字符串&nbsp;<code>text</code>，你只能交换其中两个字符一次或者什么都不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;ababa&quot;\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;aaabaaa&quot;\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;aaabbaaa&quot;\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;aaaaa&quot;\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;abcdef&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 20000</code></li>\n\t<li><code>text</code> 仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1157.子数组中占绝大多数的元素",
        "hardRate": "HARD",
        "passRate": "46.14%",
        "problemsUrl": "https://leetcode.cn/problems/online-majority-element-in-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/online-majority-element-in-subarray/solution",
        "problemsDesc": "<p>设计一个数据结构，有效地找到给定子数组的 <strong>多数元素</strong> 。</p>\n\n<p>子数组的 <strong>多数元素</strong> 是在子数组中出现&nbsp;<code>threshold</code>&nbsp;次数或次数以上的元素。</p>\n\n<p>实现 <code>MajorityChecker</code> 类:</p>\n\n<ul>\n\t<li><code>MajorityChecker(int[] arr)</code>&nbsp;会用给定的数组 <code>arr</code>&nbsp;对&nbsp;<code>MajorityChecker</code> 初始化。</li>\n\t<li><code>int query(int left, int right, int threshold)</code>&nbsp;返回子数组中的元素 &nbsp;<code>arr[left...right]</code>&nbsp;至少出现&nbsp;<code>threshold</code>&nbsp;次数，如果不存在这样的元素则返回 <code>-1</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong>\n[\"MajorityChecker\", \"query\", \"query\", \"query\"]\n[[[1, 1, 2, 2, 1, 1]], [0, 5, 4], [0, 3, 3], [2, 3, 2]]\n<strong>输出：</strong>\n[null, 1, -1, 2]\n\n<b>解释：</b>\nMajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]);\nmajorityChecker.query(0,5,4); // 返回 1\nmajorityChecker.query(0,3,3); // 返回 -1\nmajorityChecker.query(2,3,2); // 返回 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= left &lt;= right &lt; arr.length</code></li>\n\t<li><code>threshold &lt;= right - left + 1</code></li>\n\t<li><code>2 * threshold &gt; right - left + 1</code></li>\n\t<li>调用&nbsp;<code>query</code>&nbsp;的次数最多为&nbsp;<code>10<sup>4</sup></code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1158.市场分析 I",
        "hardRate": "MEDIUM",
        "passRate": "54.49%",
        "problemsUrl": "https://leetcode.cn/problems/market-analysis-i/",
        "solutionsUrl": "https://leetcode.cn/problems/market-analysis-i/solution",
        "problemsDesc": "<p>Table: <code>Users</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| user_id        | int     |\n| join_date      | date    |\n| favorite_brand | varchar |\n+----------------+---------+\n此表主键是 user_id。\n表中描述了购物网站的用户信息，用户可以在此网站上进行商品买卖。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Orders</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| order_id      | int     |\n| order_date    | date    |\n| item_id       | int     |\n| buyer_id      | int     |\n| seller_id     | int     |\n+---------------+---------+\n此表主键是 order_id。\n外键是 item_id 和（buyer_id，seller_id）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Items</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| item_id       | int     |\n| item_brand    | varchar |\n+---------------+---------+\n此表主键是 item_id。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>请写出一条SQL语句以查询每个用户的注册日期和在 <strong><code>2019</code> </strong>年作为买家的订单总数。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nUsers 表:\n+---------+------------+----------------+\n| user_id | join_date  | favorite_brand |\n+---------+------------+----------------+\n| 1       | 2018-01-01 | Lenovo         |\n| 2       | 2018-02-09 | Samsung        |\n| 3       | 2018-01-19 | LG             |\n| 4       | 2018-05-21 | HP             |\n+---------+------------+----------------+\nOrders 表:\n+----------+------------+---------+----------+-----------+\n| order_id | order_date | item_id | buyer_id | seller_id |\n+----------+------------+---------+----------+-----------+\n| 1        | 2019-08-01 | 4       | 1        | 2         |\n| 2        | 2018-08-02 | 2       | 1        | 3         |\n| 3        | 2019-08-03 | 3       | 2        | 3         |\n| 4        | 2018-08-04 | 1       | 4        | 2         |\n| 5        | 2018-08-04 | 1       | 3        | 4         |\n| 6        | 2019-08-05 | 2       | 2        | 4         |\n+----------+------------+---------+----------+-----------+\nItems 表:\n+---------+------------+\n| item_id | item_brand |\n+---------+------------+\n| 1       | Samsung    |\n| 2       | Lenovo     |\n| 3       | LG         |\n| 4       | HP         |\n+---------+------------+\n<strong>输出：</strong>\n+-----------+------------+----------------+\n| buyer_id  | join_date  | orders_in_2019 |\n+-----------+------------+----------------+\n| 1         | 2018-01-01 | 1              |\n| 2         | 2018-02-09 | 2              |\n| 3         | 2018-01-19 | 0              |\n| 4         | 2018-05-21 | 0              |\n+-----------+------------+----------------+</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1159.市场分析 II",
        "hardRate": "HARD",
        "passRate": "50.63%",
        "problemsUrl": "https://leetcode.cn/problems/market-analysis-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/market-analysis-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1160.拼写单词",
        "hardRate": "EASY",
        "passRate": "68.19%",
        "problemsUrl": "https://leetcode.cn/problems/find-words-that-can-be-formed-by-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/find-words-that-can-be-formed-by-characters/solution",
        "problemsDesc": "<p>给你一份『词汇表』（字符串数组）&nbsp;<code>words</code>&nbsp;和一张『字母表』（字符串）&nbsp;<code>chars</code>。</p>\n\n<p>假如你可以用&nbsp;<code>chars</code>&nbsp;中的『字母』（字符）拼写出 <code>words</code>&nbsp;中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p>\n\n<p>注意：每次拼写（指拼写词汇表中的一个单词）时，<code>chars</code> 中的每个字母都只能用一次。</p>\n\n<p>返回词汇表&nbsp;<code>words</code>&nbsp;中你掌握的所有单词的 <strong>长度之和</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;\n<strong>输出：</strong>6\n<strong>解释： </strong>\n可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;\n<strong>输出：</strong>10\n<strong>解释：</strong>\n可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 = 10。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length, chars.length&nbsp;&lt;= 100</code></li>\n\t<li>所有字符串中都仅包含小写英文字母</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1161.最大层内元素和",
        "hardRate": "MEDIUM",
        "passRate": "66.11%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/solution",
        "problemsDesc": "<p>给你一个二叉树的根节点&nbsp;<code>root</code>。设根节点位于二叉树的第 <code>1</code> 层，而根节点的子节点位于第 <code>2</code> 层，依此类推。</p>\n\n<p>请返回层内元素之和 <strong>最大</strong> 的那几层（可能只有一层）的层号，并返回其中&nbsp;<strong>最小</strong> 的那个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/capture.jpeg\" style=\"height: 175px; width: 200px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,7,0,7,-8,null,null]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n第 1 层各元素之和为 1，\n第 2 层各元素之和为 7 + 0 = 7，\n第 3 层各元素之和为 7 + -8 = -1，\n所以我们返回第 2 层的层号，它的层内元素之和最大。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [989,null,10250,98693,-89388,null,null,null,-32127]\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数在<meta charset=\"UTF-8\" />&nbsp;<code>[1, 10<sup>4</sup>]</code>范围内<meta charset=\"UTF-8\" /></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1162.地图分析",
        "hardRate": "MEDIUM",
        "passRate": "46.71%",
        "problemsUrl": "https://leetcode.cn/problems/as-far-from-land-as-possible/",
        "solutionsUrl": "https://leetcode.cn/problems/as-far-from-land-as-possible/solution",
        "problemsDesc": "<p>你现在手里有一份大小为<meta charset=\"UTF-8\" />&nbsp;<code>n x n</code>&nbsp;的 网格 <code>grid</code>，上面的每个 单元格 都用&nbsp;<code>0</code>&nbsp;和&nbsp;<code>1</code>&nbsp;标记好了。其中&nbsp;<code>0</code>&nbsp;代表海洋，<code>1</code>&nbsp;代表陆地。</p>\n\n<p>请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。如果网格上只有陆地或者海洋，请返回&nbsp;<code>-1</code>。</p>\n\n<p>我们这里说的距离是「曼哈顿距离」（&nbsp;Manhattan Distance）：<code>(x0, y0)</code> 和&nbsp;<code>(x1, y1)</code>&nbsp;这两个单元格之间的距离是&nbsp;<code>|x0 - x1| + |y0 - y1|</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/1336_ex1.jpeg\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,0,1],[0,0,0],[1,0,1]]\n<strong>输出：</strong>2\n<strong>解释： </strong>\n海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/1336_ex2.jpeg\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,0,0],[0,0,0],[0,0,0]]\n<strong>输出：</strong>4\n<strong>解释： </strong>\n海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 100</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;不是&nbsp;<code>0</code>&nbsp;就是&nbsp;<code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1163.按字典序排在最后的子串",
        "hardRate": "HARD",
        "passRate": "35.25%",
        "problemsUrl": "https://leetcode.cn/problems/last-substring-in-lexicographical-order/",
        "solutionsUrl": "https://leetcode.cn/problems/last-substring-in-lexicographical-order/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，找出它的所有子串并按字典序排列，返回排在最后的那个子串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abab\"\n<strong>输出：</strong>\"bab\"\n<strong>解释：</strong>我们可以找出 7 个子串 [\"a\", \"ab\", \"aba\", \"abab\", \"b\", \"ba\", \"bab\"]。按字典序排在最后的子串是 \"bab\"。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leetcode\"\n<strong>输出：</strong>\"tcode\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 4 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅含有小写英文字符。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1164.指定日期的产品价格",
        "hardRate": "MEDIUM",
        "passRate": "58.60%",
        "problemsUrl": "https://leetcode.cn/problems/product-price-at-a-given-date/",
        "solutionsUrl": "https://leetcode.cn/problems/product-price-at-a-given-date/solution",
        "problemsDesc": "<p>产品数据表: <code>Products</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| product_id    | int     |\n| new_price     | int     |\n| change_date   | date    |\n+---------------+---------+\n这张表的主键是 (product_id, change_date)。\n这张表的每一行分别记录了 某产品 在某个日期 更改后 的新价格。</pre>\n\n<p>&nbsp;</p>\n\n<p>写一段 SQL来查找在&nbsp;<code>2019-08-16</code><strong> </strong>时全部产品的价格，假设所有产品在修改前的价格都是&nbsp;<code>10</code><strong> 。</strong></p>\n\n<p>以 <strong>任意顺序 </strong>返回结果表。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<code><strong>输入：</strong>\nProducts</code> 表:\n+------------+-----------+-------------+\n| product_id | new_price | change_date |\n+------------+-----------+-------------+\n| 1          | 20        | 2019-08-14  |\n| 2          | 50        | 2019-08-14  |\n| 1          | 30        | 2019-08-15  |\n| 1          | 35        | 2019-08-16  |\n| 2          | 65        | 2019-08-17  |\n| 3          | 20        | 2019-08-18  |\n+------------+-----------+-------------+\n<strong>输出：</strong>\n+------------+-------+\n| product_id | price |\n+------------+-------+\n| 2          | 50    |\n| 1          | 35    |\n| 3          | 10    |\n+------------+-------+</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1165.单行键盘",
        "hardRate": "EASY",
        "passRate": "84.13%",
        "problemsUrl": "https://leetcode.cn/problems/single-row-keyboard/",
        "solutionsUrl": "https://leetcode.cn/problems/single-row-keyboard/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1166.设计文件系统",
        "hardRate": "MEDIUM",
        "passRate": "49.69%",
        "problemsUrl": "https://leetcode.cn/problems/design-file-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-file-system/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1167.连接棒材的最低费用",
        "hardRate": "MEDIUM",
        "passRate": "51.35%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-connect-sticks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-connect-sticks/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1168.水资源分配优化",
        "hardRate": "HARD",
        "passRate": "62.53%",
        "problemsUrl": "https://leetcode.cn/problems/optimize-water-distribution-in-a-village/",
        "solutionsUrl": "https://leetcode.cn/problems/optimize-water-distribution-in-a-village/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1169.查询无效交易",
        "hardRate": "MEDIUM",
        "passRate": "32.99%",
        "problemsUrl": "https://leetcode.cn/problems/invalid-transactions/",
        "solutionsUrl": "https://leetcode.cn/problems/invalid-transactions/solution",
        "problemsDesc": "<p>如果出现下述两种情况，交易 <strong>可能无效</strong>：</p>\n\n<ul>\n\t<li>交易金额超过<meta charset=\"UTF-8\" />&nbsp;<code>$1000</code></li>\n\t<li>或者，它和&nbsp;<strong>另一个城市</strong>&nbsp;中 <strong>同名</strong> 的另一笔交易相隔不超过 <code>60</code> 分钟（包含 60 分钟整）</li>\n</ul>\n\n<p>给定字符串数组交易清单<meta charset=\"UTF-8\" />&nbsp;<code>transaction</code>&nbsp;。每个交易字符串&nbsp;<code>transactions[i]</code>&nbsp;由一些用逗号分隔的值组成，这些值分别表示交易的名称，时间（以分钟计），金额以及城市。</p>\n\n<p>返回&nbsp;<code>transactions</code>，返回可能无效的交易列表。你可以按 <strong>任何顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n<strong>输出：</strong>[\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n<strong>解释：</strong>第一笔交易是无效的，因为第二笔交易和它间隔不超过 60 分钟、名称相同且发生在不同的城市。同样，第二笔交易也是无效的。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\n<strong>输出：</strong>[\"alice,50,1200,mtv\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\n<strong>输出：</strong>[\"bob,50,1200,mtv\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>transactions.length &lt;= 1000</code></li>\n\t<li>每笔交易&nbsp;<code>transactions[i]</code>&nbsp;按&nbsp;<code>\"{name},{time},{amount},{city}\"</code>&nbsp;的格式进行记录</li>\n\t<li>每个交易名称&nbsp;<code>{name}</code>&nbsp;和城市&nbsp;<code>{city}</code>&nbsp;都由小写英文字母组成，长度在&nbsp;<code>1</code>&nbsp;到&nbsp;<code>10</code>&nbsp;之间</li>\n\t<li>每个交易时间&nbsp;<code>{time}</code>&nbsp;由一些数字组成，表示一个&nbsp;<code>0</code>&nbsp;到&nbsp;<code>1000</code>&nbsp;之间的整数</li>\n\t<li>每笔交易金额&nbsp;<code>{amount}</code>&nbsp;由一些数字组成，表示一个&nbsp;<code>0</code> 到&nbsp;<code>2000</code>&nbsp;之间的整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1170.比较字符串最小字母出现频次",
        "hardRate": "MEDIUM",
        "passRate": "66.31%",
        "problemsUrl": "https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/",
        "solutionsUrl": "https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/solution",
        "problemsDesc": "<p>定义一个函数 <code>f(s)</code>，统计 <code>s</code>  中<strong>（按字典序比较）最小字母的出现频次</strong> ，其中 <code>s</code> 是一个非空字符串。</p>\n\n<p>例如，若 <code>s = \"dcce\"</code>，那么 <code>f(s) = 2</code>，因为字典序最小字母是 <code>\"c\"</code>，它出现了 2 次。</p>\n\n<p>现在，给你两个字符串数组待查表 <code>queries</code> 和词汇表 <code>words</code> 。对于每次查询 <code>queries[i]</code> ，需统计 <code>words</code> 中满足 <code>f(queries[i])</code> < <code>f(W)</code> 的<strong> 词的数目</strong> ，<code>W</code> 表示词汇表 <code>words</code> 中的每个词。</p>\n\n<p>请你返回一个整数数组 <code>answer</code> 作为答案，其中每个 <code>answer[i]</code> 是第 <code>i</code> 次查询的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>queries = [\"cbd\"], words = [\"zaaaz\"]\n<strong>输出：</strong>[1]\n<strong>解释：</strong>查询 f(\"cbd\") = 1，而 f(\"zaaaz\") = 3 所以 f(\"cbd\") < f(\"zaaaz\")。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>queries = [\"bbb\",\"cc\"], words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>第一个查询 f(\"bbb\") < f(\"aaaa\")，第二个查询 f(\"aaa\") 和 f(\"aaaa\") 都 > f(\"cc\")。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= queries.length <= 2000</code></li>\n\t<li><code>1 <= words.length <= 2000</code></li>\n\t<li><code>1 <= queries[i].length, words[i].length <= 10</code></li>\n\t<li><code>queries[i][j]</code>、<code>words[i][j]</code> 都由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1171.从链表中删去总和值为零的连续节点",
        "hardRate": "MEDIUM",
        "passRate": "53.06%",
        "problemsUrl": "https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/solution",
        "problemsDesc": "<p>给你一个链表的头节点&nbsp;<code>head</code>，请你编写代码，反复删去链表中由 <strong>总和</strong>&nbsp;值为 <code>0</code> 的连续节点组成的序列，直到不存在这样的序列为止。</p>\n\n<p>删除完毕后，请你返回最终结果链表的头节点。</p>\n\n<p>&nbsp;</p>\n\n<p>你可以返回任何满足题目要求的答案。</p>\n\n<p>（注意，下面示例中的所有序列，都是对&nbsp;<code>ListNode</code>&nbsp;对象序列化的表示。）</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>head = [1,2,-3,3,1]\n<strong>输出：</strong>[3,1]\n<strong>提示：</strong>答案 [1,2,1] 也是正确的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>head = [1,2,3,-3,4]\n<strong>输出：</strong>[1,2,4]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>head = [1,2,3,-3,-2]\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给你的链表中可能有 <code>1</code> 到&nbsp;<code>1000</code>&nbsp;个节点。</li>\n\t<li>对于链表中的每个节点，节点的值：<code>-1000 &lt;= node.val &lt;= 1000</code>.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1172.餐盘栈",
        "hardRate": "HARD",
        "passRate": "40.01%",
        "problemsUrl": "https://leetcode.cn/problems/dinner-plate-stacks/",
        "solutionsUrl": "https://leetcode.cn/problems/dinner-plate-stacks/solution",
        "problemsDesc": "<p>我们把无限数量 &infin; 的栈排成一行，按从左到右的次序从 0 开始编号。每个栈的的最大容量&nbsp;<code>capacity</code> 都相同。</p>\n\n<p>实现一个叫「餐盘」的类&nbsp;<code>DinnerPlates</code>：</p>\n\n<ul>\n\t<li><code>DinnerPlates(int capacity)</code>&nbsp;- 给出栈的最大容量&nbsp;<code>capacity</code>。</li>\n\t<li><code>void push(int val)</code>&nbsp;- 将给出的正整数&nbsp;<code>val</code>&nbsp;推入&nbsp;<strong>从左往右第一个&nbsp;</strong>没有满的栈。</li>\n\t<li><code>int pop()</code>&nbsp;- 返回&nbsp;<strong>从右往左第一个&nbsp;</strong>非空栈顶部的值，并将其从栈中删除；如果所有的栈都是空的，请返回&nbsp;<code>-1</code>。</li>\n\t<li><code>int popAtStack(int index)</code>&nbsp;- 返回编号&nbsp;<code>index</code>&nbsp;的栈顶部的值，并将其从栈中删除；如果编号&nbsp;<code>index</code>&nbsp;的栈是空的，请返回 <code>-1</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入： </strong>\n[&quot;DinnerPlates&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;popAtStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;popAtStack&quot;,&quot;popAtStack&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;]\n[[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]]\n<strong>输出：</strong>\n[null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1]\n\n<strong>解释：</strong>\nDinnerPlates D = DinnerPlates(2);  // 初始化，栈最大容量 capacity = 2\nD.push(1);\nD.push(2);\nD.push(3);\nD.push(4);\nD.push(5);         // 栈的现状为：    2 &nbsp;4\n&nbsp;                                   1 &nbsp;3 &nbsp;5\n                                    ﹈ ﹈ ﹈\nD.popAtStack(0);   // 返回 2。栈的现状为：     &nbsp;4\n            &nbsp;                             1 &nbsp;3 &nbsp;5\n                                          ﹈ ﹈ ﹈\nD.push(20);        // 栈的现状为：  20  4\n&nbsp;                                  1 &nbsp;3 &nbsp;5\n                                   ﹈ ﹈ ﹈\nD.push(21);        // 栈的现状为：  20  4 21\n&nbsp;                                  1 &nbsp;3 &nbsp;5\n                                   ﹈ ﹈ ﹈\nD.popAtStack(0);   // 返回 20。栈的现状为：       4 21\n             &nbsp;                              1 &nbsp;3 &nbsp;5\n                                            ﹈ ﹈ ﹈\nD.popAtStack(2);   // 返回 21。栈的现状为：       4\n             &nbsp;                              1 &nbsp;3 &nbsp;5\n                                            ﹈ ﹈ ﹈ \nD.pop()            // 返回 5。栈的现状为：        4\n             &nbsp;                              1 &nbsp;3 \n                                            ﹈ ﹈  \nD.pop()            // 返回 4。栈的现状为：    1  3 \n                                           ﹈ ﹈   \nD.pop()            // 返回 3。栈的现状为：    1 \n                                           ﹈   \nD.pop()            // 返回 1。现在没有栈。\nD.pop()            // 返回 -1。仍然没有栈。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= capacity&nbsp;&lt;= 20000</code></li>\n\t<li><code>1 &lt;= val&nbsp;&lt;= 20000</code></li>\n\t<li><code>0 &lt;= index&nbsp;&lt;= 100000</code></li>\n\t<li>最多会对&nbsp;<code>push</code>，<code>pop</code>，和&nbsp;<code>popAtStack</code>&nbsp;进行 <code>200000</code> 次调用。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1173.即时食物配送 I",
        "hardRate": "EASY",
        "passRate": "76.49%",
        "problemsUrl": "https://leetcode.cn/problems/immediate-food-delivery-i/",
        "solutionsUrl": "https://leetcode.cn/problems/immediate-food-delivery-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1174.即时食物配送 II",
        "hardRate": "MEDIUM",
        "passRate": "61.80%",
        "problemsUrl": "https://leetcode.cn/problems/immediate-food-delivery-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/immediate-food-delivery-ii/solution",
        "problemsDesc": "<p>配送表: <code>Delivery</code></p>\n\n<pre>+-----------------------------+---------+\n| Column Name                 | Type    |\n+-----------------------------+---------+\n| delivery_id                 | int     |\n| customer_id                 | int     |\n| order_date                  | date    |\n| customer_pref_delivery_date | date    |\n+-----------------------------+---------+\ndelivery_id 是表的主键。\n该表保存着顾客的食物配送信息，顾客在某个日期下了订单，并指定了一个期望的配送日期（和下单日期相同或者在那之后）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>如果顾客期望的配送日期和下单日期相同，则该订单称为 「即时订单」，否则称为「计划订单」。</p>\n\n<p>「首次订单」是顾客最早创建的订单。我们保证一个顾客只会有一个「首次订单」。</p>\n\n<p>写一条 SQL 查询语句获取即时订单在所有用户的首次订单中的比例。<strong>保留两位小数。</strong></p>\n\n<p>&nbsp;</p>\n\n<p>查询结果如下所示：</p>\n\n<pre>Delivery 表：\n+-------------+-------------+------------+-----------------------------+\n| delivery_id | customer_id | order_date | customer_pref_delivery_date |\n+-------------+-------------+------------+-----------------------------+\n| 1           | 1           | 2019-08-01 | 2019-08-02                  |\n| 2           | 2           | 2019-08-02 | 2019-08-02                  |\n| 3           | 1           | 2019-08-11 | 2019-08-12                  |\n| 4           | 3           | 2019-08-24 | 2019-08-24                  |\n| 5           | 3           | 2019-08-21 | 2019-08-22                  |\n| 6           | 2           | 2019-08-11 | 2019-08-13                  |\n| 7           | 4           | 2019-08-09 | 2019-08-09                  |\n+-------------+-------------+------------+-----------------------------+\n\nResult 表：\n+----------------------+\n| immediate_percentage |\n+----------------------+\n| 50.00                |\n+----------------------+\n1 号顾客的 1 号订单是首次订单，并且是计划订单。\n2 号顾客的 2 号订单是首次订单，并且是即时订单。\n3 号顾客的 5 号订单是首次订单，并且是计划订单。\n4 号顾客的 7 号订单是首次订单，并且是即时订单。\n因此，一半顾客的首次订单是即时的。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1175.质数排列",
        "hardRate": "EASY",
        "passRate": "56.31%",
        "problemsUrl": "https://leetcode.cn/problems/prime-arrangements/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-arrangements/solution",
        "problemsDesc": "<p>请你帮忙给从 <code>1</code> 到 <code>n</code>&nbsp;的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。</p>\n\n<p>让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。</p>\n\n<p>由于答案可能会很大，所以请你返回答案 <strong>模 mod&nbsp;<code>10^9 + 7</code></strong>&nbsp;之后的结果即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 5\n<strong>输出：</strong>12\n<strong>解释：</strong>举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 100\n<strong>输出：</strong>682289015\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1176.健身计划评估",
        "hardRate": "EASY",
        "passRate": "48.56%",
        "problemsUrl": "https://leetcode.cn/problems/diet-plan-performance/",
        "solutionsUrl": "https://leetcode.cn/problems/diet-plan-performance/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1177.构建回文串检测",
        "hardRate": "MEDIUM",
        "passRate": "41.90%",
        "problemsUrl": "https://leetcode.cn/problems/can-make-palindrome-from-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/can-make-palindrome-from-substring/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>，请你对&nbsp;<code>s</code>&nbsp;的子串进行检测。</p>\n\n<p>每次检测，待检子串都可以表示为&nbsp;<code>queries[i] = [left, right, k]</code>。我们可以 <strong>重新排列</strong> 子串&nbsp;<code>s[left], ..., s[right]</code>，并从中选择 <strong>最多</strong> <code>k</code>&nbsp;项替换成任何小写英文字母。&nbsp;</p>\n\n<p>如果在上述检测过程中，子串可以变成回文形式的字符串，那么检测结果为&nbsp;<code>true</code>，否则结果为&nbsp;<code>false</code>。</p>\n\n<p>返回答案数组&nbsp;<code>answer[]</code>，其中&nbsp;<code>answer[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个待检子串&nbsp;<code>queries[i]</code>&nbsp;的检测结果。</p>\n\n<p>注意：在替换时，子串中的每个字母都必须作为 <strong>独立的</strong> 项进行计数，也就是说，如果&nbsp;<code>s[left..right] = &quot;aaa&quot;</code>&nbsp;且&nbsp;<code>k = 2</code>，我们只能替换其中的两个字母。（另外，任何检测都不会修改原始字符串 <code>s</code>，可以认为每次检测都是独立的）</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abcda&quot;, queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]\n<strong>输出：</strong>[true,false,false,true,true]\n<strong>解释：</strong>\nqueries[0] : 子串 = &quot;d&quot;，回文。\nqueries[1] :&nbsp;子串 = &quot;bc&quot;，不是回文。\nqueries[2] :&nbsp;子串 = &quot;abcd&quot;，只替换 1 个字符是变不成回文串的。\nqueries[3] :&nbsp;子串 = &quot;abcd&quot;，可以变成回文的 &quot;abba&quot;。 也可以变成 &quot;baab&quot;，先重新排序变成 &quot;bacd&quot;，然后把 &quot;cd&quot; 替换为 &quot;ab&quot;。\nqueries[4] :&nbsp;子串 = &quot;abcda&quot;，可以变成回文的 &quot;abcba&quot;。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length,&nbsp;queries.length&nbsp;&lt;= 10^5</code></li>\n\t<li><code>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt;&nbsp;s.length</code></li>\n\t<li><code>0 &lt;= queries[i][2] &lt;= s.length</code></li>\n\t<li><code>s</code> 中只有小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1178.猜字谜",
        "hardRate": "HARD",
        "passRate": "46.71%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-valid-words-for-each-puzzle/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-valid-words-for-each-puzzle/solution",
        "problemsDesc": "<p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p>\n\n<p>字谜的迷面 <code>puzzle</code> 按字符串形式给出，如果一个单词 <code>word</code> 符合下面两个条件，那么它就可以算作谜底：</p>\n\n<ul>\n\t<li>单词 <code>word</code> 中包含谜面 <code>puzzle</code> 的第一个字母。</li>\n\t<li>单词 <code>word</code> 中的每一个字母都可以在谜面 <code>puzzle</code> 中找到。<br />\n\t例如，如果字谜的谜面是 \"abcdefg\"，那么可以作为谜底的单词有 \"faced\", \"cabbage\", 和 \"baggage\"；而 \"beefed\"（不含字母 \"a\"）以及 \"based\"（其中的 \"s\" 没有出现在谜面中）都不能作为谜底。</li>\n</ul>\n\n<p>返回一个答案数组 <code>answer</code>，数组中的每个元素 <code>answer[i]</code> 是在给出的单词列表 <code>words</code> 中可以作为字谜迷面 <code>puzzles[i]</code> 所对应的谜底的单词数目。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nwords = [\"aaaa\",\"asas\",\"able\",\"ability\",\"actt\",\"actor\",\"access\"], \npuzzles = [\"aboveyz\",\"abrodyz\",\"abslute\",\"absoryz\",\"actresz\",\"gaswxyz\"]\n<strong>输出：</strong>[1,1,3,2,4,0]\n<strong>解释：</strong>\n1 个单词可以作为 \"aboveyz\" 的谜底 : \"aaaa\" \n1 个单词可以作为 \"abrodyz\" 的谜底 : \"aaaa\"\n3 个单词可以作为 \"abslute\" 的谜底 : \"aaaa\", \"asas\", \"able\"\n2 个单词可以作为 \"absoryz\" 的谜底 : \"aaaa\", \"asas\"\n4 个单词可以作为 \"actresz\" 的谜底 : \"aaaa\", \"asas\", \"actt\", \"access\"\n没有单词可以作为 \"gaswxyz\" 的谜底，因为列表中的单词都不含字母 'g'。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 10^5</code></li>\n\t<li><code>4 <= words[i].length <= 50</code></li>\n\t<li><code>1 <= puzzles.length <= 10^4</code></li>\n\t<li><code>puzzles[i].length == 7</code></li>\n\t<li><code>words[i][j]</code>, <code>puzzles[i][j]</code> 都是小写英文字母。</li>\n\t<li>每个 <code>puzzles[i]</code> 所包含的字符都不重复。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1179.重新格式化部门表",
        "hardRate": "EASY",
        "passRate": "64.80%",
        "problemsUrl": "https://leetcode.cn/problems/reformat-department-table/",
        "solutionsUrl": "https://leetcode.cn/problems/reformat-department-table/solution",
        "problemsDesc": "<p>部门表&nbsp;<code>Department</code>：</p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| revenue       | int     |\n| month         | varchar |\n+---------------+---------+\n(id, month) 是表的联合主键。\n这个表格有关于每个部门每月收入的信息。\n月份（month）可以取下列值 [&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;]。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询来重新格式化表，使得新的表中有一个部门 id 列和一些对应&nbsp;<strong>每个月 </strong>的收入（revenue）列。</p>\n\n<p>查询结果格式如下面的示例所示：</p>\n\n<pre>\nDepartment 表：\n+------+---------+-------+\n| id   | revenue | month |\n+------+---------+-------+\n| 1    | 8000    | Jan   |\n| 2    | 9000    | Jan   |\n| 3    | 10000   | Feb   |\n| 1    | 7000    | Feb   |\n| 1    | 6000    | Mar   |\n+------+---------+-------+\n\n查询得到的结果表：\n+------+-------------+-------------+-------------+-----+-------------+\n| id   | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue |\n+------+-------------+-------------+-------------+-----+-------------+\n| 1    | 8000        | 7000        | 6000        | ... | null        |\n| 2    | 9000        | null        | null        | ... | null        |\n| 3    | null        | 10000       | null        | ... | null        |\n+------+-------------+-------------+-------------+-----+-------------+\n\n注意，结果表有 13 列 (1个部门 id 列 + 12个月份的收入列)。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1180.统计只含单一字母的子串",
        "hardRate": "EASY",
        "passRate": "78.22%",
        "problemsUrl": "https://leetcode.cn/problems/count-substrings-with-only-one-distinct-letter/",
        "solutionsUrl": "https://leetcode.cn/problems/count-substrings-with-only-one-distinct-letter/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1181.前后拼接",
        "hardRate": "MEDIUM",
        "passRate": "39.81%",
        "problemsUrl": "https://leetcode.cn/problems/before-and-after-puzzle/",
        "solutionsUrl": "https://leetcode.cn/problems/before-and-after-puzzle/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1182.与目标颜色间的最短距离",
        "hardRate": "MEDIUM",
        "passRate": "47.75%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-distance-to-target-color/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-distance-to-target-color/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1183.矩阵中 1 的最大数量",
        "hardRate": "HARD",
        "passRate": "62.67%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-ones/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1184.公交站间的距离",
        "hardRate": "EASY",
        "passRate": "61.78%",
        "problemsUrl": "https://leetcode.cn/problems/distance-between-bus-stops/",
        "solutionsUrl": "https://leetcode.cn/problems/distance-between-bus-stops/solution",
        "problemsDesc": "<p>环形公交路线上有&nbsp;<code>n</code>&nbsp;个站，按次序从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;进行编号。我们已知每一对相邻公交站之间的距离，<code>distance[i]</code>&nbsp;表示编号为&nbsp;<code>i</code>&nbsp;的车站和编号为&nbsp;<code>(i + 1) % n</code>&nbsp;的车站之间的距离。</p>\n\n<p>环线上的公交车都可以按顺时针和逆时针的方向行驶。</p>\n\n<p>返回乘客从出发点&nbsp;<code>start</code>&nbsp;到目的地&nbsp;<code>destination</code>&nbsp;之间的最短距离。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1.jpg\" style=\"height: 240px; width: 388px;\"></p>\n\n<pre><strong>输入：</strong>distance = [1,2,3,4], start = 0, destination = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-1.jpg\" style=\"height: 240px; width: 388px;\"></p>\n\n<pre><strong>输入：</strong>distance = [1,2,3,4], start = 0, destination = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-2.jpg\" style=\"height: 240px; width: 388px;\"></p>\n\n<pre><strong>输入：</strong>distance = [1,2,3,4], start = 0, destination = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 10^4</code></li>\n\t<li><code>distance.length == n</code></li>\n\t<li><code>0 &lt;= start, destination &lt; n</code></li>\n\t<li><code>0 &lt;= distance[i] &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1185.一周中的第几天",
        "hardRate": "EASY",
        "passRate": "62.21%",
        "problemsUrl": "https://leetcode.cn/problems/day-of-the-week/",
        "solutionsUrl": "https://leetcode.cn/problems/day-of-the-week/solution",
        "problemsDesc": "<p>给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。</p>\n\n<p>输入为三个整数：<code>day</code>、<code>month</code> 和&nbsp;<code>year</code>，分别表示日、月、年。</p>\n\n<p>您返回的结果必须是这几个值中的一个&nbsp;<code>{&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;}</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>day = 31, month = 8, year = 2019\n<strong>输出：</strong>&quot;Saturday&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>day = 18, month = 7, year = 1999\n<strong>输出：</strong>&quot;Sunday&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>day = 15, month = 8, year = 1993\n<strong>输出：</strong>&quot;Sunday&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给出的日期一定是在&nbsp;<code>1971</code> 到&nbsp;<code>2100</code>&nbsp;年之间的有效日期。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1186.删除一次得到子数组最大和",
        "hardRate": "MEDIUM",
        "passRate": "48.06%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/solution",
        "problemsDesc": "<p>给你一个整数数组，返回它的某个&nbsp;<strong>非空</strong> 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。</p>\n\n<p>注意，删除一个元素后，子数组 <strong>不能为空</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,-2,0,3]\n<strong>输出：</strong>4\n<strong>解释：</strong>我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,-2,-2,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>我们直接选出 [3]，这就是最大和。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [-1,-1,-1,-1]\n<strong>输出：</strong>-1\n<strong>解释：</strong>最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。\n     我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1187.使数组严格递增",
        "hardRate": "HARD",
        "passRate": "59.82%",
        "problemsUrl": "https://leetcode.cn/problems/make-array-strictly-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/make-array-strictly-increasing/solution",
        "problemsDesc": "<p>给你两个整数数组&nbsp;<code>arr1</code> 和 <code>arr2</code>，返回使&nbsp;<code>arr1</code>&nbsp;严格递增所需要的最小「操作」数（可能为 0）。</p>\n\n<p>每一步「操作」中，你可以分别从 <code>arr1</code> 和 <code>arr2</code> 中各选出一个索引，分别为&nbsp;<code>i</code> 和&nbsp;<code>j</code>，<code>0 &lt;=&nbsp;i &lt; arr1.length</code>&nbsp;和&nbsp;<code>0 &lt;= j &lt; arr2.length</code>，然后进行赋值运算&nbsp;<code>arr1[i] = arr2[j]</code>。</p>\n\n<p>如果无法让&nbsp;<code>arr1</code>&nbsp;严格递增，请返回&nbsp;<code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]\n<strong>输出：</strong>1\n<strong>解释：</strong>用 2 来替换 <code>5，之后</code> <code>arr1 = [1, 2, 3, 6, 7]</code>。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [1,5,3,6,7], arr2 = [4,3,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>用 3 来替换 <code>5，然后</code>用 4 来替换 3<code>，得到</code> <code>arr1 = [1, 3, 4, 6, 7]</code>。\n</pre>\n\n<p><strong class=\"example\">示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法使 <code>arr1 严格递增</code>。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr1.length, arr2.length &lt;= 2000</code></li>\n\t<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 10^9</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1188.设计有限阻塞队列",
        "hardRate": "MEDIUM",
        "passRate": "70.37%",
        "problemsUrl": "https://leetcode.cn/problems/design-bounded-blocking-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/design-bounded-blocking-queue/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1189.“气球” 的最大数量",
        "hardRate": "EASY",
        "passRate": "68.27%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-balloons/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-balloons/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>text</code>，你需要使用 <code>text</code> 中的字母来拼凑尽可能多的单词&nbsp;<strong>&quot;balloon&quot;（气球）</strong>。</p>\n\n<p>字符串&nbsp;<code>text</code> 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词&nbsp;<strong>&quot;balloon&quot;</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/14/1536_ex1_upd.jpeg\" style=\"height: 35px; width: 154px;\"></strong></p>\n\n<pre><strong>输入：</strong>text = &quot;nlaebolko&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/14/1536_ex2_upd.jpeg\" style=\"height: 35px; width: 233px;\"></strong></p>\n\n<pre><strong>输入：</strong>text = &quot;loonbalxballpoon&quot;\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;leetcode&quot;\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 10^4</code></li>\n\t<li><code>text</code>&nbsp;全部由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1190.反转每对括号间的子串",
        "hardRate": "MEDIUM",
        "passRate": "64.75%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses/solution",
        "problemsDesc": "<p>给出一个字符串&nbsp;<code>s</code>（仅含有小写英文字母和括号）。</p>\n\n<p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p>\n\n<p>注意，您的结果中 <strong>不应</strong> 包含任何括号。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(abcd)\"\n<strong>输出：</strong>\"dcba\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(u(love)i)\"\n<strong>输出：</strong>\"iloveu\"\n<strong>解释：</strong>先反转子字符串 \"love\" ，然后反转整个字符串。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(ed(et(oc))el)\"\n<strong>输出：</strong>\"leetcode\"\n<strong>解释：</strong>先反转子字符串 \"oc\" ，接着反转 \"etco\" ，然后反转整个字符串。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a(bcdefghijkl(mno)p)q\"\n<strong>输出：</strong>\"apmnolkjihgfedcbq\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> 中只有小写英文字母和括号</li>\n\t<li>题目测试用例确保所有括号都是成对出现的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1191.K 次串联后最大子数组之和",
        "hardRate": "MEDIUM",
        "passRate": "27.03%",
        "problemsUrl": "https://leetcode.cn/problems/k-concatenation-maximum-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/k-concatenation-maximum-sum/solution",
        "problemsDesc": "<p>给定一个整数数组&nbsp;<code>arr</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，通过重复&nbsp;<code>k</code>&nbsp;次来修改数组。</p>\n\n<p>例如，如果&nbsp;<code>arr = [1, 2]</code>&nbsp;，<meta charset=\"UTF-8\" />&nbsp;<code>k = 3</code>&nbsp;，那么修改后的数组将是 <code>[1, 2, 1, 2, 1, 2]</code> 。</p>\n\n<p>返回修改后的数组中的最大的子数组之和。注意，子数组长度可以是 <code>0</code>，在这种情况下它的总和也是 <code>0</code>。</p>\n\n<p>由于&nbsp;<strong>结果可能会很大</strong>，需要返回的<meta charset=\"UTF-8\" />&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code>&nbsp;的&nbsp;<strong>模</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2], k = 3\n<strong>输出：</strong>9\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,-2,1], k = 5\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [-1,-2], k = 7\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1192.查找集群内的关键连接",
        "hardRate": "HARD",
        "passRate": "54.48%",
        "problemsUrl": "https://leetcode.cn/problems/critical-connections-in-a-network/",
        "solutionsUrl": "https://leetcode.cn/problems/critical-connections-in-a-network/solution",
        "problemsDesc": "<p>力扣数据中心有&nbsp;<code>n</code>&nbsp;台服务器，分别按从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n-1</code>&nbsp;的方式进行了编号。它们之间以 <strong>服务器到服务器</strong> 的形式相互连接组成了一个内部集群，连接是无向的。用 &nbsp;<code>connections</code> 表示集群网络，<code>connections[i] = [a, b]</code>&nbsp;表示服务器 <code>a</code>&nbsp;和 <code>b</code>&nbsp;之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。</p>\n\n<p><strong>关键连接</strong><em> </em>是在该集群中的重要连接，假如我们将它移除，便会导致某些服务器无法访问其他服务器。</p>\n\n<p>请你以任意顺序返回该集群内的所有 <strong>关键连接</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/critical-connections-in-a-network.png\" style=\"height: 205px; width: 200px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]\n<strong>输出：</strong>[[1,3]]\n<strong>解释：</strong>[[3,1]] 也是正确的。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>n = 2, connections = [[0,1]]\n<b>输出：</b>[[0,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>n - 1 &lt;= connections.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>不存在重复的连接</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1193.每月交易 I",
        "hardRate": "MEDIUM",
        "passRate": "60.88%",
        "problemsUrl": "https://leetcode.cn/problems/monthly-transactions-i/",
        "solutionsUrl": "https://leetcode.cn/problems/monthly-transactions-i/solution",
        "problemsDesc": "<p>Table: <code>Transactions</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| country       | varchar |\n| state         | enum    |\n| amount        | int     |\n| trans_date    | date    |\n+---------------+---------+\nid 是这个表的主键。\n该表包含有关传入事务的信息。\nstate 列类型为 “[”批准“，”拒绝“] 之一。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 sql 查询来查找每个月和每个国家/地区的事务数及其总金额、已批准的事务数及其总金额。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<code><strong>输入：</strong>\nTransactions</code> table:\n+------+---------+----------+--------+------------+\n| id   | country | state    | amount | trans_date |\n+------+---------+----------+--------+------------+\n| 121  | US      | approved | 1000   | 2018-12-18 |\n| 122  | US      | declined | 2000   | 2018-12-19 |\n| 123  | US      | approved | 2000   | 2019-01-01 |\n| 124  | DE      | approved | 2000   | 2019-01-07 |\n+------+---------+----------+--------+------------+\n<strong>输出：</strong>\n+----------+---------+-------------+----------------+--------------------+-----------------------+\n| month    | country | trans_count | approved_count | trans_total_amount | approved_total_amount |\n+----------+---------+-------------+----------------+--------------------+-----------------------+\n| 2018-12  | US      | 2           | 1              | 3000               | 1000                  |\n| 2019-01  | US      | 1           | 1              | 2000               | 2000                  |\n| 2019-01  | DE      | 1           | 1              | 2000               | 2000                  |\n+----------+---------+-------------+----------------+--------------------+-----------------------+</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1194.锦标赛优胜者",
        "hardRate": "HARD",
        "passRate": "51.09%",
        "problemsUrl": "https://leetcode.cn/problems/tournament-winners/",
        "solutionsUrl": "https://leetcode.cn/problems/tournament-winners/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1195.交替打印字符串",
        "hardRate": "MEDIUM",
        "passRate": "64.96%",
        "problemsUrl": "https://leetcode.cn/problems/fizz-buzz-multithreaded/",
        "solutionsUrl": "https://leetcode.cn/problems/fizz-buzz-multithreaded/solution",
        "problemsDesc": "<p>编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是：</p>\n\n<ul>\n\t<li>如果这个数字可以被 3 整除，输出 \"fizz\"。</li>\n\t<li>如果这个数字可以被 5 整除，输出 \"buzz\"。</li>\n\t<li>如果这个数字可以同时被 3 和 5 整除，输出 \"fizzbuzz\"。</li>\n</ul>\n\n<p>例如，当 <code>n = 15</code>，输出： <code>1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz</code>。</p>\n\n<p>假设有这么一个类：</p>\n\n<pre>\nclass FizzBuzz {\n  public FizzBuzz(int n) { ... }               // constructor\n  public void fizz(printFizz) { ... }          // only output \"fizz\"\n  public void buzz(printBuzz) { ... }          // only output \"buzz\"\n  public void fizzbuzz(printFizzBuzz) { ... }  // only output \"fizzbuzz\"\n  public void number(printNumber) { ... }      // only output the numbers\n}</pre>\n\n<p>请你实现一个有四个线程的多线程版  <code>FizzBuzz</code>， 同一个 <code>FizzBuzz</code> 实例会被如下四个线程使用：</p>\n\n<ol>\n\t<li>线程A将调用 <code>fizz()</code> 来判断是否能被 3 整除，如果可以，则输出 <code>fizz</code>。</li>\n\t<li>线程B将调用 <code>buzz()</code> 来判断是否能被 5 整除，如果可以，则输出 <code>buzz</code>。</li>\n\t<li>线程C将调用 <code>fizzbuzz()</code> 来判断是否同时能被 3 和 5 整除，如果可以，则输出 <code>fizzbuzz</code>。</li>\n\t<li>线程D将调用 <code>number()</code> 来实现输出既不能被 3 整除也不能被 5 整除的数字。</li>\n</ol>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>本题已经提供了打印字符串的相关方法，如 <code>printFizz()</code> 等，具体方法名请参考答题模板中的注释部分。</li>\n</ul>\n\n<p> </p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1196.最多可以买到的苹果数量",
        "hardRate": "EASY",
        "passRate": "68.24%",
        "problemsUrl": "https://leetcode.cn/problems/how-many-apples-can-you-put-into-the-basket/",
        "solutionsUrl": "https://leetcode.cn/problems/how-many-apples-can-you-put-into-the-basket/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1197.进击的骑士",
        "hardRate": "MEDIUM",
        "passRate": "39.21%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-knight-moves/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-knight-moves/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1198.找出所有行中最小公共元素",
        "hardRate": "MEDIUM",
        "passRate": "74.07%",
        "problemsUrl": "https://leetcode.cn/problems/find-smallest-common-element-in-all-rows/",
        "solutionsUrl": "https://leetcode.cn/problems/find-smallest-common-element-in-all-rows/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1199.建造街区的最短时间",
        "hardRate": "HARD",
        "passRate": "47.25%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-build-blocks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-build-blocks/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1200.最小绝对差",
        "hardRate": "EASY",
        "passRate": "72.45%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-absolute-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-absolute-difference/solution",
        "problemsDesc": "<p>给你个整数数组&nbsp;<code>arr</code>，其中每个元素都 <strong>不相同</strong>。</p>\n\n<p>请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。</p>\n\n<p>每对元素对 <code>[a,b</code>] 如下：</p>\n\n<ul>\n\t<li><code>a ,&nbsp;b</code>&nbsp;均为数组&nbsp;<code>arr</code>&nbsp;中的元素</li>\n\t<li><code>a &lt; b</code></li>\n\t<li><code>b - a</code>&nbsp;等于 <code>arr</code> 中任意两个元素的最小绝对差</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [4,2,1,3]\n<strong>输出：</strong>[[1,2],[2,3],[3,4]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,3,6,10,15]\n<strong>输出：</strong>[[1,3]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,8,-10,23,19,-4,-14,27]\n<strong>输出：</strong>[[-14,-10],[19,23],[23,27]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>-10^6 &lt;= arr[i] &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    }
]