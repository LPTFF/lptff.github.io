[
    {
        "problemsName": " 2101.引爆最多的炸弹",
        "hardRate": "MEDIUM",
        "passRate": "39.72%",
        "problemsUrl": "https://leetcode.cn/problems/detonate-the-maximum-bombs/",
        "solutionsUrl": "https://leetcode.cn/problems/detonate-the-maximum-bombs/solution",
        "problemsDesc": "<p>给你一个炸弹列表。一个炸弹的 <strong>爆炸范围</strong>&nbsp;定义为以炸弹为圆心的一个圆。</p>\n\n<p>炸弹用一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>bombs</code>&nbsp;表示，其中&nbsp;<code>bombs[i] = [x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub>]</code>&nbsp;。<code>x<sub>i</sub></code> 和&nbsp;<code>y<sub>i</sub></code>&nbsp;表示第 <code>i</code>&nbsp;个炸弹的 X 和 Y 坐标，<code>r<sub>i</sub></code>&nbsp;表示爆炸范围的 <strong>半径</strong>&nbsp;。</p>\n\n<p>你需要选择引爆 <strong>一个&nbsp;</strong>炸弹。当这个炸弹被引爆时，<strong>所有</strong> 在它爆炸范围内的炸弹都会被引爆，这些炸弹会进一步将它们爆炸范围内的其他炸弹引爆。</p>\n\n<p>给你数组&nbsp;<code>bombs</code>&nbsp;，请你返回在引爆&nbsp;<strong>一个</strong>&nbsp;炸弹的前提下，<strong>最多</strong>&nbsp;能引爆的炸弹数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-3.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<pre><b>输入：</b>bombs = [[2,1,3],[6,1,4]]\n<b>输出：</b>2\n<strong>解释：</strong>\n上图展示了 2 个炸弹的位置和爆炸范围。\n如果我们引爆左边的炸弹，右边的炸弹不会被影响。\n但如果我们引爆右边的炸弹，两个炸弹都会爆炸。\n所以最多能引爆的炸弹数目是 max(1, 2) = 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-2.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<pre><b>输入：</b>bombs = [[1,1,5],[10,10,5]]\n<b>输出：</b>1\n<strong>解释：\n</strong>引爆任意一个炸弹都不会引爆另一个炸弹。所以最多能引爆的炸弹数目为 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/desmos-eg1.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<pre><b>输入：</b>bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\n<b>输出：</b>5\n<strong>解释：</strong>\n最佳引爆炸弹为炸弹 0 ，因为：\n- 炸弹 0 引爆炸弹 1 和 2 。红色圆表示炸弹 0 的爆炸范围。\n- 炸弹 2 引爆炸弹 3 。蓝色圆表示炸弹 2 的爆炸范围。\n- 炸弹 3 引爆炸弹 4 。绿色圆表示炸弹 3 的爆炸范围。\n所以总共有 5 个炸弹被引爆。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bombs.length&nbsp;&lt;= 100</code></li>\n\t<li><code>bombs[i].length == 3</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2102.序列顺序查询",
        "hardRate": "HARD",
        "passRate": "55.87%",
        "problemsUrl": "https://leetcode.cn/problems/sequentially-ordinal-rank-tracker/",
        "solutionsUrl": "https://leetcode.cn/problems/sequentially-ordinal-rank-tracker/solution",
        "problemsDesc": "<p>一个观光景点由它的名字&nbsp;<code>name</code> 和景点评分&nbsp;<code>score</code>&nbsp;组成，其中&nbsp;<code>name</code>&nbsp;是所有观光景点中&nbsp;<strong>唯一</strong>&nbsp;的字符串，<code>score</code>&nbsp;是一个整数。景点按照最好到最坏排序。景点评分 <strong>越高</strong>&nbsp;，这个景点越好。如果有两个景点的评分一样，那么 <strong>字典序较小</strong>&nbsp;的景点更好。</p>\n\n<p>你需要搭建一个系统，查询景点的排名。初始时系统里没有任何景点。这个系统支持：</p>\n\n<ul>\n\t<li><strong>添加</strong> 景点，每次添加 <strong>一个</strong> 景点。</li>\n\t<li><strong>查询 </strong>已经添加景点中第&nbsp;<code>i</code>&nbsp;<strong>好</strong>&nbsp;的景点，其中&nbsp;<code>i</code>&nbsp;是系统目前位置查询的次数（包括当前这一次）。\n\t<ul>\n\t\t<li>比方说，如果系统正在进行第 <code>4</code>&nbsp;次查询，那么需要返回所有已经添加景点中第 <code>4</code>&nbsp;好的。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>注意，测试数据保证&nbsp;<strong>任意查询时刻</strong>&nbsp;，查询次数都 <strong>不超过</strong>&nbsp;系统中景点的数目。</p>\n\n<p>请你实现&nbsp;<code>SORTracker</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>SORTracker()</code>&nbsp;初始化系统。</li>\n\t<li><code>void add(string name, int score)</code>&nbsp;向系统中添加一个名为&nbsp;<code>name</code> 评分为&nbsp;<code>score</code>&nbsp;的景点。</li>\n\t<li><code>string get()</code>&nbsp;查询第 <code>i</code>&nbsp;好的景点，其中 <code>i</code>&nbsp;是目前系统查询的次数（包括当前这次查询）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"SORTracker\", \"add\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"get\"]\n[[], [\"bradford\", 2], [\"branford\", 3], [], [\"alps\", 2], [], [\"orland\", 2], [], [\"orlando\", 3], [], [\"alpine\", 2], [], []]\n<strong>输出：</strong>\n[null, null, null, \"branford\", null, \"alps\", null, \"bradford\", null, \"bradford\", null, \"bradford\", \"orland\"]\n\n<strong>解释：</strong>\nSORTracker tracker = new SORTracker(); // 初始化系统\ntracker.add(\"bradford\", 2); // 添加 name=\"bradford\" 且 score=2 的景点。\ntracker.add(\"branford\", 3); // 添加 name=\"branford\" 且 score=3 的景点。\ntracker.get();              // 从好带坏的景点为：branford ，bradford 。\n                            // 注意到 branford 比 bradford 好，因为它的 <strong>评分更高</strong> (3 &gt; 2) 。\n                            // 这是第 1 次调用 get() ，所以返回最好的景点：\"branford\" 。\ntracker.add(\"alps\", 2);     // 添加 name=\"alps\" 且 score=2 的景点。\ntracker.get();              // 从好到坏的景点为：branford, alps, bradford 。\n                            // 注意 alps 比 bradford 好，虽然它们评分相同，都为 2 。\n                            // 这是因为 \"alps\" <strong>字典序</strong>&nbsp;比 \"bradford\" 小。\n                            // 返回第 2 好的地点 \"alps\" ，因为当前为第 2 次调用 get() 。\ntracker.add(\"orland\", 2);   // 添加 name=\"orland\" 且 score=2 的景点。\ntracker.get();              // 从好到坏的景点为：branford, alps, bradford, orland 。\n                            // 返回 \"bradford\" ，因为当前为第 3 次调用 get() 。\ntracker.add(\"orlando\", 3);  // 添加 name=\"orlando\" 且 score=3 的景点。\ntracker.get();              // 从好到坏的景点为：branford, orlando, alps, bradford, orland 。\n                            // 返回 \"bradford\".\ntracker.add(\"alpine\", 2);   // 添加 name=\"alpine\" 且 score=2 的景点。\ntracker.get();              // 从好到坏的景点为：branford, orlando, alpine, alps, bradford, orland 。\n                            // 返回 \"bradford\" 。\ntracker.get();              // 从好到坏的景点为：branford, orlando, alpine, alps, bradford, orland 。\n                            // 返回 \"orland\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>name</code>&nbsp;只包含小写英文字母，且每个景点名字互不相同。</li>\n\t<li><code>1 &lt;= name.length &lt;= 10</code></li>\n\t<li><code>1 &lt;= score &lt;= 10<sup>5</sup></code></li>\n\t<li>任意时刻，调用&nbsp;<code>get</code>&nbsp;的次数都不超过调用&nbsp;<code>add</code>&nbsp;的次数。</li>\n\t<li><strong>总共</strong>&nbsp;调用&nbsp;<code>add</code> 和&nbsp;<code>get</code>&nbsp;不超过&nbsp;<code>4 * 10<sup>4</sup></code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2103.环和杆",
        "hardRate": "EASY",
        "passRate": "79.62%",
        "problemsUrl": "https://leetcode.cn/problems/rings-and-rods/",
        "solutionsUrl": "https://leetcode.cn/problems/rings-and-rods/solution",
        "problemsDesc": "<p>总计有 <code>n</code> 个环，环的颜色可以是红、绿、蓝中的一种。这些环分布穿在 10 根编号为 <code>0</code> 到 <code>9</code> 的杆上。</p>\n\n<p>给你一个长度为 <code>2n</code> 的字符串 <code>rings</code> ，表示这 <code>n</code> 个环在杆上的分布。<code>rings</code> 中每两个字符形成一个 <strong>颜色位置对</strong> ，用于描述每个环：</p>\n\n<ul>\n\t<li>第 <code>i</code> 对中的 <strong>第一个</strong> 字符表示第 <code>i</code> 个环的 <strong>颜色</strong>（<code>'R'</code>、<code>'G'</code>、<code>'B'</code>）。</li>\n\t<li>第 <code>i</code> 对中的 <strong>第二个</strong> 字符表示第 <code>i</code> 个环的 <strong>位置</strong>，也就是位于哪根杆上（<code>'0'</code> 到 <code>'9'</code>）。</li>\n</ul>\n\n<p>例如，<code>\"R3G2B1\"</code> 表示：共有 <code>n == 3</code> 个环，红色的环在编号为 3 的杆上，绿色的环在编号为 2 的杆上，蓝色的环在编号为 1 的杆上。</p>\n\n<p>找出所有集齐 <strong>全部三种颜色</strong> 环的杆，并返回这种杆的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/23/ex1final.png\" style=\"width: 258px; height: 130px;\">\n<pre><strong>输入：</strong>rings = \"B0B6G0R6R0R6G9\"\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 编号 0 的杆上有 3 个环，集齐全部颜色：红、绿、蓝。\n- 编号 6 的杆上有 3 个环，但只有红、蓝两种颜色。\n- 编号 9 的杆上只有 1 个绿色环。\n因此，集齐全部三种颜色环的杆的数目为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/23/ex2final.png\" style=\"width: 266px; height: 130px;\">\n<pre><strong>输入：</strong>rings = \"B0R0G0R9R0B0G0\"\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 编号 0 的杆上有 6 个环，集齐全部颜色：红、绿、蓝。\n- 编号 9 的杆上只有 1 个红色环。\n因此，集齐全部三种颜色环的杆的数目为 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>rings = \"G4\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\n只给了一个环，因此，不存在集齐全部三种颜色环的杆。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rings.length == 2 * n</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li>如 <code>i</code> 是 <strong>偶数</strong> ，则&nbsp;<code>rings[i]</code> 的值可以取 <code>'R'</code>、<code>'G'</code> 或 <code>'B'</code>（下标从 <strong>0</strong> 开始计数）</li>\n\t<li>如 <code>i</code> 是 <strong>奇数</strong> ，则&nbsp;<code>rings[i]</code> 的值可以取 <code>'0'</code> 到 <code>'9'</code> 中的一个数字（下标从 <strong>0</strong> 开始计数）</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2104.子数组范围和",
        "hardRate": "MEDIUM",
        "passRate": "62.90%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-subarray-ranges/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-subarray-ranges/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。<code>nums</code> 中，子数组的 <strong>范围</strong> 是子数组中最大元素和最小元素的差值。</p>\n\n<p>返回 <code>nums</code> 中 <strong>所有</strong> 子数组范围的 <strong>和</strong> <em>。</em></p>\n\n<p>子数组是数组中一个连续 <strong>非空</strong> 的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>4\n<strong>解释：</strong>nums 的 6 个子数组如下所示：\n[1]，范围 = 最大 - 最小 = 1 - 1 = 0 \n[2]，范围 = 2 - 2 = 0\n[3]，范围 = 3 - 3 = 0\n[1,2]，范围 = 2 - 1 = 1\n[2,3]，范围 = 3 - 2 = 1\n[1,2,3]，范围 = 3 - 1 = 2\n所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,3]\n<strong>输出：</strong>4\n<strong>解释：</strong>nums 的 6 个子数组如下所示：\n[1]，范围 = 最大 - 最小 = 1 - 1 = 0\n[3]，范围 = 3 - 3 = 0\n[3]，范围 = 3 - 3 = 0\n[1,3]，范围 = 3 - 1 = 2\n[3,3]，范围 = 3 - 3 = 0\n[1,3,3]，范围 = 3 - 1 = 2\n所有范围的和是 0 + 0 + 0 + 2 + 0 + 2 = 4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,-2,-3,4,1]\n<strong>输出：</strong>59\n<strong>解释：</strong>nums 中所有子数组范围的和是 59\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计一种时间复杂度为 <code>O(n)</code> 的解决方案吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2105.给植物浇水 II",
        "hardRate": "MEDIUM",
        "passRate": "53.02%",
        "problemsUrl": "https://leetcode.cn/problems/watering-plants-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/watering-plants-ii/solution",
        "problemsDesc": "<p>Alice 和 Bob 打算给花园里的 <code>n</code> 株植物浇水。植物排成一行，从左到右进行标记，编号从 <code>0</code> 到 <code>n - 1</code> 。其中，第 <code>i</code> 株植物的位置是 <code>x = i</code> 。</p>\n\n<p>每一株植物都需要浇特定量的水。Alice 和 Bob 每人有一个水罐，<strong>最初是满的 </strong>。他们按下面描述的方式完成浇水：</p>\n\n<ul>\n\t<li>&nbsp;Alice 按 <strong>从左到右</strong> 的顺序给植物浇水，从植物 <code>0</code> 开始。Bob 按 <strong>从右到左</strong> 的顺序给植物浇水，从植物 <code>n - 1</code> 开始。他们 <strong>同时</strong> 给植物浇水。</li>\n\t<li>如果没有足够的水 <strong>完全</strong> 浇灌下一株植物，他 / 她会立即重新灌满浇水罐。</li>\n\t<li>不管植物需要多少水，浇水所耗费的时间都是一样的。</li>\n\t<li><strong>不能</strong> 提前重新灌满水罐。</li>\n\t<li>每株植物都可以由 Alice 或者 Bob 来浇水。</li>\n\t<li>如果 Alice 和 Bob 到达同一株植物，那么当前水罐中水更多的人会给这株植物浇水。如果他俩水量相同，那么 Alice 会给这株植物浇水。</li>\n</ul>\n\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>plants</code> ，数组由 <code>n</code> 个整数组成。其中，<code>plants[i]</code> 为第 <code>i</code> 株植物需要的水量。另有两个整数 <code>capacityA</code> 和&nbsp;<code>capacityB</code> 分别表示 Alice 和 Bob 水罐的容量。返回两人浇灌所有植物过程中重新灌满水罐的 <strong>次数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [2,2,3,3], capacityA = 5, capacityB = 5\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 最初，Alice 和 Bob 的水罐中各有 5 单元水。\n- Alice 给植物 0 浇水，Bob 给植物 3 浇水。\n- Alice 和 Bob 现在分别剩下 3 单元和 2 单元水。\n- Alice 有足够的水给植物 1 ，所以她直接浇水。Bob 的水不够给植物 2 ，所以他先重新装满水，再浇水。\n所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 0 + 1 + 0 = 1 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [2,2,3,3], capacityA = 3, capacityB = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- 最初，Alice 的水罐中有 3 单元水，Bob 的水罐中有 4 单元水。\n- Alice 给植物 0 浇水，Bob 给植物 3 浇水。\n- Alice 和 Bob 现在都只有 1 单元水，并分别需要给植物 1 和植物 2 浇水。\n- 由于他们的水量均不足以浇水，所以他们重新灌满水罐再进行浇水。\n所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 1 + 1 + 0 = 2 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [5], capacityA = 10, capacityB = 8\n<strong>输出：</strong>0\n<strong>解释：</strong>\n- 只有一株植物\n- Alice 的水罐有 10 单元水，Bob 的水罐有 8 单元水。因此 Alice 的水罐中水更多，她会给这株植物浇水。\n所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == plants.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= plants[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>max(plants[i]) &lt;= capacityA, capacityB &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2106.摘水果",
        "hardRate": "HARD",
        "passRate": "45.09%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/solution",
        "problemsDesc": "<p>在一个无限的 x 坐标轴上，有许多水果分布在其中某些位置。给你一个二维整数数组 <code>fruits</code> ，其中 <code>fruits[i] = [position<sub>i</sub>, amount<sub>i</sub>]</code> 表示共有 <code>amount<sub>i</sub></code> 个水果放置在 <code>position<sub>i</sub></code> 上。<code>fruits</code> 已经按 <code>position<sub>i</sub></code> <strong>升序排列</strong> ，每个 <code>position<sub>i</sub></code> <strong>互不相同</strong> 。</p>\n\n<p>另给你两个整数 <code>startPos</code> 和 <code>k</code> 。最初，你位于 <code>startPos</code> 。从任何位置，你可以选择 <strong>向左或者向右</strong> 走。在 x 轴上每移动 <strong>一个单位</strong> ，就记作 <strong>一步</strong> 。你总共可以走 <strong>最多</strong> <code>k</code> 步。你每达到一个位置，都会摘掉全部的水果，水果也将从该位置消失（不会再生）。</p>\n\n<p>返回你可以摘到水果的 <strong>最大总数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/21/1.png\" style=\"width: 472px; height: 115px;\">\n<pre><strong>输入：</strong>fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4\n<strong>输出：</strong>9\n<strong>解释：</strong>\n最佳路线为：\n- 向右移动到位置 6 ，摘到 3 个水果\n- 向右移动到位置 8 ，摘到 6 个水果\n移动 3 步，共摘到 3 + 6 = 9 个水果\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/21/2.png\" style=\"width: 512px; height: 129px;\">\n<pre><strong>输入：</strong>fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4\n<strong>输出：</strong>14\n<strong>解释：</strong>\n可以移动最多 k = 4 步，所以无法到达位置 0 和位置 10 。\n最佳路线为：\n- 在初始位置 5 ，摘到 7 个水果\n- 向左移动到位置 4 ，摘到 1 个水果\n- 向右移动到位置 6 ，摘到 2 个水果\n- 向右移动到位置 7 ，摘到 4 个水果\n移动 1 + 3 = 4 步，共摘到 7 + 1 + 2 + 4 = 14 个水果\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/21/3.png\" style=\"width: 476px; height: 100px;\">\n<pre><strong>输入：</strong>fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2\n<strong>输出：</strong>0\n<strong>解释：</strong>\n最多可以移动 k = 2 步，无法到达任一有水果的地方\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= fruits.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>fruits[i].length == 2</code></li>\n\t<li><code>0 &lt;= startPos, position<sub>i</sub> &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li>对于任意 <code>i &gt; 0</code> ，<code>position<sub>i-1</sub> &lt; position<sub>i</sub></code> 均成立（下标从 <strong>0</strong> 开始计数）</li>\n\t<li><code>1 &lt;= amount<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2107.分享 K 个糖果后独特口味的数量",
        "hardRate": "MEDIUM",
        "passRate": "38.88%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-unique-flavors-after-sharing-k-candies/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-unique-flavors-after-sharing-k-candies/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2108.找出数组中的第一个回文字符串",
        "hardRate": "EASY",
        "passRate": "77.53%",
        "problemsUrl": "https://leetcode.cn/problems/find-first-palindromic-string-in-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-first-palindromic-string-in-the-array/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code> ，找出并返回数组中的 <strong>第一个回文字符串</strong> 。如果不存在满足要求的字符串，返回一个 <strong>空字符串</strong><em> </em><code>\"\"</code> 。</p>\n\n<p><strong>回文字符串</strong> 的定义为：如果一个字符串正着读和反着读一样，那么该字符串就是一个 <strong>回文字符串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\n<strong>输出：</strong>\"ada\"\n<strong>解释：</strong>第一个回文字符串是 \"ada\" 。\n注意，\"racecar\" 也是回文字符串，但它不是第一个。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"notapalindrome\",\"racecar\"]\n<strong>输出：</strong>\"racecar\"\n<strong>解释：</strong>第一个也是唯一一个回文字符串是 \"racecar\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"def\",\"ghi\"]\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>不存在回文字符串，所以返回一个空字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2109.向字符串添加空格",
        "hardRate": "MEDIUM",
        "passRate": "61.51%",
        "problemsUrl": "https://leetcode.cn/problems/adding-spaces-to-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/adding-spaces-to-a-string/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，以及一个下标从 <strong>0</strong> 开始的整数数组 <code>spaces</code> 。</p>\n\n<p>数组 <code>spaces</code> 描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值 <strong>之前</strong> 。</p>\n\n<ul>\n\t<li>例如，<code>s = \"EnjoyYourCoffee\"</code> 且 <code>spaces = [5, 9]</code> ，那么我们需要在 <code>'Y'</code> 和 <code>'C'</code> 之前添加空格，这两个字符分别位于下标 <code>5</code> 和下标 <code>9</code> 。因此，最终得到 <code>\"Enjoy <em><strong>Y</strong></em>our <em><strong>C</strong></em>offee\"</code> 。</li>\n</ul>\n\n<p>请你添加空格，并返回修改后的字符串<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"LeetcodeHelpsMeLearn\", spaces = [8,13,15]\n<strong>输出：</strong>\"Leetcode Helps Me Learn\"\n<strong>解释：</strong>\n下标 8、13 和 15 对应 \"Leetcode<em><strong>H</strong></em>elps<em><strong>M</strong></em>e<em><strong>L</strong></em>earn\" 中加粗斜体字符。\n接着在这些字符前添加空格。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"icodeinpython\", spaces = [1,5,7,9]\n<strong>输出：</strong>\"i code in py thon\"\n<strong>解释：</strong>\n下标 1、5、7 和 9 对应 \"i<em><strong>c</strong></em>ode<em><strong>i</strong></em>n<em><strong>p</strong></em>y<em><strong>t</strong></em>hon\" 中加粗斜体字符。\n接着在这些字符前添加空格。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"spacing\", spaces = [0,1,2,3,4,5,6]\n<strong>输出：</strong>\" s p a c i n g\"\n<strong>解释：</strong>\n字符串的第一个字符前可以添加空格。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅由大小写英文字母组成</li>\n\t<li><code>1 &lt;= spaces.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= spaces[i] &lt;= s.length - 1</code></li>\n\t<li><code>spaces</code> 中的所有值 <strong>严格递增</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2110.股票平滑下跌阶段的数目",
        "hardRate": "MEDIUM",
        "passRate": "52.81%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-smooth-descent-periods-of-a-stock/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-smooth-descent-periods-of-a-stock/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>prices</code>&nbsp;，表示一支股票的历史每日股价，其中&nbsp;<code>prices[i]</code>&nbsp;是这支股票第&nbsp;<code>i</code>&nbsp;天的价格。</p>\n\n<p>一个 <strong>平滑下降的阶段</strong>&nbsp;定义为：对于&nbsp;<strong>连续一天或者多天</strong>&nbsp;，每日股价都比 <strong>前一日股价恰好少 </strong><code>1</code>&nbsp;，这个阶段第一天的股价没有限制。</p>\n\n<p>请你返回 <strong>平滑下降阶段</strong>&nbsp;的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>prices = [3,2,1,4]\n<b>输出：</b>7\n<b>解释：</b>总共有 7 个平滑下降阶段：\n[3], [2], [1], [4], [3,2], [2,1] 和 [3,2,1]\n注意，仅一天按照定义也是平滑下降阶段。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>prices = [8,6,7,7]\n<b>输出：</b>4\n<b>解释：</b>总共有 4 个连续平滑下降阶段：[8], [6], [7] 和 [7]\n由于 8 - 6 ≠ 1 ，所以 [8,6] 不是平滑下降阶段。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>prices = [1]\n<b>输出：</b>1\n<b>解释：</b>总共有 1 个平滑下降阶段：[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= prices[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2111.使数组 K 递增的最少操作次数",
        "hardRate": "HARD",
        "passRate": "34.99%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始包含 <code>n</code>&nbsp;个正整数的数组&nbsp;<code>arr</code>&nbsp;，和一个正整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>如果对于每个满足&nbsp;<code>k &lt;= i &lt;= n-1</code>&nbsp;的下标&nbsp;<code>i</code>&nbsp;，都有&nbsp;<code>arr[i-k] &lt;= arr[i]</code>&nbsp;，那么我们称&nbsp;<code>arr</code>&nbsp;是 <strong>K</strong>&nbsp;<strong>递增</strong> 的。</p>\n\n<ul>\n\t<li>比方说，<code>arr = [4, 1, 5, 2, 6, 2]</code>&nbsp;对于&nbsp;<code>k = 2</code>&nbsp;是 K 递增的，因为：\n\n\t<ul>\n\t\t<li><code>arr[0] &lt;= arr[2] (4 &lt;= 5)</code></li>\n\t\t<li><code>arr[1] &lt;= arr[3] (1 &lt;= 2)</code></li>\n\t\t<li><code>arr[2] &lt;= arr[4] (5 &lt;= 6)</code></li>\n\t\t<li><code>arr[3] &lt;= arr[5] (2 &lt;= 2)</code></li>\n\t</ul>\n\t</li>\n\t<li>但是，相同的数组&nbsp;<code>arr</code>&nbsp;对于&nbsp;<code>k = 1</code>&nbsp;不是 K 递增的（因为&nbsp;<code>arr[0] &gt; arr[1]</code>），对于&nbsp;<code>k = 3</code>&nbsp;也不是 K 递增的（因为&nbsp;<code>arr[0] &gt; arr[3]</code>&nbsp;）。</li>\n</ul>\n\n<p>每一次 <strong>操作</strong>&nbsp;中，你可以选择一个下标&nbsp;<code>i</code> 并将&nbsp;<code>arr[i]</code> <strong>改成任意&nbsp;</strong>正整数。</p>\n\n<p>请你返回对于给定的 <code>k</code>&nbsp;，使数组变成 K 递增的 <strong>最少操作次数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>arr = [5,4,3,2,1], k = 1\n<b>输出：</b>4\n<strong>解释：\n</strong>对于 k = 1 ，数组最终必须变成非递减的。\n可行的 K 递增结果数组为 [5,<em><strong>6</strong></em>,<em><strong>7</strong></em>,<em><strong>8</strong></em>,<em><strong>9</strong></em>]，[<em><strong>1</strong></em>,<em><strong>1</strong></em>,<em><strong>1</strong></em>,<em><strong>1</strong></em>,1]，[<em><strong>2</strong></em>,<em><strong>2</strong></em>,3,<em><strong>4</strong></em>,<em><strong>4</strong></em>] 。它们都需要 4 次操作。\n次优解是将数组变成比方说 [<em><strong>6</strong></em>,<em><strong>7</strong></em>,<em><strong>8</strong></em>,<em><strong>9</strong></em>,<em><strong>10</strong></em>] ，因为需要 5 次操作。\n显然我们无法使用少于 4 次操作将数组变成 K 递增的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>arr = [4,1,5,2,6,2], k = 2\n<b>输出：</b>0\n<strong>解释：</strong>\n这是题目描述中的例子。\n对于每个满足 2 &lt;= i &lt;= 5 的下标 i ，有 arr[i-2] &lt;=<b> </b>arr[i] 。\n由于给定数组已经是 K 递增的，我们不需要进行任何操作。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,1,5,2,6,2], k = 3\n<b>输出：</b>2\n<strong>解释：</strong>\n下标 3 和 5 是仅有的 3 &lt;= i &lt;= 5 且不满足 arr[i-3] &lt;= arr[i] 的下标。\n将数组变成 K 递增的方法之一是将 arr[3] 变为 4 ，且将 arr[5] 变成 5 。\n数组变为 [4,1,5,<em><strong>4</strong></em>,6,<em><strong>5</strong></em>] 。\n可能有其他方法将数组变为 K 递增的，但没有任何一种方法需要的操作次数小于 2 次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i], k &lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2112.最繁忙的机场",
        "hardRate": "MEDIUM",
        "passRate": "68.39%",
        "problemsUrl": "https://leetcode.cn/problems/the-airport-with-the-most-traffic/",
        "solutionsUrl": "https://leetcode.cn/problems/the-airport-with-the-most-traffic/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2113.查询删除和添加元素后的数组",
        "hardRate": "MEDIUM",
        "passRate": "61.64%",
        "problemsUrl": "https://leetcode.cn/problems/elements-in-array-after-removing-and-replacing-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/elements-in-array-after-removing-and-replacing-elements/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2114.句子中的最多单词数",
        "hardRate": "EASY",
        "passRate": "84.97%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-words-found-in-sentences/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-words-found-in-sentences/solution",
        "problemsDesc": "<p>一个 <strong>句子</strong>&nbsp;由一些 <strong>单词</strong>&nbsp;以及它们之间的单个空格组成，句子的开头和结尾不会有多余空格。</p>\n\n<p>给你一个字符串数组&nbsp;<code>sentences</code>&nbsp;，其中&nbsp;<code>sentences[i]</code>&nbsp;表示单个 <strong>句子</strong>&nbsp;。</p>\n\n<p>请你返回单个句子里 <strong>单词的最多数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>sentences = [\"alice and bob love leetcode\", \"i think so too\", <em><strong>\"this is great thanks very much\"</strong></em>]\n<b>输出：</b>6\n<b>解释：</b>\n- 第一个句子 \"alice and bob love leetcode\" 总共有 5 个单词。\n- 第二个句子 \"i think so too\" 总共有 4 个单词。\n- 第三个句子 \"this is great thanks very much\" 总共有 6 个单词。\n所以，单个句子中有最多单词数的是第三个句子，总共有 6 个单词。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>sentences = [\"please wait\", <em><strong>\"continue to fight\"</strong></em>, <em><strong>\"continue to win\"</strong></em>]\n<b>输出：</b>3\n<b>解释：</b>可能有多个句子有相同单词数。\n这个例子中，第二个句子和第三个句子（加粗斜体）有相同数目的单词数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentences.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= sentences[i].length &lt;= 100</code></li>\n\t<li><code>sentences[i]</code>&nbsp;只包含小写英文字母和&nbsp;<code>' '</code>&nbsp;。</li>\n\t<li><code>sentences[i]</code>&nbsp;的开头和结尾都没有空格。</li>\n\t<li><code>sentences[i]</code>&nbsp;中所有单词由单个空格隔开。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2115.从给定原材料中找到所有可以做出的菜",
        "hardRate": "MEDIUM",
        "passRate": "42.44%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-possible-recipes-from-given-supplies/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-possible-recipes-from-given-supplies/solution",
        "problemsDesc": "<p>你有 <code>n</code>&nbsp;道不同菜的信息。给你一个字符串数组&nbsp;<code>recipes</code>&nbsp;和一个二维字符串数组&nbsp;<code>ingredients</code>&nbsp;。第&nbsp;<code>i</code>&nbsp;道菜的名字为&nbsp;<code>recipes[i]</code>&nbsp;，如果你有它&nbsp;<strong>所有</strong>&nbsp;的原材料&nbsp;<code>ingredients[i]</code>&nbsp;，那么你可以&nbsp;<strong>做出</strong>&nbsp;这道菜。一道菜的原材料可能是&nbsp;<strong>另一道</strong>&nbsp;菜，也就是说&nbsp;<code>ingredients[i]</code>&nbsp;可能包含&nbsp;<code>recipes</code>&nbsp;中另一个字符串。</p>\n\n<p>同时给你一个字符串数组&nbsp;<code>supplies</code>&nbsp;，它包含你初始时拥有的所有原材料，每一种原材料你都有无限多。</p>\n\n<p>请你返回你可以做出的所有菜。你可以以 <strong>任意顺序</strong>&nbsp;返回它们。</p>\n\n<p>注意两道菜在它们的原材料中可能互相包含。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\n<b>输出：</b>[\"bread\"]\n<strong>解释：</strong>\n我们可以做出 \"bread\" ，因为我们有原材料 \"yeast\" 和 \"flour\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\n<b>输出：</b>[\"bread\",\"sandwich\"]\n<strong>解释：</strong>\n我们可以做出 \"bread\" ，因为我们有原材料 \"yeast\" 和 \"flour\" 。\n我们可以做出 \"sandwich\" ，因为我们有原材料 \"meat\" 且可以做出原材料 \"bread\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\n<b>输出：</b>[\"bread\",\"sandwich\",\"burger\"]\n<strong>解释：</strong>\n我们可以做出 \"bread\" ，因为我们有原材料 \"yeast\" 和 \"flour\" 。\n我们可以做出 \"sandwich\" ，因为我们有原材料 \"meat\" 且可以做出原材料 \"bread\" 。\n我们可以做出 \"burger\" ，因为我们有原材料 \"meat\" 且可以做出原材料 \"bread\" 和 \"sandwich\" 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\"]\n<b>输出：</b>[]\n<strong>解释：</strong>\n我们没法做出任何菜，因为我们只有原材料 \"yeast\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == recipes.length == ingredients.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= ingredients[i].length, supplies.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= recipes[i].length, ingredients[i][j].length, supplies[k].length &lt;= 10</code></li>\n\t<li><code>recipes[i], ingredients[i][j]</code>&nbsp;和&nbsp;<code>supplies[k]</code>&nbsp;只包含小写英文字母。</li>\n\t<li>所有&nbsp;<code>recipes</code> 和&nbsp;<code>supplies</code>&nbsp;中的值互不相同。</li>\n\t<li><code>ingredients[i]</code>&nbsp;中的字符串互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2116.判断一个括号字符串是否有效",
        "hardRate": "MEDIUM",
        "passRate": "32.03%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-parentheses-string-can-be-valid/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-parentheses-string-can-be-valid/solution",
        "problemsDesc": "<p>一个括号字符串是只由&nbsp;<code>'('</code> 和&nbsp;<code>')'</code>&nbsp;组成的&nbsp;<strong>非空</strong>&nbsp;字符串。如果一个字符串满足下面 <b>任意</b>&nbsp;一个条件，那么它就是有效的：</p>\n\n<ul>\n\t<li>字符串为&nbsp;<code>()</code>.</li>\n\t<li>它可以表示为 <code>AB</code><span style=\"\">（</span><code>A</code>&nbsp;与&nbsp;<code>B</code>&nbsp;连接），其中<code>A</code> 和&nbsp;<code>B</code>&nbsp;都是有效括号字符串。</li>\n\t<li>它可以表示为&nbsp;<code>(A)</code>&nbsp;，其中&nbsp;<code>A</code>&nbsp;是一个有效括号字符串。</li>\n</ul>\n\n<p>给你一个括号字符串&nbsp;<code>s</code>&nbsp;和一个字符串&nbsp;<code>locked</code>&nbsp;，两者长度都为&nbsp;<code>n</code>&nbsp;。<code>locked</code>&nbsp;是一个二进制字符串，只包含&nbsp;<code>'0'</code>&nbsp;和&nbsp;<code>'1'</code>&nbsp;。对于&nbsp;<code>locked</code>&nbsp;中&nbsp;<strong>每一个</strong>&nbsp;下标&nbsp;<code>i</code> ：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>locked[i]</code>&nbsp;是&nbsp;<code>'1'</code>&nbsp;，你 <strong>不能</strong>&nbsp;改变&nbsp;<code>s[i]</code>&nbsp;。</li>\n\t<li>如果&nbsp;<code>locked[i]</code>&nbsp;是&nbsp;<code>'0'</code>&nbsp;，你&nbsp;<strong>可以</strong>&nbsp;将&nbsp;<code>s[i]</code>&nbsp;变为&nbsp;<code>'('</code>&nbsp;或者&nbsp;<code>')'</code>&nbsp;。</li>\n</ul>\n\n<p>如果你可以将 <code>s</code>&nbsp;变为有效括号字符串，请你返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/06/eg1.png\" style=\"width: 311px; height: 101px;\" /></p>\n\n<pre>\n<b>输入：</b>s = \"))()))\", locked = \"010100\"\n<b>输出：</b>true\n<b>解释：</b>locked[1] == '1' 和 locked[3] == '1' ，所以我们无法改变 s[1] 或者 s[3] 。\n我们可以将 s[0] 和 s[4] 变为 '(' ，不改变 s[2] 和 s[5] ，使 s 变为有效字符串。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"()()\", locked = \"0000\"\n<b>输出：</b>true\n<b>解释：</b>我们不需要做任何改变，因为 s 已经是有效字符串了。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \")\", locked = \"0\"\n<b>输出：</b>false\n<b>解释：</b>locked 允许改变 s[0] 。\n但无论将 s[0] 变为 '(' 或者 ')' 都无法使 s 变为有效字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == s.length == locked.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'('</code>&nbsp;要么是&nbsp;<code>')'</code>&nbsp;。</li>\n\t<li><code>locked[i]</code> 要么是&nbsp;<code>'0'</code>&nbsp;要么是&nbsp;<code>'1'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2117.一个区间内所有数乘积的缩写",
        "hardRate": "HARD",
        "passRate": "30.79%",
        "problemsUrl": "https://leetcode.cn/problems/abbreviating-the-product-of-a-range/",
        "solutionsUrl": "https://leetcode.cn/problems/abbreviating-the-product-of-a-range/solution",
        "problemsDesc": "<p>给你两个正整数&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code>&nbsp;，满足&nbsp;<code>left &lt;= right</code>&nbsp;。请你计算&nbsp;<strong>闭区间</strong>&nbsp;<code>[left, right]</code>&nbsp;中所有整数的&nbsp;<strong>乘积</strong>&nbsp;。</p>\n\n<p>由于乘积可能非常大，你需要将它按照以下步骤 <strong>缩写</strong>&nbsp;：</p>\n\n<ol>\n\t<li>统计乘积中&nbsp;<strong>后缀</strong> 0 的数目，并 <strong>移除</strong> 这些 0 ，将这个数目记为&nbsp;<code>C</code>&nbsp;。\n\n\t<ul>\n\t\t<li>比方说，<code>1000</code>&nbsp;中有 <code>3</code> 个后缀 0&nbsp;，<code>546</code>&nbsp;中没有后缀 0 。</li>\n\t</ul>\n\t</li>\n\t<li>将乘积中剩余数字的位数记为&nbsp;<code>d</code>&nbsp;。如果&nbsp;<code>d &gt; 10</code>&nbsp;，那么将乘积表示为&nbsp;<code>&lt;pre&gt;...&lt;suf&gt;</code>&nbsp;的形式，其中&nbsp;<code>&lt;pre&gt;</code>&nbsp;表示乘积最 <strong>开始</strong>&nbsp;的 <code>5</code>&nbsp;个数位，<code>&lt;suf&gt;</code>&nbsp;表示删除后缀 0 <strong>之后</strong>&nbsp;结尾的 <code>5</code>&nbsp;个数位。如果&nbsp;<code>d &lt;= 10</code>&nbsp;，我们不对它做修改。\n\t<ul>\n\t\t<li>比方说，我们将&nbsp;<code>1234567654321</code>&nbsp;表示为&nbsp;<code>12345...54321</code>&nbsp;，但是&nbsp;<code>1234567</code>&nbsp;仍然表示为&nbsp;<code>1234567</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li>最后，将乘积表示为 <strong>字符串</strong>&nbsp;<code>\"&lt;pre&gt;...&lt;suf&gt;eC\"</code>&nbsp;。\n\t<ul>\n\t\t<li>比方说，<code>12345678987600000</code>&nbsp;被表示为&nbsp;<code>\"12345...89876e5\"</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>请你返回一个字符串，表示 <strong>闭区间</strong>&nbsp;<code>[left, right]</code>&nbsp;中所有整数&nbsp;<strong>乘积</strong>&nbsp;的&nbsp;<strong>缩写</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>left = 1, right = 4\n<b>输出：</b>\"24e0\"\n<strong>解释：</strong>\n乘积为 1 × 2 × 3 × 4 = 24 。\n由于没有后缀 0 ，所以 24 保持不变，缩写的结尾为 \"e0\" 。\n因为乘积的结果是 2 位数，小于 10 ，所欲我们不进一步将它缩写。\n所以，最终将乘积表示为 \"24e0\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 2, right = 11\n<strong>输出：</strong>\"399168e2\"\n<strong>解释：</strong>乘积为 39916800 。\n有 2 个后缀 0 ，删除后得到 399168 。缩写的结尾为 \"e2\" 。 \n删除后缀 0 后是 6 位数，不需要进一步缩写。 \n所以，最终将乘积表示为 \"399168e2\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 371, right = 375\n<strong>输出：</strong>\"7219856259e3\"\n<strong>解释：</strong>乘积为 7219856259000 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2118.建立方程",
        "hardRate": "HARD",
        "passRate": "54.64%",
        "problemsUrl": "https://leetcode.cn/problems/build-the-equation/",
        "solutionsUrl": "https://leetcode.cn/problems/build-the-equation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2119.反转两次的数字",
        "hardRate": "EASY",
        "passRate": "73.68%",
        "problemsUrl": "https://leetcode.cn/problems/a-number-after-a-double-reversal/",
        "solutionsUrl": "https://leetcode.cn/problems/a-number-after-a-double-reversal/solution",
        "problemsDesc": "<p><strong>反转</strong> 一个整数意味着倒置它的所有位。</p>\n\n<ul>\n\t<li>例如，反转 <code>2021</code> 得到 <code>1202</code> 。反转 <code>12300</code> 得到 <code>321</code> ，<strong>不保留前导零</strong> 。</li>\n</ul>\n\n<p>给你一个整数 <code>num</code> ，<strong>反转</strong> <code>num</code> 得到 <code>reversed1</code> ，<strong>接着反转</strong> <code>reversed1</code> 得到 <code>reversed2</code> 。如果 <code>reversed2</code> 等于 <code>num</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 526\n<strong>输出：</strong>true\n<strong>解释：</strong>反转 num 得到 625 ，接着反转 625 得到 526 ，等于 num 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 1800\n<strong>输出：</strong>false\n<strong>解释：</strong>反转 num 得到 81 ，接着反转 81 得到 18 ，不等于 num 。 </pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 0\n<strong>输出：</strong>true\n<strong>解释：</strong>反转 num 得到 0 ，接着反转 0 得到 0 ，等于 num 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2120.执行所有后缀指令",
        "hardRate": "MEDIUM",
        "passRate": "82.47%",
        "problemsUrl": "https://leetcode.cn/problems/execution-of-all-suffix-instructions-staying-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/execution-of-all-suffix-instructions-staying-in-a-grid/solution",
        "problemsDesc": "<p>现有一个 <code>n x n</code> 大小的网格，左上角单元格坐标 <code>(0, 0)</code> ，右下角单元格坐标 <code>(n - 1, n - 1)</code> 。给你整数 <code>n</code> 和一个整数数组 <code>startPos</code> ，其中 <code>startPos = [start<sub>row</sub>, start<sub>col</sub>]</code> 表示机器人最开始在坐标为 <code>(start<sub>row</sub>, start<sub>col</sub>)</code> 的单元格上。</p>\n\n<p>另给你一个长度为 <code>m</code> 、下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，其中 <code>s[i]</code> 是对机器人的第 <code>i</code> 条指令：<code>'L'</code>（向左移动），<code>'R'</code>（向右移动），<code>'U'</code>（向上移动）和 <code>'D'</code>（向下移动）。</p>\n\n<p>机器人可以从 <code>s</code> 中的任一第 <code>i</code> 条指令开始执行。它将会逐条执行指令直到 <code>s</code> 的末尾，但在满足下述条件之一时，机器人将会停止：</p>\n\n<ul>\n\t<li>下一条指令将会导致机器人移动到网格外。</li>\n\t<li>没有指令可以执行。</li>\n</ul>\n\n<p>返回一个长度为 <code>m</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是机器人从第 <code>i</code>&nbsp;条指令 <strong>开始</strong>&nbsp;，可以执行的 <strong>指令数目</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/09/1.png\" style=\"width: 145px; height: 142px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 3, startPos = [0,1], s = \"RRDDLU\"\n<strong>输出：</strong>[1,5,4,3,1,0]\n<strong>解释：</strong>机器人从 startPos 出发，并从第 i 条指令开始执行：\n- 0: \"<em><strong>R</strong></em>RDDLU\" 在移动到网格外之前，只能执行一条 \"R\" 指令。\n- 1:  \"<em><strong>RDDLU</strong></em>\" 可以执行全部五条指令，机器人仍在网格内，最终到达 (0, 0) 。\n- 2:   \"<em><strong>DDLU</strong></em>\" 可以执行全部四条指令，机器人仍在网格内，最终到达 (0, 0) 。\n- 3:    \"<em><strong>DLU</strong></em>\" 可以执行全部三条指令，机器人仍在网格内，最终到达 (0, 0) 。\n- 4:     \"<em><strong>L</strong></em>U\" 在移动到网格外之前，只能执行一条 \"L\" 指令。\n- 5:      \"U\" 如果向上移动，将会移动到网格外。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/09/2.png\" style=\"width: 106px; height: 103px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 2, startPos = [1,1], s = \"LURD\"\n<strong>输出：</strong>[4,1,0,0]\n<strong>解释：</strong>\n- 0: \"<em><strong>LURD</strong></em>\"\n- 1:  \"<em><strong>U</strong></em>RD\"\n- 2:   \"RD\"\n- 3:    \"D\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/09/3.png\" style=\"width: 67px; height: 64px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 1, startPos = [0,0], s = \"LRUD\"\n<strong>输出：</strong>[0,0,0,0]\n<strong>解释：</strong>无论机器人从哪条指令开始执行，都会移动到网格外。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == s.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 500</code></li>\n\t<li><code>startPos.length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>row</sub>, start<sub>col</sub> &lt; n</code></li>\n\t<li><code>s</code> 由 <code>'L'</code>、<code>'R'</code>、<code>'U'</code> 和 <code>'D'</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2121.相同元素的间隔之和",
        "hardRate": "MEDIUM",
        "passRate": "38.64%",
        "problemsUrl": "https://leetcode.cn/problems/intervals-between-identical-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/intervals-between-identical-elements/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、由 <code>n</code> 个整数组成的数组 <code>arr</code> 。</p>\n\n<p><code>arr</code> 中两个元素的 <strong>间隔</strong> 定义为它们下标之间的 <strong>绝对差</strong> 。更正式地，<code>arr[i]</code> 和 <code>arr[j]</code> 之间的间隔是 <code>|i - j|</code> 。</p>\n\n<p>返回一个长度为 <code>n</code> 的数组&nbsp;<code>intervals</code> ，其中 <code>intervals[i]</code> 是<em> </em><code>arr[i]</code><em> </em>和<em> </em><code>arr</code><em> </em>中每个相同元素（与 <code>arr[i]</code> 的值相同）的 <strong>间隔之和</strong> <em>。</em></p>\n\n<p><strong>注意：</strong><code>|x|</code> 是 <code>x</code> 的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,1,3,1,2,3,3]\n<strong>输出：</strong>[4,2,7,2,4,4,5]\n<strong>解释：</strong>\n- 下标 0 ：另一个 2 在下标 4 ，|0 - 4| = 4\n- 下标 1 ：另一个 1 在下标 3 ，|1 - 3| = 2\n- 下标 2 ：另两个 3 在下标 5 和 6 ，|2 - 5| + |2 - 6| = 7\n- 下标 3 ：另一个 1 在下标 1 ，|3 - 1| = 2\n- 下标 4 ：另一个 2 在下标 0 ，|4 - 0| = 4\n- 下标 5 ：另两个 3 在下标 2 和 6 ，|5 - 2| + |5 - 6| = 4\n- 下标 6 ：另两个 3 在下标 2 和 5 ，|6 - 2| + |6 - 5| = 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [10,5,10,10]\n<strong>输出：</strong>[5,0,3,4]\n<strong>解释：</strong>\n- 下标 0 ：另两个 10 在下标 2 和 3 ，|0 - 2| + |0 - 3| = 5\n- 下标 1 ：只有这一个 5 在数组中，所以到相同元素的间隔之和是 0\n- 下标 2 ：另两个 10 在下标 0 和 3 ，|2 - 0| + |2 - 3| = 3\n- 下标 3 ：另两个 10 在下标 0 和 2 ，|3 - 0| + |3 - 2| = 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == arr.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2122.还原原数组",
        "hardRate": "HARD",
        "passRate": "42.00%",
        "problemsUrl": "https://leetcode.cn/problems/recover-the-original-array/",
        "solutionsUrl": "https://leetcode.cn/problems/recover-the-original-array/solution",
        "problemsDesc": "<p>Alice 有一个下标从 <strong>0</strong> 开始的数组 <code>arr</code> ，由 <code>n</code> 个正整数组成。她会选择一个任意的 <strong>正整数 </strong><code>k</code> 并按下述方式创建两个下标从 <strong>0</strong> 开始的新整数数组 <code>lower</code> 和 <code>higher</code> ：</p>\n\n<ol>\n\t<li>对每个满足 <code>0 &lt;= i &lt; n</code> 的下标 <code>i</code> ，<code>lower[i] = arr[i] - k</code></li>\n\t<li>对每个满足 <code>0 &lt;= i &lt; n</code> 的下标 <code>i</code> ，<code>higher[i] = arr[i] + k</code></li>\n</ol>\n\n<p>不幸地是，Alice 丢失了全部三个数组。但是，她记住了在数组 <code>lower</code> 和 <code>higher</code> 中出现的整数，但不知道每个整数属于哪个数组。请你帮助 Alice 还原原数组。</p>\n\n<p>给你一个由 2n 个整数组成的整数数组 <code>nums</code> ，其中 <strong>恰好</strong> <code>n</code> 个整数出现在 <code>lower</code> ，剩下的出现在 <code>higher</code> ，还原并返回 <strong>原数组</strong> <code>arr</code> 。如果出现答案不唯一的情况，返回 <strong>任一</strong> 有效数组。</p>\n\n<p><strong>注意：</strong>生成的测试用例保证存在 <strong>至少一个</strong> 有效数组 <code>arr</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,10,6,4,8,12]\n<strong>输出：</strong>[3,7,11]\n<strong>解释：</strong>\n如果 arr = [3,7,11] 且 k = 1 ，那么 lower = [2,6,10] 且 higher = [4,8,12] 。\n组合 lower 和 higher 得到 [2,6,10,4,8,12] ，这是 nums 的一个排列。\n另一个有效的数组是 arr = [5,7,9] 且 k = 3 。在这种情况下，lower = [2,4,6] 且 higher = [8,10,12] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,3,3]\n<strong>输出：</strong>[2,2]\n<strong>解释：</strong>\n如果 arr = [2,2] 且 k = 1 ，那么 lower = [1,1] 且 higher = [3,3] 。\n组合 lower 和 higher 得到 [1,1,3,3] ，这是 nums 的一个排列。\n注意，数组不能是 [1,3] ，因为在这种情况下，获得 [1,1,3,3] 唯一可行的方案是 k = 0 。\n这种方案是无效的，k 必须是一个正整数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,435]\n<strong>输出：</strong>[220]\n<strong>解释：</strong>\n唯一可行的组合是 arr = [220] 且 k = 215 。在这种情况下，lower = [5] 且 higher = [435] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 * n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>生成的测试用例保证存在 <strong>至少一个</strong> 有效数组 <code>arr</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2123.使矩阵中的 1 互不相邻的最小操作数",
        "hardRate": "HARD",
        "passRate": "52.98%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-remove-adjacent-ones-in-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-remove-adjacent-ones-in-matrix/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2124.检查是否所有 A 都在 B 之前",
        "hardRate": "EASY",
        "passRate": "69.21%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-all-as-appears-before-all-bs/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-all-as-appears-before-all-bs/solution",
        "problemsDesc": "<p>给你一个 <strong>仅</strong> 由字符 <code>'a'</code> 和 <code>'b'</code> 组成的字符串&nbsp; <code>s</code> 。如果字符串中 <strong>每个</strong> <em> </em><code>'a'</code> 都出现在 <strong>每个</strong><em> </em><code>'b'</code><em> </em>之前，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"aaabbb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\n'a' 位于下标 0、1 和 2 ；而 'b' 位于下标 3、4 和 5 。\n因此，每个 'a' 都出现在每个 'b' 之前，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abab\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\n存在一个 'a' 位于下标 2 ，而一个 'b' 位于下标 1 。\n因此，不能满足每个 'a' 都出现在每个 'b' 之前，所以返回 false 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"bbb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\n不存在 'a' ，因此可以视作每个 'a' 都出现在每个 'b' 之前，所以返回 true 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s[i]</code> 为 <code>'a'</code> 或 <code>'b'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2125.银行中的激光束数量",
        "hardRate": "MEDIUM",
        "passRate": "83.07%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-laser-beams-in-a-bank/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-laser-beams-in-a-bank/solution",
        "problemsDesc": "<p>银行内部的防盗安全装置已经激活。给你一个下标从 <strong>0</strong> 开始的二进制字符串数组 <code>bank</code> ，表示银行的平面图，这是一个大小为 <code>m x n</code> 的二维矩阵。 <code>bank[i]</code> 表示第 <code>i</code> 行的设备分布，由若干 <code>'0'</code> 和若干 <code>'1'</code> 组成。<code>'0'</code> 表示单元格是空的，而 <code>'1'</code> 表示单元格有一个安全设备。</p>\n\n<p>对任意两个安全设备而言，<strong>如果</strong><strong>同时</strong> 满足下面两个条件，则二者之间存在 <strong>一个</strong> 激光束：</p>\n\n<ul>\n\t<li>两个设备位于两个 <strong>不同行</strong> ：<code>r<sub>1</sub></code> 和 <code>r<sub>2</sub></code> ，其中 <code>r<sub>1</sub> &lt; r<sub>2</sub></code> 。</li>\n\t<li>满足&nbsp;<code>r<sub>1</sub> &lt; i &lt; r<sub>2</sub></code>&nbsp;的 <strong>所有&nbsp;</strong>行&nbsp;<code>i</code>&nbsp;，都&nbsp;<strong>没有安全设备</strong> 。</li>\n</ul>\n\n<p>激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。</p>\n\n<p>返回银行中激光束的总数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/24/laser1.jpg\" style=\"width: 400px; height: 368px;\" /></p>\n\n<pre>\n<strong>输入：</strong>bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\n<strong>输出：</strong>8\n<strong>解释：</strong>在下面每组设备对之间，存在一条激光束。总共是 8 条激光束：\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\n注意，第 0 行和第 3 行上的设备之间不存在激光束。\n这是因为第 2 行存在安全设备，这不满足第 2 个条件。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/24/laser2.jpg\" style=\"width: 244px; height: 325px;\" /></p>\n\n<pre>\n<strong>输入：</strong>bank = [\"000\",\"111\",\"000\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在两个位于不同行的设备\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == bank.length</code></li>\n\t<li><code>n == bank[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>bank[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2126.摧毁小行星",
        "hardRate": "MEDIUM",
        "passRate": "48.83%",
        "problemsUrl": "https://leetcode.cn/problems/destroying-asteroids/",
        "solutionsUrl": "https://leetcode.cn/problems/destroying-asteroids/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>mass</code>&nbsp;，它表示一颗行星的初始质量。再给你一个整数数组&nbsp;<code>asteroids</code>&nbsp;，其中&nbsp;<code>asteroids[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;颗小行星的质量。</p>\n\n<p>你可以按 <strong>任意顺序</strong>&nbsp;重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量 <strong>大于等于</strong>&nbsp;小行星的质量，那么小行星被 <strong>摧毁</strong>&nbsp;，并且行星会 <strong>获得</strong>&nbsp;这颗小行星的质量。否则，行星将被摧毁。</p>\n\n<p>如果所有小行星 <strong>都</strong>&nbsp;能被摧毁，请返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>mass = 10, asteroids = [3,9,19,5,21]\n<b>输出：</b>true\n<b>解释：</b>一种安排小行星的方式为 [9,19,5,3,21] ：\n- 行星与质量为 9 的小行星碰撞。新的行星质量为：10 + 9 = 19\n- 行星与质量为 19 的小行星碰撞。新的行星质量为：19 + 19 = 38\n- 行星与质量为 5 的小行星碰撞。新的行星质量为：38 + 5 = 43\n- 行星与质量为 3 的小行星碰撞。新的行星质量为：43 + 3 = 46\n- 行星与质量为 21 的小行星碰撞。新的行星质量为：46 + 21 = 67\n所有小行星都被摧毁。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>mass = 5, asteroids = [4,9,23,4]\n<b>输出：</b>false\n<b>解释：</b>\n行星无论如何没法获得足够质量去摧毁质量为 23 的小行星。\n行星把别的小行星摧毁后，质量为 5 + 4 + 9 + 4 = 22 。\n它比 23 小，所以无法摧毁最后一颗小行星。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= mass &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= asteroids.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= asteroids[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2127.参加会议的最多员工数",
        "hardRate": "HARD",
        "passRate": "34.12%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/solution",
        "problemsDesc": "<p>一个公司准备组织一场会议，邀请名单上有&nbsp;<code>n</code>&nbsp;位员工。公司准备了一张 <strong>圆形</strong>&nbsp;的桌子，可以坐下 <strong>任意数目</strong>&nbsp;的员工。</p>\n\n<p>员工编号为 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;。每位员工都有一位 <strong>喜欢</strong>&nbsp;的员工，每位员工&nbsp;<strong>当且仅当</strong>&nbsp;他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 <strong>不会</strong>&nbsp;是他自己。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>favorite</code>&nbsp;，其中&nbsp;<code>favorite[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;位员工喜欢的员工。请你返回参加会议的&nbsp;<strong>最多员工数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/14/ex1.png\" style=\"width: 236px; height: 195px;\"></p>\n\n<pre><b>输入：</b>favorite = [2,2,1,2]\n<b>输出：</b>3\n<strong>解释：</strong>\n上图展示了公司邀请员工 0，1 和 2 参加会议以及他们在圆桌上的座位。\n没办法邀请所有员工参与会议，因为员工 2 没办法同时坐在 0，1 和 3 员工的旁边。\n注意，公司也可以邀请员工 1，2 和 3 参加会议。\n所以最多参加会议的员工数目为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>favorite = [1,2,0]\n<b>输出：</b>3\n<b>解释：</b>\n每个员工都至少是另一个员工喜欢的员工。所以公司邀请他们所有人参加会议的前提是所有人都参加了会议。\n座位安排同图 1 所示：\n- 员工 0 坐在员工 2 和 1 之间。\n- 员工 1 坐在员工 0 和 2 之间。\n- 员工 2 坐在员工 1 和 0 之间。\n参与会议的最多员工数目为 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/14/ex2.png\" style=\"width: 219px; height: 220px;\"></p>\n\n<pre><b>输入：</b>favorite = [3,0,1,4,1]\n<b>输出：</b>4\n<b>解释：</b>\n上图展示了公司可以邀请员工 0，1，3 和 4 参加会议以及他们在圆桌上的座位。\n员工 2 无法参加，因为他喜欢的员工 0 旁边的座位已经被占领了。\n所以公司只能不邀请员工 2 。\n参加会议的最多员工数目为 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == favorite.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= favorite[i] &lt;=&nbsp;n - 1</code></li>\n\t<li><code>favorite[i] != i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2128.通过翻转行或列来去除所有的 1",
        "hardRate": "MEDIUM",
        "passRate": "75.50%",
        "problemsUrl": "https://leetcode.cn/problems/remove-all-ones-with-row-and-column-flips/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-all-ones-with-row-and-column-flips/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2129.将标题首字母大写",
        "hardRate": "EASY",
        "passRate": "60.68%",
        "problemsUrl": "https://leetcode.cn/problems/capitalize-the-title/",
        "solutionsUrl": "https://leetcode.cn/problems/capitalize-the-title/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>title</code>&nbsp;，它由单个空格连接一个或多个单词组成，每个单词都只包含英文字母。请你按以下规则将每个单词的首字母 <strong>大写</strong>&nbsp;：</p>\n\n<ul>\n\t<li>如果单词的长度为&nbsp;<code>1</code>&nbsp;或者&nbsp;<code>2</code>&nbsp;，所有字母变成小写。</li>\n\t<li>否则，将单词首字母大写，剩余字母变成小写。</li>\n</ul>\n\n<p>请你返回 <strong>大写后</strong>&nbsp;的<em>&nbsp;</em><code>title</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre><b>输入：</b>title = \"capiTalIze tHe titLe\"\n<b>输出：</b>\"Capitalize The Title\"\n<strong>解释：</strong>\n由于所有单词的长度都至少为 3 ，将每个单词首字母大写，剩余字母变为小写。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>title = \"First leTTeR of EACH Word\"\n<b>输出：</b>\"First Letter of Each Word\"\n<strong>解释：</strong>\n单词 \"of\" 长度为 2 ，所以它保持完全小写。\n其他单词长度都至少为 3 ，所以其他单词首字母大写，剩余字母小写。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>title = \"i lOve leetcode\"\n<b>输出：</b>\"i Love Leetcode\"\n<strong>解释：</strong>\n单词 \"i\" 长度为 1 ，所以它保留小写。\n其他单词长度都至少为 3 ，所以其他单词首字母大写，剩余字母小写。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= title.length &lt;= 100</code></li>\n\t<li><code>title</code>&nbsp;由单个空格隔开的单词组成，且不含有任何前导或后缀空格。</li>\n\t<li>每个单词由大写和小写英文字母组成，且都是 <strong>非空</strong>&nbsp;的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2130.链表最大孪生和",
        "hardRate": "MEDIUM",
        "passRate": "80.34%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/solution",
        "problemsDesc": "<p>在一个大小为&nbsp;<code>n</code>&nbsp;且 <code>n</code>&nbsp;为&nbsp;<strong>偶数</strong> 的链表中，对于&nbsp;<code>0 &lt;= i &lt;= (n / 2) - 1</code>&nbsp;的 <code>i</code>&nbsp;，第&nbsp;<code>i</code>&nbsp;个节点（下标从 <strong>0</strong>&nbsp;开始）的孪生节点为第&nbsp;<code>(n-1-i)</code>&nbsp;个节点 。</p>\n\n<ul>\n\t<li>比方说，<code>n = 4</code>&nbsp;那么节点&nbsp;<code>0</code>&nbsp;是节点 <code>3</code>&nbsp;的孪生节点，节点 <code>1</code>&nbsp;是节点 <code>2</code>&nbsp;的孪生节点。这是长度为 <code><span style=\"\">n = 4</span></code>&nbsp;的链表中所有的孪生节点。</li>\n</ul>\n\n<p><strong>孪生和</strong>&nbsp;定义为一个节点和它孪生节点两者值之和。</p>\n\n<p>给你一个长度为偶数的链表的头节点&nbsp;<code>head</code>&nbsp;，请你返回链表的 <strong>最大孪生和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg1drawio.png\" style=\"width: 250px; height: 70px;\"></p>\n\n<pre><b>输入：</b>head = [5,4,2,1]\n<b>输出：</b>6\n<strong>解释：</strong>\n节点 0 和节点 1 分别是节点 3 和 2 的孪生节点。孪生和都为 6 。\n链表中没有其他孪生节点。\n所以，链表的最大孪生和是 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg2drawio.png\" style=\"width: 250px; height: 70px;\"></p>\n\n<pre><b>输入：</b>head = [4,2,2,3]\n<b>输出：</b>7\n<strong>解释：</strong>\n链表中的孪生节点为：\n- 节点 0 是节点 3 的孪生节点，孪生和为 4 + 3 = 7 。\n- 节点 1 是节点 2 的孪生节点，孪生和为 2 + 2 = 4 。\n所以，最大孪生和为 max(7, 4) = 7 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png\" style=\"width: 200px; height: 88px;\"></p>\n\n<pre><b>输入：</b>head = [1,100000]\n<b>输出：</b>100001\n<strong>解释：</strong>\n链表中只有一对孪生节点，孪生和为 1 + 100000 = 100001 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表的节点数目是&nbsp;<code>[2, 10<sup>5</sup>]</code>&nbsp;中的&nbsp;<strong>偶数</strong>&nbsp;。</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2131.连接两字母单词得到的最长回文串",
        "hardRate": "MEDIUM",
        "passRate": "42.92%",
        "problemsUrl": "https://leetcode.cn/problems/longest-palindrome-by-concatenating-two-letter-words/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-palindrome-by-concatenating-two-letter-words/solution",
        "problemsDesc": "<p>给你一个字符串数组&nbsp;<code>words</code>&nbsp;。<code>words</code>&nbsp;中每个元素都是一个包含 <strong>两个</strong>&nbsp;小写英文字母的单词。</p>\n\n<p>请你从 <code>words</code>&nbsp;中选择一些元素并按 <b>任意顺序</b>&nbsp;连接它们，并得到一个 <strong>尽可能长的回文串</strong>&nbsp;。每个元素 <strong>至多</strong>&nbsp;只能使用一次。</p>\n\n<p>请你返回你能得到的最长回文串的 <strong>长度</strong>&nbsp;。如果没办法得到任何一个回文串，请你返回 <code>0</code>&nbsp;。</p>\n\n<p><strong>回文串</strong>&nbsp;指的是从前往后和从后往前读一样的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>words = [\"lc\",\"cl\",\"gg\"]\n<b>输出：</b>6\n<b>解释：</b>一个最长的回文串为 \"lc\" + \"gg\" + \"cl\" = \"lcggcl\" ，长度为 6 。\n\"clgglc\" 是另一个可以得到的最长回文串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>words = [\"ab\",\"ty\",\"yt\",\"lc\",\"cl\",\"ab\"]\n<b>输出：</b>8\n<strong>解释：</strong>最长回文串是 \"ty\" + \"lc\" + \"cl\" + \"yt\" = \"tylcclyt\" ，长度为 8 。\n\"lcyttycl\" 是另一个可以得到的最长回文串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>words = [\"cc\",\"ll\",\"xx\"]\n<b>输出：</b>2\n<b>解释：</b>最长回文串是 \"cc\" ，长度为 2 。\n\"ll\" 是另一个可以得到的最长回文串。\"xx\" 也是。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>words[i].length == 2</code></li>\n\t<li><code>words[i]</code>&nbsp;仅包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2132.用邮票贴满网格图",
        "hardRate": "HARD",
        "passRate": "30.74%",
        "problemsUrl": "https://leetcode.cn/problems/stamping-the-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/stamping-the-grid/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的二进制矩阵&nbsp;<code>grid</code>&nbsp;，每个格子要么为&nbsp;<code>0</code>&nbsp;（空）要么为&nbsp;<code>1</code>&nbsp;（被占据）。</p>\n\n<p>给你邮票的尺寸为&nbsp;<code>stampHeight x stampWidth</code>&nbsp;。我们想将邮票贴进二进制矩阵中，且满足以下&nbsp;<strong>限制</strong>&nbsp;和&nbsp;<strong>要求</strong>&nbsp;：</p>\n\n<ol>\n\t<li>覆盖所有 <strong>空</strong>&nbsp;格子。</li>\n\t<li>不覆盖任何 <strong>被占据&nbsp;</strong>的格子。</li>\n\t<li>我们可以放入任意数目的邮票。</li>\n\t<li>邮票可以相互有 <strong>重叠</strong>&nbsp;部分。</li>\n\t<li>邮票不允许 <strong>旋转</strong>&nbsp;。</li>\n\t<li>邮票必须完全在矩阵 <strong>内</strong>&nbsp;。</li>\n</ol>\n\n<p>如果在满足上述要求的前提下，可以放入邮票，请返回&nbsp;<code>true</code>&nbsp;，否则返回<i>&nbsp;</i><code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/ex1.png\" style=\"width: 180px; height: 237px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3\n<b>输出：</b>true\n<b>解释：</b>我们放入两个有重叠部分的邮票（图中标号为 1 和 2），它们能覆盖所有与空格子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/ex2.png\" style=\"width: 170px; height: 179px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 \n<b>输出：</b>false \n<b>解释：</b>没办法放入邮票覆盖所有的空格子，且邮票不超出网格图以外。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[r].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>grid[r][c]</code> 要么是&nbsp;<code>0</code>&nbsp;，要么是&nbsp;<code>1</code> 。</li>\n\t<li><code>1 &lt;= stampHeight, stampWidth &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2133.检查是否每一行每一列都包含全部整数",
        "hardRate": "EASY",
        "passRate": "55.66%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-every-row-and-column-contains-all-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-every-row-and-column-contains-all-numbers/solution",
        "problemsDesc": "<p>对一个大小为 <code>n x n</code> 的矩阵而言，如果其每一行和每一列都包含从 <code>1</code> 到 <code>n</code> 的 <strong>全部</strong> 整数（含 <code>1</code> 和 <code>n</code>），则认为该矩阵是一个 <strong>有效</strong> 矩阵。</p>\n\n<p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>matrix</code> ，请你判断矩阵是否为一个有效矩阵：如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/example1drawio.png\" style=\"width: 250px; height: 251px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[3,1,2],[2,3,1]]\n<strong>输出：</strong>true\n<strong>解释：</strong>在此例中，n = 3 ，每一行和每一列都包含数字 1、2、3 。\n因此，返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/example2drawio.png\" style=\"width: 250px; height: 251px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,1,1],[1,2,3],[1,2,3]]\n<strong>输出：</strong>false\n<strong>解释：</strong>在此例中，n = 3 ，但第一行和第一列不包含数字 2 和 3 。\n因此，返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= matrix[i][j] &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2134.最少交换次数来组合所有的 1 II",
        "hardRate": "MEDIUM",
        "passRate": "48.79%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/solution",
        "problemsDesc": "<p><strong>交换</strong> 定义为选中一个数组中的两个 <strong>互不相同</strong> 的位置并交换二者的值。</p>\n\n<p><strong>环形</strong> 数组是一个数组，可以认为 <strong>第一个</strong> 元素和 <strong>最后一个</strong> 元素 <strong>相邻</strong> 。</p>\n\n<p>给你一个 <strong>二进制环形</strong> 数组 <code>nums</code> ，返回在 <strong>任意位置</strong> 将数组中的所有 <code>1</code> 聚集在一起需要的最少交换次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,0,1,1,0,0]\n<strong>输出：</strong>1\n<strong>解释：</strong>这里列出一些能够将所有 1 聚集在一起的方案：\n[0,<strong><em>0</em></strong>,<em><strong>1</strong></em>,1,1,0,0] 交换 1 次。\n[0,1,<em><strong>1</strong></em>,1,<em><strong>0</strong></em>,0,0] 交换 1 次。\n[1,1,0,0,0,0,1] 交换 2 次（利用数组的环形特性）。\n无法在交换 0 次的情况下将数组中的所有 1 聚集在一起。\n因此，需要的最少交换次数为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,1,1,0,0,1,1,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>这里列出一些能够将所有 1 聚集在一起的方案：\n[1,1,1,0,0,0,0,1,1] 交换 2 次（利用数组的环形特性）。\n[1,1,1,1,1,0,0,0,0] 交换 2 次。\n无法在交换 0 次或 1 次的情况下将数组中的所有 1 聚集在一起。\n因此，需要的最少交换次数为 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,0,0,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>得益于数组的环形特性，所有的 1 已经聚集在一起。\n因此，需要的最少交换次数为 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 为 <code>0</code> 或者 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2135.统计追加字母可以获得的单词数",
        "hardRate": "MEDIUM",
        "passRate": "36.13%",
        "problemsUrl": "https://leetcode.cn/problems/count-words-obtained-after-adding-a-letter/",
        "solutionsUrl": "https://leetcode.cn/problems/count-words-obtained-after-adding-a-letter/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的字符串数组 <code>startWords</code> 和 <code>targetWords</code> 。每个字符串都仅由 <strong>小写英文字母</strong> 组成。</p>\n\n<p>对于 <code>targetWords</code> 中的每个字符串，检查是否能够从 <code>startWords</code> 中选出一个字符串，执行一次 <strong>转换操作</strong>&nbsp;，得到的结果与当前&nbsp;<code>targetWords</code> 字符串相等。</p>\n\n<p><strong>转换操作</strong> 如下面两步所述：</p>\n\n<ol>\n\t<li><strong>追加</strong> 任何 <strong>不存在</strong> 于当前字符串的任一小写字母到当前字符串的末尾。\n\n\t<ul>\n\t\t<li>例如，如果字符串为 <code>\"abc\"</code> ，那么字母 <code>'d'</code>、<code>'e'</code> 或 <code>'y'</code> 都可以加到该字符串末尾，但 <code>'a'</code> 就不行。如果追加的是 <code>'d'</code> ，那么结果字符串为 <code>\"abcd\"</code> 。</li>\n\t</ul>\n\t</li>\n\t<li><strong>重排</strong> 新字符串中的字母，可以按 <strong>任意</strong> 顺序重新排布字母。\n\t<ul>\n\t\t<li>例如，<code>\"abcd\"</code> 可以重排为 <code>\"acbd\"</code>、<code>\"bacd\"</code>、<code>\"cbda\"</code>，以此类推。注意，它也可以重排为 <code>\"abcd\"</code> 自身。</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>找出 <code>targetWords</code> 中有多少字符串能够由&nbsp;<code>startWords</code> 中的 <strong>任一</strong> 字符串执行上述转换操作获得。返回<em> </em><code>targetWords</code><em> </em>中这类 <strong>字符串的数目</strong> 。</p>\n\n<p><strong>注意：</strong>你仅能验证 <code>targetWords</code> 中的字符串是否可以由 <code>startWords</code> 中的某个字符串经执行操作获得。<code>startWords</code>&nbsp; 中的字符串在这一过程中 <strong>不</strong> 发生实际变更。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>startWords = [\"ant\",\"act\",\"tack\"], targetWords = [\"tack\",\"act\",\"acti\"]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- 为了形成 targetWords[0] = \"tack\" ，可以选用 startWords[1] = \"act\" ，追加字母 'k' ，并重排 \"actk\" 为 \"tack\" 。\n- startWords 中不存在可以用于获得 targetWords[1] = \"act\" 的字符串。\n  注意 \"act\" 确实存在于 startWords ，但是 <strong>必须</strong> 在重排前给这个字符串追加一个字母。\n- 为了形成 targetWords[2] = \"acti\" ，可以选用 startWords[1] = \"act\" ，追加字母 'i' ，并重排 \"acti\" 为 \"acti\" 自身。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>startWords = [\"ab\",\"a\"], targetWords = [\"abc\",\"abcd\"]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 为了形成 targetWords[0] = \"abc\" ，可以选用 startWords[0] = \"ab\" ，追加字母 'c' ，并重排为 \"abc\" 。\n- startWords 中不存在可以用于获得 targetWords[1] = \"abcd\" 的字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= startWords.length, targetWords.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= startWords[i].length, targetWords[j].length &lt;= 26</code></li>\n\t<li><code>startWords</code> 和 <code>targetWords</code> 中的每个字符串都仅由小写英文字母组成</li>\n\t<li>在 <code>startWords</code> 或 <code>targetWords</code> 的任一字符串中，每个字母至多出现一次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2136.全部开花的最早一天",
        "hardRate": "HARD",
        "passRate": "66.05%",
        "problemsUrl": "https://leetcode.cn/problems/earliest-possible-day-of-full-bloom/",
        "solutionsUrl": "https://leetcode.cn/problems/earliest-possible-day-of-full-bloom/solution",
        "problemsDesc": "<p>你有 <code>n</code> 枚花的种子。每枚种子必须先种下，才能开始生长、开花。播种需要时间，种子的生长也是如此。给你两个下标从 <strong>0</strong> 开始的整数数组 <code>plantTime</code> 和 <code>growTime</code> ，每个数组的长度都是 <code>n</code> ：</p>\n\n<ul>\n\t<li><code>plantTime[i]</code> 是 <strong>播种</strong> 第 <code>i</code> 枚种子所需的 <strong>完整天数</strong> 。每天，你只能为播种某一枚种子而劳作。<strong>无须</strong> 连续几天都在种同一枚种子，但是种子播种必须在你工作的天数达到 <code>plantTime[i]</code> 之后才算完成。</li>\n\t<li><code>growTime[i]</code> 是第 <code>i</code> 枚种子完全种下后生长所需的 <strong>完整天数 </strong>。在它生长的最后一天 <strong>之后</strong> ，将会开花并且永远 <strong>绽放</strong> 。</li>\n</ul>\n\n<p>从第 <code>0</code> 开始，你可以按 <strong>任意</strong> 顺序播种种子。</p>\n\n<p>返回所有种子都开花的 <strong>最早</strong> 一天是第几天。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/1.png\" style=\"width: 453px; height: 149px;\">\n<pre><strong>输入：</strong>plantTime = [1,4,3], growTime = [2,3,1]\n<strong>输出：</strong>9\n<strong>解释：</strong>灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。\n一种最优方案是：\n第 0 天，播种第 0 枚种子，种子生长 2 整天。并在第 3 天开花。\n第 1、2、3、4 天，播种第 1 枚种子。种子生长 3 整天，并在第 8 天开花。\n第 5、6、7 天，播种第 2 枚种子。种子生长 1 整天，并在第 9 天开花。\n因此，在第 9 天，所有种子都开花。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/2.png\" style=\"width: 454px; height: 184px;\">\n<pre><strong>输入：</strong>plantTime = [1,2,3,2], growTime = [2,1,2,1]\n<strong>输出：</strong>9\n<strong>解释：</strong>灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。 \n一种最优方案是：\n第 1 天，播种第 0 枚种子，种子生长 2 整天。并在第 4 天开花。\n第 0、3 天，播种第 1 枚种子。种子生长 1 整天，并在第 5 天开花。\n第 2、4、5 天，播种第 2 枚种子。种子生长 2 整天，并在第 8 天开花。\n第 6、7 天，播种第 3 枚种子。种子生长 1 整天，并在第 9 天开花。\n因此，在第 9 天，所有种子都开花。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>plantTime = [1], growTime = [1]\n<strong>输出：</strong>2\n<strong>解释：</strong>第 0 天，播种第 0 枚种子。种子需要生长 1 整天，然后在第 2 天开花。\n因此，在第 2 天，所有种子都开花。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == plantTime.length == growTime.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= plantTime[i], growTime[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2137.通过倒水操作让所有的水桶所含水量相等",
        "hardRate": "MEDIUM",
        "passRate": "64.72%",
        "problemsUrl": "https://leetcode.cn/problems/pour-water-between-buckets-to-make-water-levels-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/pour-water-between-buckets-to-make-water-levels-equal/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2138.将字符串拆分为若干长度为 k 的组",
        "hardRate": "EASY",
        "passRate": "66.35%",
        "problemsUrl": "https://leetcode.cn/problems/divide-a-string-into-groups-of-size-k/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-a-string-into-groups-of-size-k/solution",
        "problemsDesc": "<p>字符串 <code>s</code> 可以按下述步骤划分为若干长度为 <code>k</code> 的组：</p>\n\n<ul>\n\t<li>第一组由字符串中的前 <code>k</code> 个字符组成，第二组由接下来的 <code>k</code> 个字符串组成，依此类推。每个字符都能够成为 <strong>某一个</strong> 组的一部分。</li>\n\t<li>对于最后一组，如果字符串剩下的字符 <strong>不足</strong> <code>k</code> 个，需使用字符 <code>fill</code> 来补全这一组字符。</li>\n</ul>\n\n<p>注意，在去除最后一个组的填充字符 <code>fill</code>（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 <code>s</code> 。</p>\n\n<p>给你一个字符串 <code>s</code> ，以及每组的长度 <code>k</code> 和一个用于填充的字符 <code>fill</code> ，按上述步骤处理之后，返回一个字符串数组，该数组表示 <code>s</code> 分组后 <strong>每个组的组成情况</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abcdefghi\", k = 3, fill = \"x\"\n<strong>输出：</strong>[\"abc\",\"def\",\"ghi\"]\n<strong>解释：</strong>\n前 3 个字符是 \"abc\" ，形成第一组。\n接下来 3 个字符是 \"def\" ，形成第二组。\n最后 3 个字符是 \"ghi\" ，形成第三组。\n由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。\n因此，形成 3 组，分别是 \"abc\"、\"def\" 和 \"ghi\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abcdefghij\", k = 3, fill = \"x\"\n<strong>输出：</strong>[\"abc\",\"def\",\"ghi\",\"jxx\"]\n<strong>解释：</strong>\n与前一个例子类似，形成前三组 \"abc\"、\"def\" 和 \"ghi\" 。\n对于最后一组，字符串中仅剩下字符 'j' 可以用。为了补全这一组，使用填充字符 'x' 两次。\n因此，形成 4 组，分别是 \"abc\"、\"def\"、\"ghi\" 和 \"jxx\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n\t<li><code>fill</code> 是一个小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2139.得到目标值的最少行动次数",
        "hardRate": "MEDIUM",
        "passRate": "51.47%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-reach-target-score/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-reach-target-score/solution",
        "problemsDesc": "<p>你正在玩一个整数游戏。从整数 <code>1</code> 开始，期望得到整数 <code>target</code> 。</p>\n\n<p>在一次行动中，你可以做下述两种操作之一：</p>\n\n<ul>\n\t<li><strong>递增</strong>，将当前整数的值加 1（即， <code>x = x + 1</code>）。</li>\n\t<li><strong>加倍</strong>，使当前整数的值翻倍（即，<code>x = 2 * x</code>）。</li>\n</ul>\n\n<p>在整个游戏过程中，你可以使用 <strong>递增</strong> 操作 <strong>任意</strong> 次数。但是只能使用 <strong>加倍</strong> 操作 <strong>至多</strong> <code>maxDoubles</code> 次。</p>\n\n<p>给你两个整数 <code>target</code> 和 <code>maxDoubles</code> ，返回从 1 开始得到<em> </em><code>target</code><em> </em>需要的最少行动次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>target = 5, maxDoubles = 0\n<strong>输出：</strong>4\n<strong>解释：</strong>一直递增 1 直到得到 target 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>target = 19, maxDoubles = 2\n<strong>输出：</strong>7\n<strong>解释：</strong>最初，x = 1 。\n递增 3 次，x = 4 。\n加倍 1 次，x = 8 。\n递增 1 次，x = 9 。\n加倍 1 次，x = 18 。\n递增 1 次，x = 19 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>target = 10, maxDoubles = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>\n最初，x = 1 。 \n递增 1 次，x = 2 。 \n加倍 1 次，x = 4 。 \n递增 1 次，x = 5 。 \n加倍 1 次，x = 10 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= maxDoubles &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2140.解决智力问题",
        "hardRate": "MEDIUM",
        "passRate": "43.93%",
        "problemsUrl": "https://leetcode.cn/problems/solving-questions-with-brainpower/",
        "solutionsUrl": "https://leetcode.cn/problems/solving-questions-with-brainpower/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>questions</code>&nbsp;，其中&nbsp;<code>questions[i] = [points<sub>i</sub>, brainpower<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>这个数组表示一场考试里的一系列题目，你需要 <strong>按顺序</strong>&nbsp;（也就是从问题 <code>0</code><strong>&nbsp;</strong>开始依次解决），针对每个问题选择 <strong>解决</strong>&nbsp;或者 <strong>跳过</strong>&nbsp;操作。解决问题 <code>i</code>&nbsp;将让你 <b>获得</b>&nbsp;&nbsp;<code>points<sub>i</sub></code>&nbsp;的分数，但是你将 <strong>无法</strong>&nbsp;解决接下来的&nbsp;<code>brainpower<sub>i</sub></code>&nbsp;个问题（即只能跳过接下来的 <code>brainpower<sub>i</sub></code><sub>&nbsp;</sub>个问题）。如果你跳过问题&nbsp;<code>i</code>&nbsp;，你可以对下一个问题决定使用哪种操作。</p>\n\n<ul>\n\t<li>比方说，给你&nbsp;<code>questions = [[3, 2], [4, 3], [4, 4], [2, 5]]</code>&nbsp;：\n\n\t<ul>\n\t\t<li>如果问题&nbsp;<code>0</code>&nbsp;被解决了， 那么你可以获得&nbsp;<code>3</code>&nbsp;分，但你不能解决问题&nbsp;<code>1</code> 和&nbsp;<code>2</code>&nbsp;。</li>\n\t\t<li>如果你跳过问题&nbsp;<code>0</code>&nbsp;，且解决问题&nbsp;<code>1</code>&nbsp;，你将获得 <code>4</code> 分但是不能解决问题&nbsp;<code>2</code> 和&nbsp;<code>3</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回这场考试里你能获得的 <strong>最高</strong>&nbsp;分数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>questions = [[3,2],[4,3],[4,4],[2,5]]\n<b>输出：</b>5\n<b>解释：</b>解决问题 0 和 3 得到最高分。\n- 解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。\n- 不能解决问题 1 和 2\n- 解决问题 3 ：获得 2 分\n总得分为：3 + 2 = 5 。没有别的办法获得 5 分或者多于 5 分。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]\n<b>输出：</b>7\n<b>解释：</b>解决问题 1 和 4 得到最高分。\n- 跳过问题 0\n- 解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。\n- 不能解决问题 2 和 3\n- 解决问题 4 ：获得 5 分\n总得分为：2 + 5 = 7 。没有别的办法获得 7 分或者多于 7 分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= questions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>questions[i].length == 2</code></li>\n\t<li><code>1 &lt;= points<sub>i</sub>, brainpower<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2141.同时运行 N 台电脑的最长时间",
        "hardRate": "HARD",
        "passRate": "40.58%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-running-time-of-n-computers/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-running-time-of-n-computers/solution",
        "problemsDesc": "<p>你有&nbsp;<code>n</code>&nbsp;台电脑。给你整数&nbsp;<code>n</code>&nbsp;和一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>batteries</code>&nbsp;，其中第&nbsp;<code>i</code>&nbsp;个电池可以让一台电脑 <strong>运行&nbsp;</strong><code>batteries[i]</code>&nbsp;分钟。你想使用这些电池让&nbsp;<strong>全部</strong>&nbsp;<code>n</code>&nbsp;台电脑 <b>同时</b>&nbsp;运行。</p>\n\n<p>一开始，你可以给每台电脑连接 <strong>至多一个电池</strong>&nbsp;。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 <strong>任意次</strong>&nbsp;。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。</p>\n\n<p>注意，你不能给电池充电。</p>\n\n<p>请你返回你可以让 <code>n</code>&nbsp;台电脑同时运行的 <strong>最长</strong>&nbsp;分钟数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/06/example1-fit.png\" style=\"width: 762px; height: 150px;\"></p>\n\n<pre><b>输入：</b>n = 2, batteries = [3,3,3]\n<b>输出：</b>4\n<b>解释：</b>\n一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 1 连接。\n2 分钟后，将第二台电脑与电池 1 断开连接，并连接电池 2 。注意，电池 0 还可以供电 1 分钟。\n在第 3 分钟结尾，你需要将第一台电脑与电池 0 断开连接，然后连接电池 1 。\n在第 4 分钟结尾，电池 1 也被耗尽，第一台电脑无法继续运行。\n我们最多能同时让两台电脑同时运行 4 分钟，所以我们返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/06/example2.png\" style=\"width: 629px; height: 150px;\"></p>\n\n<pre><b>输入：</b>n = 2, batteries = [1,1,1,1]\n<b>输出：</b>2\n<b>解释：</b>\n一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 2 连接。\n一分钟后，电池 0 和电池 2 同时耗尽，所以你需要将它们断开连接，并将电池 1 和第一台电脑连接，电池 3 和第二台电脑连接。\n1 分钟后，电池 1 和电池 3 也耗尽了，所以两台电脑都无法继续运行。\n我们最多能让两台电脑同时运行 2 分钟，所以我们返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= batteries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= batteries[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2142.每辆车的乘客人数 I",
        "hardRate": "MEDIUM",
        "passRate": "46.63%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-passengers-in-each-bus-i/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-passengers-in-each-bus-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2143.在两个数组的区间中选取数字",
        "hardRate": "HARD",
        "passRate": "57.14%",
        "problemsUrl": "https://leetcode.cn/problems/choose-numbers-from-two-arrays-in-range/",
        "solutionsUrl": "https://leetcode.cn/problems/choose-numbers-from-two-arrays-in-range/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2144.打折购买糖果的最小开销",
        "hardRate": "EASY",
        "passRate": "66.91%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-of-buying-candies-with-discount/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-of-buying-candies-with-discount/solution",
        "problemsDesc": "<p>一家商店正在打折销售糖果。每购买 <strong>两个</strong>&nbsp;糖果，商店会 <strong>免费</strong>&nbsp;送一个糖果。</p>\n\n<p>免费送的糖果唯一的限制是：它的价格需要小于等于购买的两个糖果价格的 <strong>较小值</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，总共有 <code>4</code>&nbsp;个糖果，价格分别为&nbsp;<code>1</code>&nbsp;，<code>2</code>&nbsp;，<code>3</code>&nbsp;和&nbsp;<code>4</code>&nbsp;，一位顾客买了价格为&nbsp;<code>2</code> 和&nbsp;<code>3</code>&nbsp;的糖果，那么他可以免费获得价格为 <code>1</code>&nbsp;的糖果，但不能获得价格为&nbsp;<code>4</code>&nbsp;的糖果。</li>\n</ul>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>cost</code>&nbsp;，其中&nbsp;<code>cost[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个糖果的价格，请你返回获得 <strong>所有</strong>&nbsp;糖果的 <strong>最小</strong>&nbsp;总开销。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>cost = [1,2,3]\n<b>输出：</b>5\n<b>解释：</b>我们购买价格为 2 和 3 的糖果，然后免费获得价格为 1 的糖果。\n总开销为 2 + 3 = 5 。这是开销最小的 <strong>唯一</strong>&nbsp;方案。\n注意，我们不能购买价格为 1 和 3 的糖果，并免费获得价格为 2 的糖果。\n这是因为免费糖果的价格必须小于等于购买的 2 个糖果价格的较小值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>cost = [6,5,7,9,2,2]\n<b>输出：</b>23\n<b>解释：</b>最小总开销购买糖果方案为：\n- 购买价格为 9 和 7 的糖果\n- 免费获得价格为 6 的糖果\n- 购买价格为 5 和 2 的糖果\n- 免费获得价格为 2 的最后一个糖果\n因此，最小总开销为 9 + 7 + 5 + 2 = 23 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>cost = [5,5]\n<b>输出：</b>10\n<b>解释：</b>由于只有 2 个糖果，我们需要将它们都购买，而且没有免费糖果。\n所以总最小开销为 5 + 5 = 10 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= cost.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= cost[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2145.统计隐藏数组数目",
        "hardRate": "MEDIUM",
        "passRate": "35.82%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-hidden-sequences/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-hidden-sequences/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始且长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>differences</code>&nbsp;，它表示一个长度为&nbsp;<code>n + 1</code>&nbsp;的&nbsp;<strong>隐藏</strong>&nbsp;数组&nbsp;<strong>相邻</strong>&nbsp;元素之间的&nbsp;<strong>差值</strong>&nbsp;。更正式的表述为：我们将隐藏数组记作&nbsp;<code>hidden</code>&nbsp;，那么&nbsp;<code>differences[i] = hidden[i + 1] - hidden[i]</code>&nbsp;。</p>\n\n<p>同时给你两个整数&nbsp;<code>lower</code> 和&nbsp;<code>upper</code>&nbsp;，它们表示隐藏数组中所有数字的值都在 <strong>闭</strong>&nbsp;区间&nbsp;<code>[lower, upper]</code>&nbsp;之间。</p>\n\n<ul>\n\t<li>比方说，<code>differences = [1, -3, 4]</code>&nbsp;，<code>lower = 1</code>&nbsp;，<code>upper = 6</code>&nbsp;，那么隐藏数组是一个长度为 <code>4</code>&nbsp;且所有值都在&nbsp;<code>1</code>&nbsp;和&nbsp;<code>6</code>&nbsp;（包含两者）之间的数组。\n\n\t<ul>\n\t\t<li><code>[3, 4, 1, 5]</code> 和&nbsp;<code>[4, 5, 2, 6]</code>&nbsp;都是符合要求的隐藏数组。</li>\n\t\t<li><code>[5, 6, 3, 7]</code>&nbsp;不符合要求，因为它包含大于 <code>6</code>&nbsp;的元素。</li>\n\t\t<li><code>[1, 2, 3, 4]</code>&nbsp;不符合要求，因为相邻元素的差值不符合给定数据。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回 <strong>符合</strong>&nbsp;要求的隐藏数组的数目。如果没有符合要求的隐藏数组，请返回 <code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>differences = [1,-3,4], lower = 1, upper = 6\n<b>输出：</b>2\n<b>解释：</b>符合要求的隐藏数组为：\n- [3, 4, 1, 5]\n- [4, 5, 2, 6]\n所以返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>differences = [3,-4,5,1,-2], lower = -4, upper = 5\n<b>输出：</b>4\n<b>解释：</b>符合要求的隐藏数组为：\n- [-3, 0, -4, 1, 2, 0]\n- [-2, 1, -3, 2, 3, 1]\n- [-1, 2, -2, 3, 4, 2]\n- [0, 3, -1, 4, 5, 3]\n所以返回 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>differences = [4,-7,2], lower = 3, upper = 6\n<b>输出：</b>0\n<b>解释：</b>没有符合要求的隐藏数组，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == differences.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= differences[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= lower &lt;= upper &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2146.价格范围内最高排名的 K 样物品",
        "hardRate": "MEDIUM",
        "passRate": "40.13%",
        "problemsUrl": "https://leetcode.cn/problems/k-highest-ranked-items-within-a-price-range/",
        "solutionsUrl": "https://leetcode.cn/problems/k-highest-ranked-items-within-a-price-range/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>grid</code>&nbsp;，它的大小为&nbsp;<code>m x n</code>&nbsp;，表示一个商店中物品的分布图。数组中的整数含义为：</p>\n\n<ul>\n\t<li><code>0</code>&nbsp;表示无法穿越的一堵墙。</li>\n\t<li><code>1</code>&nbsp;表示可以自由通过的一个空格子。</li>\n\t<li>所有其他正整数表示该格子内的一样物品的价格。你可以自由经过这些格子。</li>\n</ul>\n\n<p>从一个格子走到上下左右相邻格子花费&nbsp;<code>1</code>&nbsp;步。</p>\n\n<p>同时给你一个整数数组&nbsp;<code>pricing</code> 和&nbsp;<code>start</code>&nbsp;，其中&nbsp;<code>pricing = [low, high]</code> 且&nbsp;<code>start = [row, col]</code>&nbsp;，表示你开始位置为&nbsp;<code>(row, col)</code>&nbsp;，同时你只对物品价格在<strong>&nbsp;闭区间</strong>&nbsp;<code>[low, high]</code>&nbsp;之内的物品感兴趣。同时给你一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>你想知道给定范围 <strong>内</strong>&nbsp;且 <strong>排名最高</strong>&nbsp;的 <code>k</code>&nbsp;件物品的 <strong>位置</strong>&nbsp;。排名按照优先级从高到低的以下规则制定：</p>\n\n<ol>\n\t<li>距离：定义为从&nbsp;<code>start</code>&nbsp;到一件物品的最短路径需要的步数（<strong>较近</strong>&nbsp;距离的排名更高）。</li>\n\t<li>价格：<strong>较低</strong>&nbsp;价格的物品有更高优先级，但只考虑在给定范围之内的价格。</li>\n\t<li>行坐标：<strong>较小</strong>&nbsp;行坐标的有更高优先级。</li>\n\t<li>列坐标：<strong>较小</strong>&nbsp;列坐标的有更高优先级。</li>\n</ol>\n\n<p>请你返回给定价格内排名最高的 <code>k</code>&nbsp;件物品的坐标，将它们按照排名排序后返回。如果给定价格内少于 <code>k</code>&nbsp;件物品，那么请将它们的坐标&nbsp;<strong>全部</strong>&nbsp;返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/16/example1drawio.png\" style=\"width: 200px; height: 151px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3\n<b>输出：</b>[[0,1],[1,1],[2,1]]\n<b>解释：</b>起点为 (0,0) 。\n价格范围为 [2,5] ，我们可以选择的物品坐标为 (0,1)，(1,1)，(2,1) 和 (2,2) 。\n这些物品的排名为：\n- (0,1) 距离为 1\n- (1,1) 距离为 2\n- (2,1) 距离为 3\n- (2,2) 距离为 4\n所以，给定价格范围内排名最高的 3 件物品的坐标为 (0,1)，(1,1) 和 (2,1) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/16/example2drawio1.png\" style=\"width: 200px; height: 151px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2\n<b>输出：</b>[[2,1],[1,2]]\n<b>解释：</b>起点为 (2,3) 。\n价格范围为 [2,3] ，我们可以选择的物品坐标为 (0,1)，(1,1)，(1,2) 和 (2,1) 。\n这些物品的排名为： \n- (2,1) 距离为 2 ，价格为 2\n- (1,2) 距离为 2 ，价格为 3\n- (1,1) 距离为 3\n- (0,1) 距离为 4\n所以，给定价格范围内排名最高的 2 件物品的坐标为 (2,1) 和 (1,2) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/30/example3.png\" style=\"width: 149px; height: 150px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3\n<b>输出：</b>[[2,1],[2,0]]\n<b>解释：</b>起点为 (0,0) 。\n价格范围为 [2,3] ，我们可以选择的物品坐标为 (2,0) 和 (2,1) 。\n这些物品的排名为：\n- (2,1) 距离为 5\n- (2,0) 距离为 6\n所以，给定价格范围内排名最高的 2 件物品的坐标为 (2,1) 和 (2,0) 。\n注意，k = 3 但给定价格范围内只有 2 件物品。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pricing.length == 2</code></li>\n\t<li><code>2 &lt;= low &lt;= high &lt;= 10<sup>5</sup></code></li>\n\t<li><code>start.length == 2</code></li>\n\t<li><code>0 &lt;= row &lt;= m - 1</code></li>\n\t<li><code>0 &lt;= col &lt;= n - 1</code></li>\n\t<li><code>grid[row][col] &gt; 0</code></li>\n\t<li><code>1 &lt;= k &lt;= m * n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2147.分隔长廊的方案数",
        "hardRate": "HARD",
        "passRate": "41.48%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-divide-a-long-corridor/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-divide-a-long-corridor/solution",
        "problemsDesc": "<p>在一个图书馆的长廊里，有一些座位和装饰植物排成一列。给你一个下标从 <strong>0</strong>&nbsp;开始，长度为 <code>n</code>&nbsp;的字符串&nbsp;<code>corridor</code>&nbsp;，它包含字母&nbsp;<code>'S'</code> 和&nbsp;<code>'P'</code>&nbsp;，其中每个&nbsp;<code>'S'</code>&nbsp;表示一个座位，每个&nbsp;<code>'P'</code>&nbsp;表示一株植物。</p>\n\n<p>在下标 <code>0</code>&nbsp;的左边和下标 <code>n - 1</code>&nbsp;的右边 <strong>已经</strong>&nbsp;分别各放了一个屏风。你还需要额外放置一些屏风。每一个位置&nbsp;<code>i - 1</code> 和&nbsp;<code>i</code>&nbsp;之间（<code>1 &lt;= i &lt;= n - 1</code>），至多能放一个屏风。</p>\n\n<p>请你将走廊用屏风划分为若干段，且每一段内都 <strong>恰好有两个座位</strong>&nbsp;，而每一段内植物的数目没有要求。可能有多种划分方案，如果两个方案中有任何一个屏风的位置不同，那么它们被视为 <strong>不同</strong> 方案。</p>\n\n<p>请你返回划分走廊的方案数。由于答案可能很大，请你返回它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;的结果。如果没有任何方案，请返回&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/04/1.png\" style=\"width: 410px; height: 199px;\"></p>\n\n<pre><b>输入：</b>corridor = \"SSPPSPS\"\n<b>输出：</b>3\n<b>解释：</b>总共有 3 种不同分隔走廊的方案。\n上图中黑色的竖线表示已经放置好的屏风。\n上图每种方案中，每一段都恰好有 <strong>两个</strong>&nbsp;座位。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/04/2.png\" style=\"width: 357px; height: 68px;\"></p>\n\n<pre><b>输入：</b>corridor = \"PPSPSP\"\n<b>输出：</b>1\n<b>解释：</b>只有 1 种分隔走廊的方案，就是不放置任何屏风。\n放置任何的屏风都会导致有一段无法恰好有 2 个座位。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/12/3.png\" style=\"width: 115px; height: 68px;\"></p>\n\n<pre><b>输入：</b>corridor = \"S\"\n<b>输出：</b>0\n<b>解释：</b>没有任何方案，因为总是有一段无法恰好有 2 个座位。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == corridor.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>corridor[i]</code>&nbsp;要么是&nbsp;<code>'S'</code>&nbsp;，要么是&nbsp;<code>'P'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2148.元素计数",
        "hardRate": "EASY",
        "passRate": "57.80%",
        "problemsUrl": "https://leetcode.cn/problems/count-elements-with-strictly-smaller-and-greater-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/count-elements-with-strictly-smaller-and-greater-elements/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，统计并返回在 <code>nums</code> 中同时至少具有一个严格较小元素和一个严格较大元素的元素数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [11,7,2,15]\n<strong>输出：</strong>2\n<strong>解释：</strong>元素 7 ：严格较小元素是元素 2 ，严格较大元素是元素 11 。\n元素 11 ：严格较小元素是元素 7 ，严格较大元素是元素 15 。\n总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-3,3,3,90]\n<strong>输出：</strong>2\n<strong>解释：</strong>元素 3 ：严格较小元素是元素 -3 ，严格较大元素是元素 90 。\n由于有两个元素的值为 3 ，总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2149.按符号重排数组",
        "hardRate": "MEDIUM",
        "passRate": "79.71%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-array-elements-by-sign/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-array-elements-by-sign/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，数组长度为 <strong>偶数</strong> ，由数目相等的正整数和负整数组成。</p>\n\n<p>你需要 <strong>重排</strong> <code>nums</code> 中的元素，使修改后的数组满足下述条件：</p>\n\n<ol>\n\t<li>任意&nbsp;<strong>连续</strong> 的两个整数 <strong>符号相反</strong></li>\n\t<li>对于符号相同的所有整数，<strong>保留</strong> 它们在 <code>nums</code> 中的 <strong>顺序</strong> 。</li>\n\t<li>重排后数组以正整数开头。</li>\n</ol>\n\n<p>重排元素满足上述条件后，返回修改后的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,-2,-5,2,-4]\n<strong>输出：</strong>[3,-2,1,-5,2,-4]\n<strong>解释：</strong>\nnums 中的正整数是 [3,1,2] ，负整数是 [-2,-5,-4] 。\n重排的唯一可行方案是 [3,-2,1,-5,2,-4]，能满足所有条件。\n像 [1,-2,2,-5,3,-4]、[3,1,2,-2,-5,-4]、[-2,3,-5,1,-4,2] 这样的其他方案是不正确的，因为不满足一个或者多个条件。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,1]\n<strong>输出：</strong>[1,-1]\n<strong>解释：</strong>\n1 是 nums 中唯一一个正整数，-1 是 nums 中唯一一个负整数。\n所以 nums 重排为 [1,-1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>nums.length</code> 是 <strong>偶数</strong></li>\n\t<li><code>1 &lt;= |nums[i]| &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums</code> 由 <strong>相等</strong> 数量的正整数和负整数组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2150.找出数组中的所有孤独数字",
        "hardRate": "MEDIUM",
        "passRate": "59.59%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-lonely-numbers-in-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-lonely-numbers-in-the-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。如果数字 <code>x</code> 在数组中仅出现 <strong>一次</strong> ，且没有 <strong>相邻</strong> 数字（即，<code>x + 1</code> 和 <code>x - 1</code>）出现在数组中，则认为数字 <code>x</code> 是 <strong>孤独数字</strong> 。</p>\n\n<p>返回<em> </em><code>nums</code> 中的 <strong>所有</strong> 孤独数字。你可以按 <strong>任何顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,6,5,8]\n<strong>输出：</strong>[10,8]\n<strong>解释：</strong>\n- 10 是一个孤独数字，因为它只出现一次，并且 9 和 11 没有在 nums 中出现。\n- 8 是一个孤独数字，因为它只出现一次，并且 7 和 9 没有在 nums 中出现。\n- 5 不是一个孤独数字，因为 6 出现在 nums 中，反之亦然。\n因此，nums 中的孤独数字是 [10, 8] 。\n注意，也可以返回 [8, 10] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,5,3]\n<strong>输出：</strong>[1,5]\n<strong>解释：</strong>\n- 1 是一个孤独数字，因为它只出现一次，并且 0 和 2 没有在 nums 中出现。\n- 5 是一个孤独数字，因为它只出现一次，并且 4 和 6 没有在 nums 中出现。\n- 3 不是一个孤独数字，因为它出现两次。\n因此，nums 中的孤独数字是 [1, 5] 。\n注意，也可以返回 [5, 1] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2151.基于陈述统计最多好人数",
        "hardRate": "HARD",
        "passRate": "50.34%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-good-people-based-on-statements/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-good-people-based-on-statements/solution",
        "problemsDesc": "<p>游戏中存在两种角色：</p>\n\n<ul>\n\t<li><strong>好人</strong>：该角色只说真话。</li>\n\t<li><strong>坏人</strong>：该角色可能说真话，也可能说假话。</li>\n</ul>\n\n<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>statements</code> ，大小为 <code>n x n</code> ，表示 <code>n</code> 个玩家对彼此角色的陈述。具体来说，<code>statements[i][j]</code> 可以是下述值之一：</p>\n\n<ul>\n\t<li><code>0</code> 表示 <code>i</code> 的陈述认为 <code>j</code> 是 <strong>坏人</strong> 。</li>\n\t<li><code>1</code> 表示 <code>i</code> 的陈述认为 <code>j</code> 是 <strong>好人</strong> 。</li>\n\t<li><code>2</code> 表示 <code>i</code> 没有对 <code>j</code> 作出陈述。</li>\n</ul>\n\n<p>另外，玩家不会对自己进行陈述。形式上，对所有&nbsp;<code>0 &lt;= i &lt; n</code> ，都有 <code>statements[i][i] = 2</code> 。</p>\n\n<p>根据这 <code>n</code> 个玩家的陈述，返回可以认为是 <strong>好人</strong> 的 <strong>最大</strong> 数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/15/logic1.jpg\" style=\"width: 600px; height: 262px;\">\n<pre><strong>输入：</strong>statements = [[2,1,2],[1,2,2],[2,0,2]]\n<strong>输出：</strong>2\n<strong>解释：</strong>每个人都做一条陈述。\n- 0 认为 1 是好人。\n- 1 认为 0 是好人。\n- 2 认为 1 是坏人。\n以 2 为突破点。\n- 假设 2 是一个好人：\n    - 基于 2 的陈述，1 是坏人。\n    - 那么可以确认 1 是坏人，2 是好人。\n    - 基于 1 的陈述，由于 1 是坏人，那么他在陈述时可能：\n        - 说真话。在这种情况下会出现矛盾，所以假设无效。\n        - 说假话。在这种情况下，0 也是坏人并且在陈述时说假话。\n    - <strong>在认为 2 是好人的情况下，这组玩家中只有一个好人。</strong>\n- 假设 2 是一个坏人：\n    - 基于 2 的陈述，由于 2 是坏人，那么他在陈述时可能：\n        - 说真话。在这种情况下，0 和 1 都是坏人。\n            - <strong>在认为 2 是坏人但说真话的情况下，这组玩家中没有一个好人。</strong>\n        - 说假话。在这种情况下，1 是好人。\n            - 由于 1 是好人，0 也是好人。\n            - <strong>在认为 2 是坏人且说假话的情况下，这组玩家中有两个好人。</strong>\n在最佳情况下，至多有两个好人，所以返回 2 。\n注意，能得到此结论的方法不止一种。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/15/logic2.jpg\" style=\"width: 600px; height: 262px;\">\n<pre><strong>输入：</strong>statements = [[2,0],[0,2]]\n<strong>输出：</strong>1\n<strong>解释：</strong>每个人都做一条陈述。\n- 0 认为 1 是坏人。\n- 1 认为 0 是坏人。\n以 0 为突破点。\n- 假设 0 是一个好人：\n    - 基于与 0 的陈述，1 是坏人并说假话。\n    - <strong>在认为 0 是好人的情况下，这组玩家中只有一个好人。</strong>\n- 假设 0 是一个坏人：\n    - 基于 0 的陈述，由于 0 是坏人，那么他在陈述时可能：\n        - 说真话。在这种情况下，0 和 1 都是坏人。\n            - <strong>在认为 0 是坏人但说真话的情况下，这组玩家中没有一个好人。</strong>\n        - 说假话。在这种情况下，1 是好人。\n            - <strong>在认为 0 是坏人且说假话的情况下，这组玩家中只有一个好人。</strong>\n在最佳情况下，至多有一个好人，所以返回 1 。 \n注意，能得到此结论的方法不止一种。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == statements.length == statements[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 15</code></li>\n\t<li><code>statements[i][j]</code> 的值为 <code>0</code>、<code>1</code> 或 <code>2</code></li>\n\t<li><code>statements[i][i] == 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2152.穿过所有点的所需最少直线数量",
        "hardRate": "MEDIUM",
        "passRate": "52.95%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-lines-to-cover-points/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-lines-to-cover-points/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2153.每辆车的乘客人数 II",
        "hardRate": "HARD",
        "passRate": "44.47%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-passengers-in-each-bus-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-passengers-in-each-bus-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2154.将找到的值乘以 2",
        "hardRate": "EASY",
        "passRate": "73.47%",
        "problemsUrl": "https://leetcode.cn/problems/keep-multiplying-found-values-by-two/",
        "solutionsUrl": "https://leetcode.cn/problems/keep-multiplying-found-values-by-two/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，另给你一个整数 <code>original</code> ，这是需要在 <code>nums</code> 中搜索的第一个数字。</p>\n\n<p>接下来，你需要按下述步骤操作：</p>\n\n<ol>\n\t<li>如果在 <code>nums</code> 中找到 <code>original</code> ，将 <code>original</code>&nbsp;<strong>乘以</strong> 2 ，得到新 <code>original</code>（即，令 <code>original = 2 * original</code>）。</li>\n\t<li>否则，停止这一过程。</li>\n\t<li>只要能在数组中找到新 <code>original</code> ，就对新 <code>original</code> 继续 <strong>重复</strong> 这一过程<strong>。</strong></li>\n</ol>\n\n<p>返回<em> </em><code>original</code> 的 <strong>最终</strong> 值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,3,6,1,12], original = 3\n<strong>输出：</strong>24\n<strong>解释：</strong> \n- 3 能在 nums 中找到。3 * 2 = 6 。\n- 6 能在 nums 中找到。6 * 2 = 12 。\n- 12 能在 nums 中找到。12 * 2 = 24 。\n- 24 不能在 nums 中找到。因此，返回 24 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,7,9], original = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>\n- 4 不能在 nums 中找到。因此，返回 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i], original &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2155.分组得分最高的所有下标",
        "hardRate": "MEDIUM",
        "passRate": "64.58%",
        "problemsUrl": "https://leetcode.cn/problems/all-divisions-with-the-highest-score-of-a-binary-array/",
        "solutionsUrl": "https://leetcode.cn/problems/all-divisions-with-the-highest-score-of-a-binary-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二进制数组 <code>nums</code> ，数组长度为 <code>n</code> 。<code>nums</code> 可以按下标 <code>i</code>（ <code>0 &lt;= i &lt;= n</code> ）拆分成两个数组（可能为空）：<code>nums<sub>left</sub></code> 和 <code>nums<sub>right</sub></code> 。</p>\n\n<ul>\n\t<li><code>nums<sub>left</sub></code> 包含 <code>nums</code> 中从下标 <code>0</code> 到 <code>i - 1</code> 的所有元素<strong>（包括 </strong><code>0</code><strong> 和 </strong><code>i - 1</code><strong> ）</strong>，而 <code>nums<sub>right</sub></code> 包含 <code>nums</code> 中从下标 <code>i</code> 到 <code>n - 1</code> 的所有元素<strong>（包括 </strong><code>i</code><strong> 和 </strong><code>n - 1</code><strong> ）。</strong></li>\n\t<li>如果 <code>i == 0</code> ，<code>nums<sub>left</sub></code> 为 <strong>空</strong> ，而 <code>nums<sub>right</sub></code> 将包含 <code>nums</code> 中的所有元素。</li>\n\t<li>如果 <code>i == n</code> ，<code>nums<sub>left</sub></code> 将包含 <code>nums</code> 中的所有元素，而 <code>nums<sub>right</sub></code> 为 <strong>空</strong> 。</li>\n</ul>\n\n<p>下标 <code>i</code><strong> </strong>的<strong> 分组得分</strong> 为 <code>nums<sub>left</sub></code> 中 <code>0</code> 的个数和 <code>nums<sub>right</sub></code> 中 <code>1</code> 的个数之<strong> 和</strong> 。</p>\n\n<p>返回 <strong>分组得分 最高</strong> 的 <strong>所有不同下标</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,0,1,0]\n<strong>输出：</strong>[2,4]\n<strong>解释：</strong>按下标分组\n- 0 ：nums<sub>left</sub> 为 [] 。nums<sub>right</sub> 为 [0,0,<em><strong>1</strong></em>,0] 。得分为 0 + 1 = 1 。\n- 1 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [0,<em><strong>1</strong></em>,0] 。得分为 1 + 1 = 2 。\n- 2 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>,<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [<em><strong>1</strong></em>,0] 。得分为 2 + 1 = 3 。\n- 3 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>,<em><strong>0</strong></em>,1] 。nums<sub>right</sub> 为 [0] 。得分为 2 + 0 = 2 。\n- 4 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>,<em><strong>0</strong></em>,1,<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [] 。得分为 3 + 0 = 3 。\n下标 2 和 4 都可以得到最高的分组得分 3 。\n注意，答案 [4,2] 也被视为正确答案。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,0,0]\n<strong>输出：</strong>[3]\n<strong>解释：</strong>按下标分组\n- 0 ：nums<sub>left</sub> 为 [] 。nums<sub>right</sub> 为 [0,0,0] 。得分为 0 + 0 = 0 。\n- 1 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [0,0] 。得分为 1 + 0 = 1 。\n- 2 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>,<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [0] 。得分为 2 + 0 = 2 。\n- 3 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>,<em><strong>0</strong></em>,<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [] 。得分为 3 + 0 = 3 。\n只有下标 3 可以得到最高的分组得分 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1]\n<strong>输出：</strong>[0]\n<strong>解释：</strong>按下标分组\n- 0 ：nums<sub>left</sub> 为 [] 。nums<sub>right</sub> 为 [<em><strong>1</strong></em>,<em><strong>1</strong></em>] 。得分为 0 + 2 = 2 。\n- 1 ：nums<sub>left</sub> 为 [1] 。nums<sub>right</sub> 为 [<em><strong>1</strong></em>] 。得分为 0 + 1 = 1 。\n- 2 ：nums<sub>left</sub> 为 [1,1] 。nums<sub>right</sub> 为 [] 。得分为 0 + 0 = 0 。\n只有下标 0 可以得到最高的分组得分 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2156.查找给定哈希值的子串",
        "hardRate": "HARD",
        "passRate": "25.23%",
        "problemsUrl": "https://leetcode.cn/problems/find-substring-with-given-hash-value/",
        "solutionsUrl": "https://leetcode.cn/problems/find-substring-with-given-hash-value/solution",
        "problemsDesc": "<p>给定整数 <code>p</code>&nbsp;和 <code>m</code>&nbsp;，一个长度为 <code>k</code>&nbsp;且下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>s</code>&nbsp;的哈希值按照如下函数计算：</p>\n\n<ul>\n\t<li><code>hash(s, p, m) = (val(s[0]) * p<sup>0</sup> + val(s[1]) * p<sup>1</sup> + ... + val(s[k-1]) * p<sup>k-1</sup>) mod m</code>.</li>\n</ul>\n\n<p>其中&nbsp;<code>val(s[i])</code>&nbsp;表示&nbsp;<code>s[i]</code>&nbsp;在字母表中的下标，从&nbsp;<code>val('a') = 1</code> 到&nbsp;<code>val('z') = 26</code>&nbsp;。</p>\n\n<p>给你一个字符串&nbsp;<code>s</code>&nbsp;和整数&nbsp;<code>power</code>，<code>modulo</code>，<code>k</code>&nbsp;和&nbsp;<code>hashValue</code>&nbsp;。请你返回 <code>s</code>&nbsp;中 <strong>第一个</strong> 长度为 <code>k</code>&nbsp;的 <strong>子串</strong>&nbsp;<code>sub</code>&nbsp;，满足<em>&nbsp;</em><code>hash(sub, power, modulo) == hashValue</code>&nbsp;。</p>\n\n<p>测试数据保证一定 <strong>存在</strong>&nbsp;至少一个这样的子串。</p>\n\n<p><strong>子串</strong> 定义为一个字符串中连续非空字符组成的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"leetcode\", power = 7, modulo = 20, k = 2, hashValue = 0\n<strong>输出：</strong>\"ee\"\n<strong>解释：</strong>\"ee\" 的哈希值为 hash(\"ee\", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0 。\n\"ee\" 是长度为 2 的第一个哈希值为 0 的子串，所以我们返回 \"ee\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"fbxzaad\", power = 31, modulo = 100, k = 3, hashValue = 32\n<b>输出：</b>\"fbx\"\n<b>解释：</b>\"fbx\" 的哈希值为 hash(\"fbx\", 31, 100) = (6 * 1 + 2 * 31 + 24 * 31<sup>2</sup>) mod 100 = 23132 mod 100 = 32 。\n\"bxz\" 的哈希值为 hash(\"bxz\", 31, 100) = (2 * 1 + 24 * 31 + 26 * 31<sup>2</sup>) mod 100 = 25732 mod 100 = 32 。\n\"fbx\" 是长度为 3 的第一个哈希值为 32 的子串，所以我们返回 \"fbx\" 。\n注意，\"bxz\" 的哈希值也为 32 ，但是它在字符串中比 \"fbx\" 更晚出现。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= s.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= power, modulo &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= hashValue &lt; modulo</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n\t<li>测试数据保证一定 <strong>存在</strong>&nbsp;满足条件的子串。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2157.字符串分组",
        "hardRate": "HARD",
        "passRate": "31.28%",
        "problemsUrl": "https://leetcode.cn/problems/groups-of-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/groups-of-strings/solution",
        "problemsDesc": "<p>给你一个下标从&nbsp;<strong>0&nbsp;</strong>开始的字符串数组&nbsp;<code>words</code>&nbsp;。每个字符串都只包含 <strong>小写英文字母</strong>&nbsp;。<code>words</code>&nbsp;中任意一个子串中，每个字母都至多只出现一次。</p>\n\n<p>如果通过以下操作之一，我们可以从 <code>s1</code>&nbsp;的字母集合得到 <code>s2</code>&nbsp;的字母集合，那么我们称这两个字符串为 <strong>关联的</strong>&nbsp;：</p>\n\n<ul>\n\t<li>往&nbsp;<code>s1</code>&nbsp;的字母集合中添加一个字母。</li>\n\t<li>从&nbsp;<code>s1</code>&nbsp;的字母集合中删去一个字母。</li>\n\t<li>将 <code>s1</code>&nbsp;中的一个字母替换成另外任意一个字母（也可以替换为这个字母本身）。</li>\n</ul>\n\n<p>数组&nbsp;<code>words</code>&nbsp;可以分为一个或者多个无交集的 <strong>组</strong>&nbsp;。如果一个字符串与另一个字符串关联，那么它们应当属于同一个组。</p>\n\n<p>注意，你需要确保分好组后，一个组内的任一字符串与其他组的字符串都不关联。可以证明在这个条件下，分组方案是唯一的。</p>\n\n<p>请你返回一个长度为 <code>2</code>&nbsp;的数组&nbsp;<code>ans</code>&nbsp;：</p>\n\n<ul>\n\t<li><code>ans[0]</code>&nbsp;是&nbsp;<code>words</code>&nbsp;分组后的&nbsp;<strong>总组数</strong>&nbsp;。</li>\n\t<li><code>ans[1]</code>&nbsp;是字符串数目最多的组所包含的字符串数目。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"a\",\"b\",\"ab\",\"cde\"]\n<b>输出：</b>[2,3]\n<b>解释：</b>\n- words[0] 可以得到 words[1] （将 'a' 替换为 'b'）和 words[2] （添加 'b'）。所以 words[0] 与 words[1] 和 words[2] 关联。\n- words[1] 可以得到 words[0] （将 'b' 替换为 'a'）和 words[2] （添加 'a'）。所以 words[1] 与 words[0] 和 words[2] 关联。\n- words[2] 可以得到 words[0] （删去 'b'）和 words[1] （删去 'a'）。所以 words[2] 与 words[0] 和 words[1] 关联。\n- words[3] 与 words 中其他字符串都不关联。\n所以，words 可以分成 2 个组 [\"a\",\"b\",\"ab\"] 和 [\"cde\"] 。最大的组大小为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"a\",\"ab\",\"abc\"]\n<b>输出：</b>[1,3]\n<strong>解释：</strong>\n- words[0] 与 words[1] 关联。\n- words[1] 与 words[0] 和 words[2] 关联。\n- words[2] 与 words[1] 关联。\n由于所有字符串与其他字符串都关联，所以它们全部在同一个组内。\n所以最大的组大小为 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 26</code></li>\n\t<li><code>words[i]</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>words[i]</code> 中每个字母最多只出现一次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2158.每天绘制新区域的数量",
        "hardRate": "HARD",
        "passRate": "55.75%",
        "problemsUrl": "https://leetcode.cn/problems/amount-of-new-area-painted-each-day/",
        "solutionsUrl": "https://leetcode.cn/problems/amount-of-new-area-painted-each-day/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2159.分别排序两列",
        "hardRate": "MEDIUM",
        "passRate": "61.27%",
        "problemsUrl": "https://leetcode.cn/problems/order-two-columns-independently/",
        "solutionsUrl": "https://leetcode.cn/problems/order-two-columns-independently/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2160.拆分数位后四位数字的最小和",
        "hardRate": "EASY",
        "passRate": "84.20%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-sum-of-four-digit-number-after-splitting-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-sum-of-four-digit-number-after-splitting-digits/solution",
        "problemsDesc": "<p>给你一个四位&nbsp;<strong>正</strong>&nbsp;整数&nbsp;<code>num</code>&nbsp;。请你使用 <code>num</code>&nbsp;中的 <strong>数位</strong> ，将&nbsp;<code>num</code>&nbsp;拆成两个新的整数&nbsp;<code>new1</code>&nbsp;和&nbsp;<code>new2</code>&nbsp;。<code>new1</code> 和&nbsp;<code>new2</code>&nbsp;中可以有&nbsp;<strong>前导 0</strong>&nbsp;，且&nbsp;<code>num</code>&nbsp;中 <strong>所有</strong>&nbsp;数位都必须使用。</p>\n\n<ul>\n\t<li>比方说，给你&nbsp;<code>num = 2932</code>&nbsp;，你拥有的数位包括：两个&nbsp;<code>2</code>&nbsp;，一个&nbsp;<code>9</code>&nbsp;和一个&nbsp;<code>3</code>&nbsp;。一些可能的&nbsp;<code>[new1, new2]</code>&nbsp;数对为&nbsp;<code>[22, 93]</code>，<code>[23, 92]</code>，<code>[223, 9]</code> 和&nbsp;<code>[2, 329]</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回可以得到的&nbsp;<code>new1</code>&nbsp;和 <code>new2</code>&nbsp;的 <strong>最小</strong>&nbsp;和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>num = 2932\n<b>输出：</b>52\n<b>解释：</b>可行的 [new1, new2] 数对为 [29, 23] ，[223, 9] 等等。\n最小和为数对 [29, 23] 的和：29 + 23 = 52 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>num = 4009\n<b>输出：</b>13\n<b>解释：</b>可行的 [new1, new2] 数对为 [0, 49] ，[490, 0] 等等。\n最小和为数对 [4, 9] 的和：4 + 9 = 13 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1000 &lt;= num &lt;= 9999</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2161.根据给定数字划分数组",
        "hardRate": "MEDIUM",
        "passRate": "82.52%",
        "problemsUrl": "https://leetcode.cn/problems/partition-array-according-to-given-pivot/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-array-according-to-given-pivot/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>pivot</code>&nbsp;。请你将&nbsp;<code>nums</code>&nbsp;重新排列，使得以下条件均成立：</p>\n\n<ul>\n\t<li>所有小于&nbsp;<code>pivot</code>&nbsp;的元素都出现在所有大于&nbsp;<code>pivot</code>&nbsp;的元素&nbsp;<strong>之前</strong>&nbsp;。</li>\n\t<li>所有等于&nbsp;<code>pivot</code>&nbsp;的元素都出现在小于和大于 <code>pivot</code>&nbsp;的元素 <strong>中间</strong>&nbsp;。</li>\n\t<li>小于 <code>pivot</code>&nbsp;的元素之间和大于 <code>pivot</code>&nbsp;的元素之间的 <strong>相对顺序</strong>&nbsp;不发生改变。\n\t<ul>\n\t\t<li>更正式的，考虑每一对&nbsp;<code>p<sub>i</sub></code>，<code>p<sub>j</sub></code>&nbsp;，<code>p<sub>i</sub></code>&nbsp;是初始时位置 <code>i</code>&nbsp;元素的新位置，<code>p<sub>j</sub></code>&nbsp;是初始时位置&nbsp;<code>j</code>&nbsp;元素的新位置。对于小于&nbsp;<code>pivot</code>&nbsp;的元素，如果&nbsp;<code>i &lt; j</code>&nbsp;且&nbsp;<code>nums[i] &lt; pivot</code> 和&nbsp;<code>nums[j] &lt; pivot</code>&nbsp;都成立，那么&nbsp;<code>p<sub>i</sub> &lt; p<sub>j</sub></code>&nbsp;也成立。类似的，对于大于&nbsp;<code>pivot</code>&nbsp;的元素，如果&nbsp;<code>i &lt; j</code> 且&nbsp;<code>nums[i] &gt; pivot</code> 和&nbsp;<code>nums[j] &gt; pivot</code>&nbsp;都成立，那么&nbsp;<code>p<sub>i</sub> &lt; p<sub>j</sub></code>&nbsp;。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回重新排列 <code>nums</code>&nbsp;数组后的结果数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [9,12,5,10,14,3,10], pivot = 10\n<b>输出：</b>[9,5,3,10,10,12,14]\n<b>解释：</b>\n元素 9 ，5 和 3 小于 pivot ，所以它们在数组的最左边。\n元素 12 和 14 大于 pivot ，所以它们在数组的最右边。\n小于 pivot 的元素的相对位置和大于 pivot 的元素的相对位置分别为 [9, 5, 3] 和 [12, 14] ，它们在结果数组中的相对顺序需要保留。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [-3,4,3,2], pivot = 2\n<b>输出：</b>[-3,2,4,3]\n<b>解释：</b>\n元素 -3 小于 pivot ，所以在数组的最左边。\n元素 4 和 3 大于 pivot ，所以它们在数组的最右边。\n小于 pivot 的元素的相对位置和大于 pivot 的元素的相对位置分别为 [-3] 和 [4, 3] ，它们在结果数组中的相对顺序需要保留。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>pivot</code>&nbsp;等于&nbsp;<code>nums</code>&nbsp;中的一个元素。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2162.设置时间的最少代价",
        "hardRate": "MEDIUM",
        "passRate": "34.28%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-set-cooking-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-set-cooking-time/solution",
        "problemsDesc": "<p>常见的微波炉可以设置加热时间，且加热时间满足以下条件：</p>\n\n<ul>\n\t<li>至少为 <code>1</code>&nbsp;秒钟。</li>\n\t<li>至多为&nbsp;<code>99</code>&nbsp;分&nbsp;<code>99</code>&nbsp;秒。</li>\n</ul>\n\n<p>你可以 <strong>最多</strong>&nbsp;输入&nbsp;<strong>4 个数字</strong>&nbsp;来设置加热时间。如果你输入的位数不足 4 位，微波炉会自动加 <strong>前缀</strong>&nbsp;<strong>0</strong>&nbsp;来补足 4 位。微波炉会将设置好的四位数中，<strong>前</strong>&nbsp;两位当作分钟数，<strong>后</strong>&nbsp;两位当作秒数。它们所表示的总时间就是加热时间。比方说：</p>\n\n<ul>\n\t<li>你输入&nbsp;<code>9</code> <code>5</code> <code>4</code>&nbsp;（三个数字），被自动补足为&nbsp;<code>0954</code>&nbsp;，并表示&nbsp;<code>9</code>&nbsp;分&nbsp;<code>54</code>&nbsp;秒。</li>\n\t<li>你输入&nbsp;<code>0</code> <code>0</code> <code>0</code> <code>8</code>&nbsp;（四个数字），表示&nbsp;<code>0</code>&nbsp;分&nbsp;<code>8</code>&nbsp;秒。</li>\n\t<li>你输入&nbsp;<code>8</code> <code>0</code> <code>9</code> <code>0</code>&nbsp;，表示&nbsp;<code>80</code>&nbsp;分&nbsp;<code>90</code>&nbsp;秒。</li>\n\t<li>你输入&nbsp;<code>8</code> <code>1</code> <code>3</code> <code>0</code>&nbsp;，表示&nbsp;<code>81</code>&nbsp;分&nbsp;<code>30</code>&nbsp;秒。</li>\n</ul>\n\n<p>给你整数&nbsp;<code>startAt</code>&nbsp;，<code>moveCost</code>&nbsp;，<code>pushCost</code>&nbsp;和&nbsp;<code>targetSeconds</code>&nbsp;。<strong>一开始</strong>，你的手指在数字&nbsp;<code>startAt</code>&nbsp;处。将手指移到<strong>&nbsp;任何其他数字</strong>&nbsp;，需要花费&nbsp;<code>moveCost</code>&nbsp;的单位代价。<strong>每</strong>&nbsp;输入你手指所在位置的数字一次，需要花费&nbsp;<code>pushCost</code>&nbsp;的单位代价。</p>\n\n<p>要设置&nbsp;<code>targetSeconds</code>&nbsp;秒的加热时间，可能会有多种设置方法。你想要知道这些方法中，总代价最小为多少。</p>\n\n<p>请你能返回设置&nbsp;<code>targetSeconds</code>&nbsp;秒钟加热时间需要花费的最少代价。</p>\n\n<p>请记住，虽然微波炉的秒数最多可以设置到 <code>99</code>&nbsp;秒，但一分钟等于&nbsp;<code>60</code>&nbsp;秒。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/30/1.png\" style=\"width: 506px; height: 210px;\"></p>\n\n<pre><b>输入：</b>startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600\n<b>输出：</b>6\n<b>解释：</b>以下为设置加热时间的所有方法。\n- 1 0 0 0 ，表示 10 分 0 秒。\n&nbsp; 手指一开始就在数字 1 处，输入 1 （代价为 1），移到 0 处（代价为 2），输入 0（代价为 1），输入 0（代价为 1），输入 0（代价为 1）。\n&nbsp; 总代价为：1 + 2 + 1 + 1 + 1 = 6 。这是所有方案中的最小代价。\n- 0 9 6 0，表示 9 分 60 秒。它也表示 600 秒。\n&nbsp; 手指移到 0 处（代价为 2），输入 0 （代价为 1），移到 9 处（代价为 2），输入 9（代价为 1），移到 6 处（代价为 2），输入 6（代价为 1），移到 0 处（代价为 2），输入 0（代价为 1）。\n&nbsp; 总代价为：2 + 1 + 2 + 1 + 2 + 1 + 2 + 1 = 12 。\n- 9 6 0，微波炉自动补全为 0960 ，表示 9 分 60 秒。\n&nbsp; 手指移到 9 处（代价为 2），输入 9 （代价为 1），移到 6 处（代价为 2），输入 6（代价为 1），移到 0 处（代价为 2），输入 0（代价为 1）。\n&nbsp; 总代价为：2 + 1 + 2 + 1 + 2 + 1 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/30/2.png\" style=\"width: 505px; height: 73px;\"></p>\n\n<pre><b>输入：</b>startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76\n<b>输出：</b>6\n<b>解释：</b>最优方案为输入两个数字 7 6，表示 76 秒。\n手指移到 7 处（代价为 1），输入 7 （代价为 2），移到 6 处（代价为 1），输入 6（代价为 2）。总代价为：1 + 2 + 1 + 2 = 6\n其他可行方案为 0076 ，076 ，0116 和 116 ，但是它们的代价都比 6 大。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= startAt &lt;= 9</code></li>\n\t<li><code>1 &lt;= moveCost, pushCost &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= targetSeconds &lt;= 6039</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2163.删除元素后和的最小差值",
        "hardRate": "HARD",
        "passRate": "49.12%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-difference-in-sums-after-removal-of-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-difference-in-sums-after-removal-of-elements/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它包含&nbsp;<code>3 * n</code>&nbsp;个元素。</p>\n\n<p>你可以从 <code>nums</code>&nbsp;中删除 <strong>恰好</strong>&nbsp;<code>n</code>&nbsp;个元素，剩下的 <code>2 * n</code>&nbsp;个元素将会被分成两个 <strong>相同大小</strong>&nbsp;的部分。</p>\n\n<ul>\n\t<li>前面&nbsp;<code>n</code>&nbsp;个元素属于第一部分，它们的和记为&nbsp;<code>sum<sub>first</sub></code>&nbsp;。</li>\n\t<li>后面&nbsp;<code>n</code>&nbsp;个元素属于第二部分，它们的和记为&nbsp;<code>sum<sub>second</sub></code>&nbsp;。</li>\n</ul>\n\n<p>两部分和的 <strong>差值</strong>&nbsp;记为&nbsp;<code>sum<sub>first</sub> - sum<sub>second</sub></code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，<code>sum<sub>first</sub> = 3</code> 且&nbsp;<code>sum<sub>second</sub> = 2</code>&nbsp;，它们的差值为&nbsp;<code>1</code>&nbsp;。</li>\n\t<li>再比方，<code>sum<sub>first</sub> = 2</code> 且&nbsp;<code>sum<sub>second</sub> = 3</code>&nbsp;，它们的差值为&nbsp;<code>-1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回删除 <code>n</code>&nbsp;个元素之后，剩下两部分和的 <strong>差值的最小值</strong>&nbsp;是多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,1,2]\n<b>输出：</b>-1\n<b>解释：</b>nums 有 3 个元素，所以 n = 1 。\n所以我们需要从 nums 中删除 1 个元素，并将剩下的元素分成两部分。\n- 如果我们删除 nums[0] = 3 ，数组变为 [1,2] 。两部分和的差值为 1 - 2 = -1 。\n- 如果我们删除 nums[1] = 1 ，数组变为 [3,2] 。两部分和的差值为 3 - 2 = 1 。\n- 如果我们删除 nums[2] = 2 ，数组变为 [3,1] 。两部分和的差值为 3 - 1 = 2 。\n两部分和的最小差值为 min(-1,1,2) = -1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [7,9,5,8,1,3]\n<b>输出：</b>1\n<b>解释：</b>n = 2 。所以我们需要删除 2 个元素，并将剩下元素分为 2 部分。\n如果我们删除元素 nums[2] = 5 和 nums[3] = 8 ，剩下元素为 [7,9,1,3] 。和的差值为 (7+9) - (1+3) = 12 。\n为了得到最小差值，我们应该删除 nums[1] = 9 和 nums[4] = 1 ，剩下的元素为 [7,5,8,3] 。和的差值为 (7+5) - (8+3) = 1 。\n观察可知，最优答案为 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == 3 * n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2164.对奇偶下标分别排序",
        "hardRate": "EASY",
        "passRate": "68.54%",
        "problemsUrl": "https://leetcode.cn/problems/sort-even-and-odd-indices-independently/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-even-and-odd-indices-independently/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。根据下述规则重排 <code>nums</code> 中的值：</p>\n\n<ol>\n\t<li>按 <strong>非递增</strong> 顺序排列 <code>nums</code> <strong>奇数下标</strong> 上的所有值。\n\n\t<ul>\n\t\t<li>举个例子，如果排序前 <code>nums = [4,<em><strong>1</strong></em>,2,<em><strong>3</strong></em>]</code> ，对奇数下标的值排序后变为 <code>[4,<em><strong>3</strong></em>,2,<em><strong>1</strong></em>]</code> 。奇数下标 <code>1</code> 和 <code>3</code> 的值按照非递增顺序重排。</li>\n\t</ul>\n\t</li>\n\t<li>按 <strong>非递减</strong> 顺序排列 <code>nums</code> <strong>偶数下标</strong> 上的所有值。\n\t<ul>\n\t\t<li>举个例子，如果排序前 <code>nums = [<em><strong>4</strong></em>,1,<em><strong>2</strong></em>,3]</code> ，对偶数下标的值排序后变为 <code>[<em><strong>2</strong></em>,1,<em><strong>4</strong></em>,3]</code> 。偶数下标 <code>0</code> 和 <code>2</code> 的值按照非递减顺序重排。</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>返回重排 <code>nums</code> 的值之后形成的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,1,2,3]\n<strong>输出：</strong>[2,3,4,1]\n<strong>解释：</strong>\n首先，按非递增顺序重排奇数下标（1 和 3）的值。\n所以，nums 从 [4,<em><strong>1</strong></em>,2,<em><strong>3</strong></em>] 变为 [4,<em><strong>3</strong></em>,2,<em><strong>1</strong></em>] 。\n然后，按非递减顺序重排偶数下标（0 和 2）的值。\n所以，nums 从 [<em><strong>4</strong></em>,1,<em><strong>2</strong></em>,3] 变为 [<em><strong>2</strong></em>,3,<em><strong>4</strong></em>,1] 。\n因此，重排之后形成的数组是 [2,3,4,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1]\n<strong>输出：</strong>[2,1]\n<strong>解释：</strong>\n由于只有一个奇数下标和一个偶数下标，所以不会发生重排。\n形成的结果数组是 [2,1] ，和初始数组一样。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2165.重排数字的最小值",
        "hardRate": "MEDIUM",
        "passRate": "55.14%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-value-of-the-rearranged-number/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-value-of-the-rearranged-number/solution",
        "problemsDesc": "<p>给你一个整数 <code>num</code> 。<strong>重排</strong> <code>num</code> 中的各位数字，使其值 <strong>最小化</strong> 且不含 <strong>任何</strong> 前导零。</p>\n\n<p>返回不含前导零且值最小的重排数字。</p>\n\n<p>注意，重排各位数字后，<code>num</code> 的符号不会改变。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 310\n<strong>输出：</strong>103\n<strong>解释：</strong>310 中各位数字的可行排列有：013、031、103、130、301、310 。\n不含任何前导零且值最小的重排数字是 103 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = -7605\n<strong>输出：</strong>-7650\n<strong>解释：</strong>-7605 中各位数字的部分可行排列为：-7650、-6705、-5076、-0567。\n不含任何前导零且值最小的重排数字是 -7650 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-10<sup>15</sup> &lt;= num &lt;= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2166.设计位集",
        "hardRate": "MEDIUM",
        "passRate": "30.72%",
        "problemsUrl": "https://leetcode.cn/problems/design-bitset/",
        "solutionsUrl": "https://leetcode.cn/problems/design-bitset/solution",
        "problemsDesc": "<p><strong>位集 Bitset</strong> 是一种能以紧凑形式存储位的数据结构。</p>\n\n<p>请你实现 <code>Bitset</code> 类。</p>\n\n<ul>\n\t<li><code>Bitset(int size)</code> 用 <code>size</code> 个位初始化 Bitset ，所有位都是 <code>0</code> 。</li>\n\t<li><code>void fix(int idx)</code> 将下标为 <code>idx</code> 的位上的值更新为 <code>1</code> 。如果值已经是 <code>1</code> ，则不会发生任何改变。</li>\n\t<li><code>void unfix(int idx)</code> 将下标为 <code>idx</code> 的位上的值更新为 <code>0</code> 。如果值已经是 <code>0</code> ，则不会发生任何改变。</li>\n\t<li><code>void flip()</code> 翻转 Bitset 中每一位上的值。换句话说，所有值为 <code>0</code> 的位将会变成 <code>1</code> ，反之亦然。</li>\n\t<li><code>boolean all()</code> 检查&nbsp;Bitset 中 <strong>每一位</strong> 的值是否都是 <code>1</code> 。如果满足此条件，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n\t<li><code>boolean one()</code> 检查&nbsp;Bitset 中 是否&nbsp;<strong>至少一位</strong> 的值是 <code>1</code> 。如果满足此条件，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n\t<li><code>int count()</code> 返回 Bitset 中值为 1 的位的 <strong>总数</strong> 。</li>\n\t<li><code>String toString()</code> 返回 Bitset 的当前组成情况。注意，在结果字符串中，第 <code>i</code> 个下标处的字符应该与 Bitset 中的第 <code>i</code> 位一致。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"Bitset\", \"fix\", \"fix\", \"flip\", \"all\", \"unfix\", \"flip\", \"one\", \"unfix\", \"count\", \"toString\"]\n[[5], [3], [1], [], [], [0], [], [], [0], [], []]\n<strong>输出</strong>\n[null, null, null, null, false, null, null, true, null, 2, \"01010\"]\n\n<strong>解释</strong>\nBitset bs = new Bitset(5); // bitset = \"00000\".\nbs.fix(3);     // 将 idx = 3 处的值更新为 1 ，此时 bitset = \"00010\" 。\nbs.fix(1);     // 将 idx = 1 处的值更新为 1 ，此时 bitset = \"01010\" 。\nbs.flip();     // 翻转每一位上的值，此时 bitset = \"10101\" 。\nbs.all();      // 返回 False ，bitset 中的值不全为 1 。\nbs.unfix(0);   // 将 idx = 0 处的值更新为 0 ，此时 bitset = \"00101\" 。\nbs.flip();     // 翻转每一位上的值，此时 bitset = \"11010\" 。\nbs.one();      // 返回 True ，至少存在一位的值为 1 。\nbs.unfix(0);   // 将 idx = 0 处的值更新为 0 ，此时 bitset = \"01010\" 。\nbs.count();    // 返回 2 ，当前有 2 位的值为 1 。\nbs.toString(); // 返回 \"01010\" ，即 bitset 的当前组成情况。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= size &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= idx &lt;= size - 1</code></li>\n\t<li>至多调用&nbsp;<code>fix</code>、<code>unfix</code>、<code>flip</code>、<code>all</code>、<code>one</code>、<code>count</code> 和 <code>toString</code> 方法 <strong>总共</strong> <code>10<sup>5</sup></code> 次</li>\n\t<li>至少调用 <code>all</code>、<code>one</code>、<code>count</code> 或 <code>toString</code> 方法一次</li>\n\t<li>至多调用&nbsp;<code>toString</code> 方法 <code>5</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2167.移除所有载有违禁货物车厢所需的最少时间",
        "hardRate": "HARD",
        "passRate": "49.21%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二进制字符串 <code>s</code> ，表示一个列车车厢序列。<code>s[i] = '0'</code> 表示第 <code>i</code> 节车厢 <strong>不</strong> 含违禁货物，而 <code>s[i] = '1'</code> 表示第 <code>i</code> 节车厢含违禁货物。</p>\n\n<p>作为列车长，你需要清理掉所有载有违禁货物的车厢。你可以不限次数执行下述三种操作中的任意一个：</p>\n\n<ol>\n\t<li>从列车 <strong>左</strong> 端移除一节车厢（即移除 <code>s[0]</code>），用去 1 单位时间。</li>\n\t<li>从列车 <strong>右</strong> 端移除一节车厢（即移除 <code>s[s.length - 1]</code>），用去 1 单位时间。</li>\n\t<li>从列车车厢序列的 <strong>任意位置</strong> 移除一节车厢，用去 2 单位时间。</li>\n</ol>\n\n<p>返回移除所有载有违禁货物车厢所需要的 <strong>最少</strong> 单位时间数。</p>\n\n<p>注意，空的列车车厢序列视为没有车厢含违禁货物。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"<em><strong>11</strong></em>00<em><strong>1</strong></em>0<em><strong>1</strong></em>\"\n<strong>输出：</strong>5\n<strong>解释：</strong>\n一种从序列中移除所有载有违禁货物的车厢的方法是：\n- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。\n- 从右端移除一节车厢 1 次。所用时间是 1 。\n- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。\n总时间是 2 + 1 + 2 = 5 。\n\n一种替代方法是：\n- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。\n- 从右端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。\n总时间也是 2 + 3 = 5 。\n\n5 是移除所有载有违禁货物的车厢所需要的最少单位时间数。\n没有其他方法能够用更少的时间移除这些车厢。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"00<em><strong>1</strong></em>0\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\n一种从序列中移除所有载有违禁货物的车厢的方法是：\n- 从左端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。\n总时间是 3.\n\n另一种从序列中移除所有载有违禁货物的车厢的方法是：\n- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。\n总时间是 2.\n\n另一种从序列中移除所有载有违禁货物的车厢的方法是：\n- 从右端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。\n总时间是 2.\n\n2 是移除所有载有违禁货物的车厢所需要的最少单位时间数。\n没有其他方法能够用更少的时间移除这些车厢。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2168.每个数字的频率都相同的独特子字符串的数量",
        "hardRate": "MEDIUM",
        "passRate": "63.17%",
        "problemsUrl": "https://leetcode.cn/problems/unique-substrings-with-equal-digit-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-substrings-with-equal-digit-frequency/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2169.得到 0 的操作数",
        "hardRate": "EASY",
        "passRate": "73.61%",
        "problemsUrl": "https://leetcode.cn/problems/count-operations-to-obtain-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/count-operations-to-obtain-zero/solution",
        "problemsDesc": "<p>给你两个 <strong>非负</strong> 整数 <code>num1</code> 和 <code>num2</code> 。</p>\n\n<p>每一步 <strong>操作</strong>&nbsp;中，如果 <code>num1 &gt;= num2</code> ，你必须用 <code>num1</code> 减 <code>num2</code> ；否则，你必须用 <code>num2</code> 减 <code>num1</code> 。</p>\n\n<ul>\n\t<li>例如，<code>num1 = 5</code> 且 <code>num2 = 4</code> ，应该用&nbsp;<code>num1</code> 减 <code>num2</code> ，因此，得到 <code>num1 = 1</code> 和 <code>num2 = 4</code> 。然而，如果 <code>num1 = 4</code>且 <code>num2 = 5</code> ，一步操作后，得到 <code>num1 = 4</code> 和 <code>num2 = 1</code> 。</li>\n</ul>\n\n<p>返回使 <code>num1 = 0</code> 或 <code>num2 = 0</code> 的 <strong>操作数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = 2, num2 = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>\n- 操作 1 ：num1 = 2 ，num2 = 3 。由于 num1 &lt; num2 ，num2 减 num1 得到 num1 = 2 ，num2 = 3 - 2 = 1 。\n- 操作 2 ：num1 = 2 ，num2 = 1 。由于 num1 &gt; num2 ，num1 减 num2 。\n- 操作 3 ：num1 = 1 ，num2 = 1 。由于 num1 == num2 ，num1 减 num2 。\n此时 num1 = 0 ，num2 = 1 。由于 num1 == 0 ，不需要再执行任何操作。\n所以总操作数是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = 10, num2 = 10\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 操作 1 ：num1 = 10 ，num2 = 10 。由于 num1 == num2 ，num1 减 num2 得到 num1 = 10 - 10 = 0 。\n此时 num1 = 0 ，num2 = 10 。由于 num1 == 0 ，不需要再执行任何操作。\n所以总操作数是 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num1, num2 &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2170.使数组变成交替数组的最少操作数",
        "hardRate": "MEDIUM",
        "passRate": "31.21%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-alternating/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-alternating/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，该数组由 <code>n</code> 个正整数组成。</p>\n\n<p>如果满足下述条件，则数组 <code>nums</code> 是一个 <strong>交替数组</strong> ：</p>\n\n<ul>\n\t<li><code>nums[i - 2] == nums[i]</code> ，其中 <code>2 &lt;= i &lt;= n - 1</code> 。</li>\n\t<li><code>nums[i - 1] != nums[i]</code> ，其中 <code>1 &lt;= i &lt;= n - 1</code> 。</li>\n</ul>\n\n<p>在一步 <strong>操作</strong> 中，你可以选择下标 <code>i</code> 并将 <code>nums[i]</code> <strong>更改</strong> 为 <strong>任一</strong> 正整数。</p>\n\n<p>返回使数组变成交替数组的 <strong>最少操作数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,3,2,4,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n使数组变成交替数组的方法之一是将该数组转换为 [3,1,3,<em><strong>1</strong></em>,<em><strong>3</strong></em>,<em><strong>1</strong></em>] 。\n在这种情况下，操作数为 3 。\n可以证明，操作数少于 3 的情况下，无法使数组变成交替数组。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,2,2]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n使数组变成交替数组的方法之一是将该数组转换为 [1,2,<em><strong>1</strong></em>,2,<em><strong>1</strong></em>].\n在这种情况下，操作数为 2 。\n注意，数组不能转换成 [<em><strong>2</strong></em>,2,2,2,2] 。因为在这种情况下，nums[0] == nums[1]，不满足交替数组的条件。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2171.拿出最少数目的魔法豆",
        "hardRate": "MEDIUM",
        "passRate": "40.41%",
        "problemsUrl": "https://leetcode.cn/problems/removing-minimum-number-of-magic-beans/",
        "solutionsUrl": "https://leetcode.cn/problems/removing-minimum-number-of-magic-beans/solution",
        "problemsDesc": "<p>给你一个 <strong>正</strong>&nbsp;整数数组&nbsp;<code>beans</code>&nbsp;，其中每个整数表示一个袋子里装的魔法豆的数目。</p>\n\n<p>请你从每个袋子中&nbsp;<strong>拿出</strong>&nbsp;一些豆子（也可以<strong>&nbsp;不拿出</strong>），使得剩下的 <strong>非空</strong> 袋子中（即 <strong>至少</strong>&nbsp;还有 <strong>一颗</strong>&nbsp;魔法豆的袋子）魔法豆的数目&nbsp;<strong>相等</strong>&nbsp;。一旦魔法豆从袋子中取出，你不能将它放到任何其他的袋子中。</p>\n\n<p>请你返回你需要拿出魔法豆的 <strong>最少数目</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>beans = [4,<em><strong>1</strong></em>,6,5]\n<b>输出：</b>4\n<b>解释：</b>\n- 我们从有 1 个魔法豆的袋子中拿出 1 颗魔法豆。\n  剩下袋子中魔法豆的数目为：[4,<em><b>0</b></em>,6,5]\n- 然后我们从有 6 个魔法豆的袋子中拿出 2 个魔法豆。\n  剩下袋子中魔法豆的数目为：[4,0,<em><strong>4</strong></em>,5]\n- 然后我们从有 5 个魔法豆的袋子中拿出 1 个魔法豆。\n  剩下袋子中魔法豆的数目为：[4,0,4,<em><b>4</b></em>]\n总共拿出了 1 + 2 + 1 = 4 个魔法豆，剩下非空袋子中魔法豆的数目相等。\n没有比取出 4 个魔法豆更少的方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>beans = [<em><strong>2</strong></em>,10,<em><strong>3</strong></em>,<em><strong>2</strong></em>]\n<b>输出：</b>7\n<strong>解释：</strong>\n- 我们从有 2 个魔法豆的其中一个袋子中拿出 2 个魔法豆。\n  剩下袋子中魔法豆的数目为：[<em><strong>0</strong></em>,10,3,2]\n- 然后我们从另一个有 2 个魔法豆的袋子中拿出 2 个魔法豆。\n  剩下袋子中魔法豆的数目为：[0,10,3,<em><strong>0</strong></em>]\n- 然后我们从有 3 个魔法豆的袋子中拿出 3 个魔法豆。\n  剩下袋子中魔法豆的数目为：[0,10,<em><strong>0</strong></em>,0]\n总共拿出了 2 + 2 + 3 = 7 个魔法豆，剩下非空袋子中魔法豆的数目相等。\n没有比取出 7 个魔法豆更少的方案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beans.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= beans[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2172.数组的最大与和",
        "hardRate": "HARD",
        "passRate": "50.74%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-and-sum-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-and-sum-of-array/solution",
        "problemsDesc": "<p>给你一个长度为&nbsp;<code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>numSlots</code>&nbsp;，满足<code>2 * numSlots &gt;= n</code>&nbsp;。总共有&nbsp;<code>numSlots</code>&nbsp;个篮子，编号为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>numSlots</code>&nbsp;。</p>\n\n<p>你需要把所有&nbsp;<code>n</code>&nbsp;个整数分到这些篮子中，且每个篮子 <strong>至多</strong>&nbsp;有 2 个整数。一种分配方案的 <strong>与和</strong>&nbsp;定义为每个数与它所在篮子编号的 <strong>按位与运算</strong>&nbsp;结果之和。</p>\n\n<ul>\n\t<li>比方说，将数字&nbsp;<code>[1, 3]</code>&nbsp;放入篮子&nbsp;<strong><em><code>1</code></em></strong>&nbsp;中，<code>[4, 6]</code> 放入篮子&nbsp;<strong><em><code>2</code></em></strong>&nbsp;中，这个方案的与和为&nbsp;<code>(1 AND <strong><em>1</em></strong>) + (3 AND <strong><em>1</em></strong>) + (4 AND <em><strong>2</strong></em>) + (6 AND <em><strong>2</strong></em>) = 1 + 1 + 0 + 2 = 4</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回将 <code>nums</code>&nbsp;中所有数放入<em>&nbsp;</em><code>numSlots</code>&nbsp;个篮子中的最大与和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4,5,6], numSlots = 3\n<b>输出：</b>9\n<b>解释：</b>一个可行的方案是 [1, 4] 放入篮子 <em><strong>1</strong></em>&nbsp;中，[2, 6] 放入篮子 <strong><em>2</em></strong>&nbsp;中，[3, 5] 放入篮子 <strong><em>3</em></strong> 中。\n最大与和为 (1 AND <strong><em>1</em></strong>) + (4 AND <strong><em>1</em></strong>) + (2 AND <strong><em>2</em></strong>) + (6 AND <strong><em>2</em></strong>) + (3 AND <strong><em>3</em></strong>) + (5 AND <em><strong>3</strong></em>) = 1 + 0 + 2 + 2 + 3 + 1 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,10,4,7,1], numSlots = 9\n<b>输出：</b>24\n<b>解释：</b>一个可行的方案是 [1, 1] 放入篮子 <em><strong>1</strong></em> 中，[3] 放入篮子 <em><strong>3</strong></em> 中，[4] 放入篮子 <strong><em>4</em></strong> 中，[7] 放入篮子 <strong><em>7</em></strong> 中，[10] 放入篮子 <strong><em>9</em></strong>&nbsp;中。\n最大与和为 (1 AND <strong><em>1</em></strong>) + (1 AND <strong><em>1</em></strong>) + (3 AND <strong><em>3</em></strong>) + (4 AND <strong><em>4</em></strong>) + (7 AND <strong><em>7</em></strong>) + (10 AND <strong><em>9</em></strong>) = 1 + 1 + 3 + 4 + 7 + 8 = 24 。\n注意，篮子 2 ，5 ，6 和 8 是空的，这是允许的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= numSlots &lt;= 9</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * numSlots</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2173.最多连胜的次数",
        "hardRate": "HARD",
        "passRate": "56.59%",
        "problemsUrl": "https://leetcode.cn/problems/longest-winning-streak/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-winning-streak/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2174.通过翻转行或列来去除所有的 1 II",
        "hardRate": "MEDIUM",
        "passRate": "66.67%",
        "problemsUrl": "https://leetcode.cn/problems/remove-all-ones-with-row-and-column-flips-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-all-ones-with-row-and-column-flips-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2175.世界排名的变化",
        "hardRate": "MEDIUM",
        "passRate": "54.89%",
        "problemsUrl": "https://leetcode.cn/problems/the-change-in-global-rankings/",
        "solutionsUrl": "https://leetcode.cn/problems/the-change-in-global-rankings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2176.统计数组中相等且可以被整除的数对",
        "hardRate": "EASY",
        "passRate": "78.84%",
        "problemsUrl": "https://leetcode.cn/problems/count-equal-and-divisible-pairs-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/count-equal-and-divisible-pairs-in-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，请你返回满足&nbsp;<code>0 &lt;= i &lt; j &lt; n</code>&nbsp;，<code>nums[i] == nums[j]</code> 且&nbsp;<code>(i * j)</code>&nbsp;能被&nbsp;<code>k</code>&nbsp;整除的数对&nbsp;<code>(i, j)</code>&nbsp;的&nbsp;<strong>数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,1,2,2,2,1,3], k = 2\n<b>输出：</b>4\n<strong>解释：</strong>\n总共有 4 对数符合所有要求：\n- nums[0] == nums[6] 且 0 * 6 == 0 ，能被 2 整除。\n- nums[2] == nums[3] 且 2 * 3 == 6 ，能被 2 整除。\n- nums[2] == nums[4] 且 2 * 4 == 8 ，能被 2 整除。\n- nums[3] == nums[4] 且 3 * 4 == 12 ，能被 2 整除。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4], k = 1\n<b>输出：</b>0\n<b>解释：</b>由于数组中没有重复数值，所以没有数对 (i,j) 符合所有要求。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2177.找到和为给定整数的三个连续整数",
        "hardRate": "MEDIUM",
        "passRate": "69.89%",
        "problemsUrl": "https://leetcode.cn/problems/find-three-consecutive-integers-that-sum-to-a-given-number/",
        "solutionsUrl": "https://leetcode.cn/problems/find-three-consecutive-integers-that-sum-to-a-given-number/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>num</code>&nbsp;，请你返回三个连续的整数，它们的&nbsp;<strong>和</strong>&nbsp;为<em>&nbsp;</em><code>num</code>&nbsp;。如果&nbsp;<code>num</code>&nbsp;无法被表示成三个连续整数的和，请你返回一个 <strong>空</strong>&nbsp;数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>num = 33\n<b>输出：</b>[10,11,12]\n<b>解释：</b>33 可以表示为 10 + 11 + 12 = 33 。\n10, 11, 12 是 3 个连续整数，所以返回 [10, 11, 12] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>num = 4\n<b>输出：</b>[]\n<b>解释：</b>没有办法将 4 表示成 3 个连续整数的和。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2178.拆分成最多数目的正偶数之和",
        "hardRate": "MEDIUM",
        "passRate": "56.52%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-split-of-positive-even-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-split-of-positive-even-integers/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>finalSum</code>&nbsp;。请你将它拆分成若干个&nbsp;<strong>互不相同</strong> 的正偶数之和，且拆分出来的正偶数数目&nbsp;<strong>最多</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，给你&nbsp;<code>finalSum = 12</code>&nbsp;，那么这些拆分是&nbsp;<strong>符合要求</strong> 的（互不相同的正偶数且和为&nbsp;<code>finalSum</code>）：<code>(2 + 10)</code>&nbsp;，<code>(2 + 4 + 6)</code>&nbsp;和&nbsp;<code>(4 + 8)</code>&nbsp;。它们中，<code>(2 + 4 + 6)</code>&nbsp;包含最多数目的整数。注意&nbsp;<code>finalSum</code>&nbsp;不能拆分成&nbsp;<code>(2 + 2 + 4 + 4)</code>&nbsp;，因为拆分出来的整数必须互不相同。</li>\n</ul>\n\n<p>请你返回一个整数数组，表示将整数拆分成 <strong>最多</strong> 数目的正偶数数组。如果没有办法将&nbsp;<code>finalSum</code>&nbsp;进行拆分，请你返回一个&nbsp;<strong>空</strong>&nbsp;数组。你可以按 <b>任意</b>&nbsp;顺序返回这些整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>finalSum = 12\n<b>输出：</b>[2,4,6]\n<b>解释：</b>以下是一些符合要求的拆分：<code>(2 + 10)<span style=\"\">，</span></code><code>(2 + 4 + 6) </code>和 <code>(4 + 8) 。</code>\n(2 + 4 + 6) 为最多数目的整数，数目为 3 ，所以我们返回 [2,4,6] 。\n[2,6,4] ，[6,2,4] 等等也都是可行的解。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>finalSum = 7\n<b>输出：</b>[]\n<b>解释：</b>没有办法将 finalSum 进行拆分。\n所以返回空数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>finalSum = 28\n<b>输出：</b>[6,8,2,12]\n<b>解释：</b>以下是一些符合要求的拆分：<code>(2 + 26)<span style=\"\">，</span></code><code>(6 + 8 + 2 + 12)</code> 和 <code>(4 + 24) 。</code>\n<code>(6 + 8 + 2 + 12)</code> 有最多数目的整数，数目为 4 ，所以我们返回 [6,8,2,12] 。\n[10,2,4,12] ，[6,2,4,16] 等等也都是可行的解。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= finalSum &lt;= 10<sup>10</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2179.统计数组中好三元组数目",
        "hardRate": "HARD",
        "passRate": "37.39%",
        "problemsUrl": "https://leetcode.cn/problems/count-good-triplets-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/count-good-triplets-in-an-array/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始且长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;，两者都是&nbsp;<code>[0, 1, ..., n - 1]</code>&nbsp;的&nbsp;<strong>排列</strong>&nbsp;。</p>\n\n<p><strong>好三元组&nbsp;</strong>指的是&nbsp;<code>3</code>&nbsp;个&nbsp;<strong>互不相同</strong>&nbsp;的值，且它们在数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;中出现顺序保持一致。换句话说，如果我们将&nbsp;<code>pos1<sub>v</sub></code> 记为值&nbsp;<code>v</code>&nbsp;在&nbsp;<code>nums1</code>&nbsp;中出现的位置，<code>pos2<sub>v</sub></code>&nbsp;为值&nbsp;<code>v</code>&nbsp;在&nbsp;<code>nums2</code>&nbsp;中的位置，那么一个好三元组定义为&nbsp;<code>0 &lt;= x, y, z &lt;= n - 1</code>&nbsp;，且&nbsp;<code>pos1<sub>x</sub> &lt; pos1<sub>y</sub> &lt; pos1<sub>z</sub></code> 和&nbsp;<code>pos2<sub>x</sub> &lt; pos2<sub>y</sub> &lt; pos2<sub>z</sub></code>&nbsp;都成立的&nbsp;<code>(x, y, z)</code>&nbsp;。</p>\n\n<p>请你返回好三元组的 <strong>总数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [2,0,1,3], nums2 = [0,1,2,3]\n<b>输出：</b>1\n<b>解释：</b>\n总共有 4 个三元组 (x,y,z) 满足 pos1<sub>x</sub> &lt; pos1<sub>y</sub> &lt; pos1<sub>z&nbsp;</sub>，分别是 (2,0,1) ，(2,0,3) ，(2,1,3) 和 (0,1,3) 。\n这些三元组中，只有 (0,1,3) 满足 pos2<sub>x</sub> &lt; pos2<sub>y</sub> &lt; pos2<sub>z</sub>&nbsp;。所以只有 1 个好三元组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]\n<b>输出：</b>4\n<b>解释：</b>总共有 4 个好三元组 (4,0,3) ，(4,0,2) ，(4,1,3) 和 (4,1,2) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= n - 1</code></li>\n\t<li><code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;是&nbsp;<code>[0, 1, ..., n - 1]</code> 的排列。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2180.统计各位数字之和为偶数的整数个数",
        "hardRate": "EASY",
        "passRate": "67.98%",
        "problemsUrl": "https://leetcode.cn/problems/count-integers-with-even-digit-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/count-integers-with-even-digit-sum/solution",
        "problemsDesc": "<p>给你一个正整数 <code>num</code> ，请你统计并返回 <strong>小于或等于</strong> <code>num</code> 且各位数字之和为 <strong>偶数</strong> 的正整数的数目。</p>\n\n<p>正整数的 <strong>各位数字之和</strong> 是其所有位上的对应数字相加的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>\n只有 2 和 4 满足小于等于 4 且各位数字之和为偶数。    \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 30\n<strong>输出：</strong>14\n<strong>解释：</strong>\n只有 14 个整数满足小于等于 30 且各位数字之和为偶数，分别是： \n2、4、6、8、11、13、15、17、19、20、22、24、26 和 28 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2181.合并零之间的节点",
        "hardRate": "MEDIUM",
        "passRate": "84.75%",
        "problemsUrl": "https://leetcode.cn/problems/merge-nodes-in-between-zeros/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-nodes-in-between-zeros/solution",
        "problemsDesc": "<p>给你一个链表的头节点 <code>head</code> ，该链表包含由 <code>0</code> 分隔开的一连串整数。链表的 <strong>开端</strong> 和 <strong>末尾</strong> 的节点都满足 <code>Node.val == 0</code> 。</p>\n\n<p>对于每两个相邻的 <code>0</code> ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 <code>0</code> 移除，修改后的链表不应该含有任何 <code>0</code> 。</p>\n\n<p>&nbsp;返回修改后链表的头节点 <code>head</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：<br />\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/02/ex1-1.png\" style=\"width: 600px; height: 41px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>head = [0,3,1,0,4,5,2,0]\n<strong>输出：</strong>[4,11]\n<strong>解释：</strong>\n上图表示输入的链表。修改后的链表包含：\n- 标记为绿色的节点之和：3 + 1 = 4\n- 标记为红色的节点之和：4 + 5 + 2 = 11\n</pre>\n\n<p><strong>示例 2：<br />\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/02/ex2-1.png\" style=\"width: 600px; height: 41px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>head = [0,1,0,3,0,2,2,0]\n<strong>输出：</strong>[1,3,4]\n<strong>解释：</strong>\n上图表示输入的链表。修改后的链表包含：\n- 标记为绿色的节点之和：1 = 1\n- 标记为红色的节点之和：3 = 3\n- 标记为黄色的节点之和：2 + 2 = 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>列表中的节点数目在范围 <code>[3, 2 * 10<sup>5</sup>]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><strong>不</strong> 存在连续两个&nbsp;<code>Node.val == 0</code> 的节点</li>\n\t<li>链表的 <strong>开端</strong> 和 <strong>末尾</strong> 节点都满足 <code>Node.val == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2182.构造限制重复的字符串",
        "hardRate": "MEDIUM",
        "passRate": "48.53%",
        "problemsUrl": "https://leetcode.cn/problems/construct-string-with-repeat-limit/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-string-with-repeat-limit/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个整数 <code>repeatLimit</code> ，用 <code>s</code> 中的字符构造一个新字符串 <code>repeatLimitedString</code> ，使任何字母 <strong>连续</strong> 出现的次数都不超过 <code>repeatLimit</code> 次。你不必使用 <code>s</code> 中的全部字符。</p>\n\n<p>返回 <strong>字典序最大的</strong><em> </em><code>repeatLimitedString</code> 。</p>\n\n<p>如果在字符串 <code>a</code> 和 <code>b</code> 不同的第一个位置，字符串 <code>a</code> 中的字母在字母表中出现时间比字符串 <code>b</code> 对应的字母晚，则认为字符串 <code>a</code> 比字符串 <code>b</code> <strong>字典序更大</strong> 。如果字符串中前 <code>min(a.length, b.length)</code> 个字符都相同，那么较长的字符串字典序更大。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"cczazcc\", repeatLimit = 3\n<strong>输出：</strong>\"zzcccac\"\n<strong>解释：</strong>使用 s 中的所有字符来构造 repeatLimitedString \"zzcccac\"。\n字母 'a' 连续出现至多 1 次。\n字母 'c' 连续出现至多 3 次。\n字母 'z' 连续出现至多 2 次。\n因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。\n该字符串是字典序最大的 repeatLimitedString ，所以返回 \"zzcccac\" 。\n注意，尽管 \"zzcccca\" 字典序更大，但字母 'c' 连续出现超过 3 次，所以它不是一个有效的 repeatLimitedString 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"aababab\", repeatLimit = 2\n<strong>输出：</strong>\"bbabaa\"\n<strong>解释：</strong>\n使用 s 中的一些字符来构造 repeatLimitedString \"bbabaa\"。 \n字母 'a' 连续出现至多 2 次。 \n字母 'b' 连续出现至多 2 次。 \n因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。 \n该字符串是字典序最大的 repeatLimitedString ，所以返回 \"bbabaa\" 。 \n注意，尽管 \"bbabaaa\" 字典序更大，但字母 'a' 连续出现超过 2 次，所以它不是一个有效的 repeatLimitedString 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= repeatLimit &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2183.统计可以被 K 整除的下标对数目",
        "hardRate": "HARD",
        "passRate": "28.28%",
        "problemsUrl": "https://leetcode.cn/problems/count-array-pairs-divisible-by-k/",
        "solutionsUrl": "https://leetcode.cn/problems/count-array-pairs-divisible-by-k/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个整数 <code>k</code> ，返回满足下述条件的下标对 <code>(i, j)</code> 的数目：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt;= n - 1</code> 且</li>\n\t<li><code>nums[i] * nums[j]</code> 能被 <code>k</code> 整除。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5], k = 2\n<strong>输出：</strong>7\n<strong>解释：</strong>\n共有 7 对下标的对应积可以被 2 整除：\n(0, 1)、(0, 3)、(1, 2)、(1, 3)、(1, 4)、(2, 3) 和 (3, 4)\n它们的积分别是 2、4、6、8、10、12 和 20 。\n其他下标对，例如 (0, 2) 和 (2, 4) 的乘积分别是 3 和 15 ，都无法被 2 整除。    \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4], k = 5\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在对应积可以被 5 整除的下标对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2184.建造坚实的砖墙的方法数",
        "hardRate": "MEDIUM",
        "passRate": "55.17%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-build-sturdy-brick-wall/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-build-sturdy-brick-wall/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2185.统计包含给定前缀的字符串",
        "hardRate": "EASY",
        "passRate": "81.58%",
        "problemsUrl": "https://leetcode.cn/problems/counting-words-with-a-given-prefix/",
        "solutionsUrl": "https://leetcode.cn/problems/counting-words-with-a-given-prefix/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code> 和一个字符串 <code>pref</code> 。</p>\n\n<p>返回 <code>words</code><em> </em>中以 <code>pref</code> 作为 <strong>前缀</strong> 的字符串的数目。</p>\n\n<p>字符串 <code>s</code> 的 <strong>前缀</strong> 就是&nbsp; <code>s</code> 的任一前导连续字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"pay\",\"<em><strong>at</strong></em>tention\",\"practice\",\"<em><strong>at</strong></em>tend\"], <code>pref </code>= \"at\"\n<strong>输出：</strong>2\n<strong>解释：</strong>以 \"at\" 作为前缀的字符串有两个，分别是：\"<em><strong>at</strong></em>tention\" 和 \"<em><strong>at</strong></em>tend\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"leetcode\",\"win\",\"loops\",\"success\"], <code>pref </code>= \"code\"\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在以 \"code\" 作为前缀的字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length, pref.length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 和 <code>pref</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2186.使两字符串互为字母异位词的最少步骤数",
        "hardRate": "MEDIUM",
        "passRate": "72.65%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/solution",
        "problemsDesc": "<p>给你两个字符串 <code>s</code> 和 <code>t</code> 。在一步操作中，你可以给 <code>s</code> 或者 <code>t</code> 追加 <strong>任一字符</strong> 。</p>\n\n<p>返回使 <code>s</code> 和 <code>t</code> 互为 <strong>字母异位词</strong> 所需的最少步骤数<em>。</em></p>\n\n<p><strong>字母异位词 </strong>指字母相同但是顺序不同（或者相同）的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"<em><strong>lee</strong>t</em>co<em><strong>de</strong></em>\", t = \"co<em><strong>a</strong></em>t<em><strong>s</strong></em>\"\n<strong>输出：</strong>7\n<strong>解释：</strong>\n- 执行 2 步操作，将 \"as\" 追加到 s = \"leetcode\" 中，得到 s = \"leetcode<em><strong>as</strong></em>\" 。\n- 执行 5 步操作，将 \"leede\" 追加到 t = \"coats\" 中，得到 t = \"coats<em><strong>leede</strong></em>\" 。\n\"leetcodeas\" 和 \"coatsleede\" 互为字母异位词。\n总共用去 2 + 5 = 7 步。\n可以证明，无法用少于 7 步操作使这两个字符串互为字母异位词。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"night\", t = \"thing\"\n<strong>输出：</strong>0\n<strong>解释：</strong>给出的字符串已经互为字母异位词。因此，不需要任何进一步操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和 <code>t</code> 由小写英文字符组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2187.完成旅途的最少时间",
        "hardRate": "MEDIUM",
        "passRate": "28.41%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-complete-trips/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-complete-trips/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>time</code>&nbsp;，其中&nbsp;<code>time[i]</code>&nbsp;表示第 <code>i</code>&nbsp;辆公交车完成 <strong>一趟</strong><strong>旅途</strong>&nbsp;所需要花费的时间。</p>\n\n<p>每辆公交车可以 <strong>连续</strong> 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 <strong>立马开始</strong>&nbsp;下一趟旅途。每辆公交车 <strong>独立</strong>&nbsp;运行，也就是说可以同时有多辆公交车在运行且互不影响。</p>\n\n<p>给你一个整数&nbsp;<code>totalTrips</code>&nbsp;，表示所有公交车&nbsp;<strong>总共</strong>&nbsp;需要完成的旅途数目。请你返回完成 <strong>至少</strong>&nbsp;<code>totalTrips</code>&nbsp;趟旅途需要花费的 <strong>最少</strong>&nbsp;时间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>time = [1,2,3], totalTrips = 5\n<b>输出：</b>3\n<strong>解释：</strong>\n- 时刻 t = 1 ，每辆公交车完成的旅途数分别为 [1,0,0] 。\n  已完成的总旅途数为 1 + 0 + 0 = 1 。\n- 时刻 t = 2 ，每辆公交车完成的旅途数分别为 [2,1,0] 。\n  已完成的总旅途数为 2 + 1 + 0 = 3 。\n- 时刻 t = 3 ，每辆公交车完成的旅途数分别为 [3,1,1] 。\n  已完成的总旅途数为 3 + 1 + 1 = 5 。\n所以总共完成至少 5 趟旅途的最少时间为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>time = [2], totalTrips = 1\n<b>输出：</b>2\n<strong>解释：</strong>\n只有一辆公交车，它将在时刻 t = 2 完成第一趟旅途。\n所以完成 1 趟旅途的最少时间为 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= time.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= time[i], totalTrips &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2188.完成比赛的最少时间",
        "hardRate": "HARD",
        "passRate": "44.34%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-finish-the-race/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-finish-the-race/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>tires</code>&nbsp;，其中&nbsp;<code>tires[i] = [f<sub>i</sub>, r<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;种轮胎如果连续使用，第&nbsp;<code>x</code>&nbsp;圈需要耗时&nbsp;<code>f<sub>i</sub> * r<sub>i</sub><sup>(x-1)</sup></code>&nbsp;秒。</p>\n\n<ul>\n\t<li>比方说，如果&nbsp;<code>f<sub>i</sub> = 3</code>&nbsp;且&nbsp;<code>r<sub>i</sub> = 2</code>&nbsp;，且一直使用这种类型的同一条轮胎，那么该轮胎完成第&nbsp;<code>1</code>&nbsp;圈赛道耗时 <code>3</code>&nbsp;秒，完成第 <code>2</code>&nbsp;圈耗时&nbsp;<code>3 * 2 = 6</code>&nbsp;秒，完成第 <code>3</code>&nbsp;圈耗时&nbsp;<code>3 * 2<sup>2</sup> = 12</code>&nbsp;秒，依次类推。</li>\n</ul>\n\n<p>同时给你一个整数&nbsp;<code>changeTime</code>&nbsp;和一个整数&nbsp;<code>numLaps</code>&nbsp;。</p>\n\n<p>比赛总共包含&nbsp;<code>numLaps</code>&nbsp;圈，你可以选择 <strong>任意</strong>&nbsp;一种轮胎开始比赛。每一种轮胎都有 <strong>无数条</strong>&nbsp;。每一圈后，你可以选择耗费 <code>changeTime</code>&nbsp;秒 <strong>换成</strong>&nbsp;任意一种轮胎（也可以换成当前种类的新轮胎）。</p>\n\n<p>请你返回完成比赛需要耗费的 <strong>最少</strong>&nbsp;时间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4\n<b>输出：</b>21\n<b>解释：</b>\n第 1 圈：使用轮胎 0 ，耗时 2 秒。\n第 2 圈：继续使用轮胎 0 ，耗时 2 * 3 = 6 秒。\n第 3 圈：耗费 5 秒换一条新的轮胎 0 ，然后耗时 2 秒完成这一圈。\n第 4 圈：继续使用轮胎 0 ，耗时 2 * 3 = 6 秒。\n总耗时 = 2 + 6 + 5 + 2 + 6 = 21 秒。\n完成比赛的最少时间为 21 秒。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5\n<b>输出：</b>25\n<b>解释：</b>\n第 1 圈：使用轮胎 1 ，耗时 2 秒。\n第 2 圈：继续使用轮胎 1 ，耗时 2 * 2 = 4 秒。\n第 3 圈：耗时 6 秒换一条新的轮胎 1 ，然后耗时 2 秒完成这一圈。\n第 4 圈：继续使用轮胎 1 ，耗时 2 * 2 = 4 秒。\n第 5 圈：耗时 6 秒换成轮胎 0 ，然后耗时 1 秒完成这一圈。\n总耗时 = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 秒。\n完成比赛的最少时间为 25 秒。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tires.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>tires[i].length == 2</code></li>\n\t<li><code>1 &lt;= f<sub>i</sub>, changeTime &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= r<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= numLaps &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2189.建造纸牌屋的方法数",
        "hardRate": "MEDIUM",
        "passRate": "64.87%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-build-house-of-cards/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-build-house-of-cards/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2190.数组中紧跟 key 之后出现最频繁的数字",
        "hardRate": "EASY",
        "passRate": "58.70%",
        "problemsUrl": "https://leetcode.cn/problems/most-frequent-number-following-key-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/most-frequent-number-following-key-in-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，同时给你一个整数&nbsp;<code>key</code>&nbsp;，它在&nbsp;<code>nums</code>&nbsp;出现过。</p>\n\n<p><strong>统计&nbsp;</strong>在 <code>nums</code>&nbsp;数组中紧跟着 <code>key</code>&nbsp;后面出现的不同整数&nbsp;<code>target</code>&nbsp;的出现次数。换言之，<code>target</code>&nbsp;的出现次数为满足以下条件的 <code>i</code>&nbsp;的数目：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt;= n - 2</code></li>\n\t<li><code>nums[i] == key</code>&nbsp;且</li>\n\t<li><code>nums[i + 1] == target</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回出现 <strong>最多</strong>&nbsp;次数的<em>&nbsp;</em><code>target</code>&nbsp;。测试数据保证出现次数最多的 <code>target</code>&nbsp;是唯一的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,100,200,1,100], key = 1\n<b>输出：</b>100\n<b>解释：</b>对于 target = 100 ，在下标 1 和 4 处出现过 2 次，且都紧跟着 key 。\n没有其他整数在 key 后面紧跟着出现，所以我们返回 100 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,2,2,2,3], key = 2\n<b>输出：</b>2\n<b>解释：</b>对于 target = 2 ，在下标 1 ，2 和 3 处出现过 3 次，且都紧跟着 key 。\n对于 target = 3 ，在下标 4 出出现过 1 次，且紧跟着 key 。\ntarget = 2 是紧跟着 key 之后出现次数最多的数字，所以我们返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>测试数据保证答案是唯一的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2191.将杂乱无章的数字排序",
        "hardRate": "MEDIUM",
        "passRate": "43.54%",
        "problemsUrl": "https://leetcode.cn/problems/sort-the-jumbled-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-the-jumbled-numbers/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>mapping</code>&nbsp;，它表示一个十进制数的映射规则，<code>mapping[i] = j</code>&nbsp;表示这个规则下将数位&nbsp;<code>i</code>&nbsp;映射为数位 <code>j</code>&nbsp;。</p>\n\n<p>一个整数 <strong>映射后的值</strong>&nbsp;为将原数字每一个数位 <code>i</code>&nbsp;（<code>0 &lt;= i &lt;= 9</code>）映射为&nbsp;<code>mapping[i]</code>&nbsp;。</p>\n\n<p>另外给你一个整数数组&nbsp;<code>nums</code>&nbsp;，请你将数组<em>&nbsp;</em><code>nums</code>&nbsp;中每个数按照它们映射后对应数字非递减顺序排序后返回。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>如果两个数字映射后对应的数字大小相同，则将它们按照输入中的 <strong>相对顺序</strong>&nbsp;排序。</li>\n\t<li><code>nums</code>&nbsp;中的元素只有在排序的时候需要按照映射后的值进行比较，返回的值应该是输入的元素本身。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>mapping = [8,9,4,0,2,1,3,5,7,6], nums = [991,338,38]\n<b>输出：</b>[338,38,991]\n<b>解释：</b>\n将数字 991 按照如下规则映射：\n1. mapping[9] = 6 ，所有数位 9 都会变成 6 。\n2. mapping[1] = 9 ，所有数位 1 都会变成 8 。\n所以，991 映射的值为 669 。\n338 映射为 007 ，去掉前导 0 后得到 7 。\n38 映射为 07 ，去掉前导 0 后得到 7 。\n由于 338 和 38 映射后的值相同，所以它们的前后顺序保留原数组中的相对位置关系，338 在 38 的前面。\n所以，排序后的数组为 [338,38,991] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>mapping = [0,1,2,3,4,5,6,7,8,9], nums = [789,456,123]\n<b>输出：</b>[123,456,789]\n<b>解释：</b>789 映射为 789 ，456 映射为 456 ，123 映射为 123 。所以排序后数组为 [123,456,789] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>mapping.length == 10</code></li>\n\t<li><code>0 &lt;= mapping[i] &lt;= 9</code></li>\n\t<li><code>mapping[i]</code>&nbsp;的值 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt; 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2192.有向无环图中一个节点的所有祖先",
        "hardRate": "MEDIUM",
        "passRate": "45.07%",
        "problemsUrl": "https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>n</code>&nbsp;，它表示一个 <strong>有向无环图</strong>&nbsp;中节点的数目，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;（包括两者）。</p>\n\n<p>给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;表示图中一条从&nbsp;<code>from<sub>i</sub></code>&nbsp;到&nbsp;<code>to<sub>i</sub></code>&nbsp;的单向边。</p>\n\n<p>请你返回一个数组&nbsp;<code>answer</code>，其中<em>&nbsp;</em><code>answer[i]</code>是第&nbsp;<code>i</code>&nbsp;个节点的所有&nbsp;<strong>祖先</strong>&nbsp;，这些祖先节点&nbsp;<strong>升序</strong>&nbsp;排序。</p>\n\n<p>如果 <code>u</code>&nbsp;通过一系列边，能够到达 <code>v</code>&nbsp;，那么我们称节点 <code>u</code>&nbsp;是节点 <code>v</code>&nbsp;的 <strong>祖先</strong>&nbsp;节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/12/e1.png\" style=\"width: 322px; height: 265px;\"></p>\n\n<pre><b>输入：</b>n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\n<b>输出：</b>[[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\n<strong>解释：</strong>\n上图为输入所对应的图。\n- 节点 0 ，1 和 2 没有任何祖先。\n- 节点 3 有 2 个祖先 0 和 1 。\n- 节点 4 有 2 个祖先 0 和 2 。\n- 节点 5 有 3 个祖先 0 ，1 和 3 。\n- 节点 6 有 5 个祖先 0 ，1 ，2 ，3 和 4 。\n- 节点 7 有 4 个祖先 0 ，1 ，2 和 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/12/e2.png\" style=\"width: 343px; height: 299px;\"></p>\n\n<pre><b>输入：</b>n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n<b>输出：</b>[[],[0],[0,1],[0,1,2],[0,1,2,3]]\n<strong>解释：</strong>\n上图为输入所对应的图。\n- 节点 0 没有任何祖先。\n- 节点 1 有 1 个祖先 0 。\n- 节点 2 有 2 个祖先 0 和 1 。\n- 节点 3 有 3 个祖先 0 ，1 和 2 。\n- 节点 4 有 4 个祖先 0 ，1 ，2 和 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= edges.length &lt;= min(2000, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\n\t<li>图中不会有重边。</li>\n\t<li>图是 <strong>有向</strong> 且 <strong>无环</strong> 的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2193.得到回文串的最少操作次数",
        "hardRate": "HARD",
        "passRate": "49.14%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-moves-to-make-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-moves-to-make-palindrome/solution",
        "problemsDesc": "<p>给你一个只包含小写英文字母的字符串&nbsp;<code>s</code>&nbsp;。</p>\n\n<p>每一次 <strong>操作</strong>&nbsp;，你可以选择 <code>s</code>&nbsp;中两个 <strong>相邻</strong>&nbsp;的字符，并将它们交换。</p>\n\n<p>请你返回将 <code>s</code>&nbsp;变成回文串的 <strong>最少操作次数</strong>&nbsp;。</p>\n\n<p><strong>注意</strong>&nbsp;，输入数据会确保&nbsp;<code>s</code>&nbsp;一定能变成一个回文串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"aabb\"\n<b>输出：</b>2\n<strong>解释：</strong>\n我们可以将 s 变成 2 个回文串，\"abba\" 和 \"baab\" 。\n- 我们可以通过 2 次操作得到 \"abba\" ：\"a<em><strong>ab</strong></em>b\" -&gt; \"ab<em><strong>ab</strong></em>\" -&gt; \"abba\" 。\n- 我们可以通过 2 次操作得到 \"baab\" ：\"a<em><strong>ab</strong></em>b\" -&gt; \"<em><strong>ab</strong></em>ab\" -&gt; \"baab\" 。\n因此，得到回文串的最少总操作次数为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"letelt\"\n<b>输出：</b>2\n<strong>解释：</strong>\n通过 2 次操作从 s 能得到回文串 \"lettel\" 。\n其中一种方法是：\"lete<em><strong>lt</strong></em>\" -&gt; \"let<em><strong>et</strong></em>l\" -&gt; \"lettel\" 。\n其他回文串比方说 \"tleelt\" 也可以通过 2 次操作得到。\n可以证明少于 2 次操作，无法得到回文串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>s</code>&nbsp;可以通过有限次操作得到一个回文串。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2194.Excel 表中某个范围内的单元格",
        "hardRate": "EASY",
        "passRate": "84.10%",
        "problemsUrl": "https://leetcode.cn/problems/cells-in-a-range-on-an-excel-sheet/",
        "solutionsUrl": "https://leetcode.cn/problems/cells-in-a-range-on-an-excel-sheet/solution",
        "problemsDesc": "<p>Excel 表中的一个单元格 <code>(r, c)</code> 会以字符串 <code>\"&lt;col&gt;&lt;row&gt;\"</code> 的形式进行表示，其中：</p>\n\n<ul>\n\t<li><code>&lt;col&gt;</code> 即单元格的列号 <code>c</code> 。用英文字母表中的 <strong>字母</strong> 标识。\n\n\t<ul>\n\t\t<li>例如，第 <code>1</code> 列用 <code>'A'</code> 表示，第 <code>2</code> 列用 <code>'B'</code> 表示，第 <code>3</code> 列用 <code>'C'</code> 表示，以此类推。</li>\n\t</ul>\n\t</li>\n\t<li><code>&lt;row&gt;</code> 即单元格的行号 <code>r</code> 。第 <code>r</code> 行就用 <strong>整数</strong> <code>r</code> 标识。</li>\n</ul>\n\n<p>给你一个格式为 <code>\"&lt;col1&gt;&lt;row1&gt;:&lt;col2&gt;&lt;row2&gt;\"</code> 的字符串 <code>s</code> ，其中 <code>&lt;col1&gt;</code> 表示 <code>c1</code> 列，<code>&lt;row1&gt;</code> 表示 <code>r1</code> 行，<code>&lt;col2&gt;</code> 表示 <code>c2</code> 列，<code>&lt;row2&gt;</code> 表示 <code>r2</code> 行，并满足 <code>r1 &lt;= r2</code> 且 <code>c1 &lt;= c2</code> 。</p>\n\n<p>找出所有满足&nbsp;<code>r1 &lt;= x &lt;= r2</code> 且 <code>c1 &lt;= y &lt;= c2</code> 的单元格，并以列表形式返回。单元格应该按前面描述的格式用 <strong>字符串</strong> 表示，并以 <strong>非递减</strong> 顺序排列（先按列排，再按行排）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/08/ex1drawio.png\" style=\"width: 250px; height: 160px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"K1:L2\"\n<strong>输出：</strong>[\"K1\",\"K2\",\"L1\",\"L2\"]\n<strong>解释：</strong>\n上图显示了列表中应该出现的单元格。\n红色箭头指示单元格的出现顺序。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/09/exam2drawio.png\" style=\"width: 500px; height: 50px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"A1:F1\"\n<strong>输出：</strong>[\"A1\",\"B1\",\"C1\",\"D1\",\"E1\",\"F1\"]\n<strong>解释：</strong>\n上图显示了列表中应该出现的单元格。 \n红色箭头指示单元格的出现顺序。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s.length == 5</code></li>\n\t<li><code>'A' &lt;= s[0] &lt;= s[3] &lt;= 'Z'</code></li>\n\t<li><code>'1' &lt;= s[1] &lt;= s[4] &lt;= '9'</code></li>\n\t<li><code>s</code> 由大写英文字母、数字、和 <code>':'</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2195.向数组中追加 K 个整数",
        "hardRate": "MEDIUM",
        "passRate": "24.02%",
        "problemsUrl": "https://leetcode.cn/problems/append-k-integers-with-minimal-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/append-k-integers-with-minimal-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。请你向 <code>nums</code> 中追加 <code>k</code> 个 <strong>未</strong> 出现在 <code>nums</code> 中的、<strong>互不相同</strong> 的 <strong>正</strong> 整数，并使结果数组的元素和 <strong>最小</strong> 。</p>\n\n<p>返回追加到 <code>nums</code> 中的 <code>k</code> 个整数之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,4,25,10,25], k = 2\n<strong>输出：</strong>5\n<strong>解释：</strong>在该解法中，向数组中追加的两个互不相同且未出现的正整数是 2 和 3 。\nnums 最终元素和为 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70 ，这是所有情况中的最小值。\n所以追加到数组中的两个整数之和是 2 + 3 = 5 ，所以返回 5 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,6], k = 6\n<strong>输出：</strong>25\n<strong>解释：</strong>在该解法中，向数组中追加的两个互不相同且未出现的正整数是 1 、2 、3 、4 、7 和 8 。\nnums 最终元素和为 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36 ，这是所有情况中的最小值。\n所以追加到数组中的两个整数之和是 1 + 2 + 3 + 4 + 7 + 8 = 25 ，所以返回 25 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2196.根据描述创建二叉树",
        "hardRate": "MEDIUM",
        "passRate": "72.83%",
        "problemsUrl": "https://leetcode.cn/problems/create-binary-tree-from-descriptions/",
        "solutionsUrl": "https://leetcode.cn/problems/create-binary-tree-from-descriptions/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>descriptions</code> ，其中 <code>descriptions[i] = [parent<sub>i</sub>, child<sub>i</sub>, isLeft<sub>i</sub>]</code> 表示 <code>parent<sub>i</sub></code> 是 <code>child<sub>i</sub></code> 在 <strong>二叉树</strong> 中的 <strong>父节点</strong>，二叉树中各节点的值 <strong>互不相同</strong> 。此外：</p>\n\n<ul>\n\t<li>如果 <code>isLeft<sub>i</sub> == 1</code> ，那么 <code>child<sub>i</sub></code> 就是 <code>parent<sub>i</sub></code> 的左子节点。</li>\n\t<li>如果 <code>isLeft<sub>i</sub> == 0</code> ，那么 <code>child<sub>i</sub></code> 就是 <code>parent<sub>i</sub></code> 的右子节点。</li>\n</ul>\n\n<p>请你根据 <code>descriptions</code> 的描述来构造二叉树并返回其 <strong>根节点</strong> 。</p>\n\n<p>测试用例会保证可以构造出 <strong>有效</strong> 的二叉树。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/09/example1drawio.png\" style=\"width: 300px; height: 236px;\" /></p>\n\n<pre>\n<strong>输入：</strong>descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]\n<strong>输出：</strong>[50,20,80,15,17,19]\n<strong>解释：</strong>根节点是值为 50 的节点，因为它没有父节点。\n结果二叉树如上图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/09/example2drawio.png\" style=\"width: 131px; height: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>descriptions = [[1,2,1],[2,3,0],[3,4,1]]\n<strong>输出：</strong>[1,2,null,null,3,4]\n<strong>解释：</strong>根节点是值为 1 的节点，因为它没有父节点。 \n结果二叉树如上图所示。 </pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= descriptions.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>descriptions[i].length == 3</code></li>\n\t<li><code>1 &lt;= parent<sub>i</sub>, child<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= isLeft<sub>i</sub> &lt;= 1</code></li>\n\t<li><code>descriptions</code> 所描述的二叉树是一棵有效二叉树</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2197.替换数组中的非互质数",
        "hardRate": "HARD",
        "passRate": "34.65%",
        "problemsUrl": "https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。请你对数组执行下述操作：</p>\n\n<ol>\n\t<li>从 <code>nums</code> 中找出 <strong>任意</strong> 两个 <strong>相邻</strong> 的 <strong>非互质</strong> 数。</li>\n\t<li>如果不存在这样的数，<strong>终止</strong> 这一过程。</li>\n\t<li>否则，删除这两个数，并 <strong>替换</strong> 为它们的 <strong>最小公倍数</strong>（Least Common Multiple，LCM）。</li>\n\t<li>只要还能找出两个相邻的非互质数就继续 <strong>重复</strong> 这一过程。</li>\n</ol>\n\n<p>返回修改后得到的 <strong>最终</strong> 数组。可以证明的是，以 <strong>任意</strong> 顺序替换相邻的非互质数都可以得到相同的结果。</p>\n\n<p>生成的测试用例可以保证最终数组中的值 <strong>小于或者等于</strong> <code>10<sup>8</sup></code> 。</p>\n\n<p>两个数字 <code>x</code> 和 <code>y</code> 满足 <strong>非互质数</strong> 的条件是：<code>GCD(x, y) &gt; 1</code> ，其中 <code>GCD(x, y)</code> 是 <code>x</code> 和 <code>y</code> 的 <strong>最大公约数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,4,3,2,7,6,2]\n<strong>输出：</strong>[12,7,6]\n<strong>解释：</strong>\n- (6, 4) 是一组非互质数，且 LCM(6, 4) = 12 。得到 nums = [<em><strong>12</strong></em>,3,2,7,6,2] 。\n- (12, 3) 是一组非互质数，且 LCM(12, 3) = 12 。得到 nums = [<em><strong>12</strong></em>,2,7,6,2] 。\n- (12, 2) 是一组非互质数，且 LCM(12, 2) = 12 。得到 nums = [<em><strong>12</strong></em>,7,6,2] 。\n- (6, 2) 是一组非互质数，且 LCM(6, 2) = 6 。得到 nums = [12,7,<em><strong>6</strong></em>] 。\n现在，nums 中不存在相邻的非互质数。\n因此，修改后得到的最终数组是 [12,7,6] 。\n注意，存在其他方法可以获得相同的最终数组。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,1,1,3,3,3]\n<strong>输出：</strong>[2,1,1,3]\n<strong>解释：</strong>\n- (3, 3) 是一组非互质数，且 LCM(3, 3) = 3 。得到 nums = [2,2,1,1,<em><strong>3</strong></em>,3] 。\n- (3, 3) 是一组非互质数，且 LCM(3, 3) = 3 。得到 nums = [2,2,1,1,<em><strong>3</strong></em>] 。\n- (2, 2) 是一组非互质数，且 LCM(2, 2) = 2 。得到 nums = [<em><strong>2</strong></em>,1,1,3] 。\n现在，nums 中不存在相邻的非互质数。 \n因此，修改后得到的最终数组是 [2,1,1,3] 。 \n注意，存在其他方法可以获得相同的最终数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li>生成的测试用例可以保证最终数组中的值 <strong>小于或者等于</strong> <code>10<sup>8</sup></code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2198.单因数三元组",
        "hardRate": "MEDIUM",
        "passRate": "57.53%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-single-divisor-triplets/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-single-divisor-triplets/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2199.找到每篇文章的主题",
        "hardRate": "HARD",
        "passRate": "59.48%",
        "problemsUrl": "https://leetcode.cn/problems/finding-the-topic-of-each-post/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-the-topic-of-each-post/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2200.找出数组中的所有 K 近邻下标",
        "hardRate": "EASY",
        "passRate": "53.77%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-k-distant-indices-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-k-distant-indices-in-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和两个整数 <code>key</code> 和 <code>k</code> 。<strong>K 近邻下标</strong> 是 <code>nums</code> 中的一个下标 <code>i</code> ，并满足至少存在一个下标 <code>j</code> 使得 <code>|i - j| &lt;= k</code> 且 <code>nums[j] == key</code> 。</p>\n\n<p>以列表形式返回按 <strong>递增顺序</strong> 排序的所有 K 近邻下标。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,9,1,3,9,5], key = 9, k = 1\n<strong>输出：</strong>[1,2,3,4,5,6]\n<strong>解释：</strong>因此，<code>nums[2] == key</code> 且 <code>nums[5] == key 。\n- 对下标 0 ，|0 - 2| &gt; k 且 |0 - 5| &gt; k ，所以不存在 j</code> 使得 <code>|0 - j| &lt;= k</code> 且 <code>nums[j] == key 。所以 0 不是一个 K 近邻下标。\n- 对下标 1 ，|1 - 2| &lt;= k 且 nums[2] == key ，所以 1 是一个 K 近邻下标。\n- 对下标 2 ，|2 - 2| &lt;= k 且 nums[2] == key ，所以 2 是一个 K 近邻下标。\n- 对下标 3 ，|3 - 2| &lt;= k 且 nums[2] == key ，所以 3 是一个 K 近邻下标。\n- 对下标 4 ，|4 - 5| &lt;= k 且 nums[5] == key ，所以 4 是一个 K 近邻下标。\n- 对下标 5 ，|5 - 5| &lt;= k 且 nums[5] == key ，所以 5 是一个 K 近邻下标。\n- 对下标 6 ，|6 - 5| &lt;= k 且 nums[5] == key ，所以 6 是一个 K 近邻下标。\n</code>因此，按递增顺序返回 [1,2,3,4,5,6] 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,2,2,2], key = 2, k = 2\n<strong>输出：</strong>[0,1,2,3,4]\n<strong>解释：</strong>对 nums 的所有下标 i ，总存在某个下标 j 使得 |i - j| &lt;= k 且 nums[j] == key ，所以每个下标都是一个 <code>K 近邻下标。</code> \n因此，返回 [0,1,2,3,4] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>key</code> 是数组 <code>nums</code> 中的一个整数</li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2201.统计可以提取的工件",
        "hardRate": "MEDIUM",
        "passRate": "49.40%",
        "problemsUrl": "https://leetcode.cn/problems/count-artifacts-that-can-be-extracted/",
        "solutionsUrl": "https://leetcode.cn/problems/count-artifacts-that-can-be-extracted/solution",
        "problemsDesc": "<p>存在一个 <code>n x n</code> 大小、下标从 <strong>0</strong> 开始的网格，网格中埋着一些工件。给你一个整数 <code>n</code> 和一个下标从 <strong>0</strong> 开始的二维整数数组 <code>artifacts</code> ，<code>artifacts</code> 描述了矩形工件的位置，其中 <code>artifacts[i] = [r1<sub>i</sub>, c1<sub>i</sub>, r2<sub>i</sub>, c2<sub>i</sub>]</code> 表示第 <code>i</code> 个工件在子网格中的填埋情况：</p>\n\n<ul>\n\t<li><code>(r1<sub>i</sub>, c1<sub>i</sub>)</code> 是第 <code>i</code> 个工件 <strong>左上</strong> 单元格的坐标，且</li>\n\t<li><code>(r2<sub>i</sub>, c2<sub>i</sub>)</code> 是第 <code>i</code> 个工件 <strong>右下</strong> 单元格的坐标。</li>\n</ul>\n\n<p>你将会挖掘网格中的一些单元格，并清除其中的填埋物。如果单元格中埋着工件的一部分，那么该工件这一部分将会裸露出来。如果一个工件的所有部分都都裸露出来，你就可以提取该工件。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>dig</code> ，其中 <code>dig[i] = [r<sub>i</sub>, c<sub>i</sub>]</code> 表示你将会挖掘单元格 <code>(r<sub>i</sub>, c<sub>i</sub>)</code> ，返回你可以提取的工件数目。</p>\n\n<p>生成的测试用例满足：</p>\n\n<ul>\n\t<li>不存在重叠的两个工件。</li>\n\t<li>每个工件最多只覆盖 <code>4</code> 个单元格。</li>\n\t<li><code>dig</code> 中的元素互不相同。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/16/untitled-diagram.jpg\" style=\"width: 216px; height: 216px;\">\n<pre><strong>输入：</strong>n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]\n<strong>输出：</strong>1\n<strong>解释：</strong> \n不同颜色表示不同的工件。挖掘的单元格用 'D' 在网格中进行标记。\n有 1 个工件可以提取，即红色工件。\n蓝色工件在单元格 (1,1) 的部分尚未裸露出来，所以无法提取该工件。\n因此，返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/16/untitled-diagram-1.jpg\" style=\"width: 216px; height: 216px;\">\n<pre><strong>输入：</strong>n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1],[1,1]]\n<strong>输出：</strong>2\n<strong>解释：</strong>红色工件和蓝色工件的所有部分都裸露出来（用 'D' 标记），都可以提取。因此，返回 2 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= artifacts.length, dig.length &lt;= min(n<sup>2</sup>, 10<sup>5</sup>)</code></li>\n\t<li><code>artifacts[i].length == 4</code></li>\n\t<li><code>dig[i].length == 2</code></li>\n\t<li><code>0 &lt;= r1<sub>i</sub>, c1<sub>i</sub>, r2<sub>i</sub>, c2<sub>i</sub>, r<sub>i</sub>, c<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>r1<sub>i</sub> &lt;= r2<sub>i</sub></code></li>\n\t<li><code>c1<sub>i</sub> &lt;= c2<sub>i</sub></code></li>\n\t<li>不存在重叠的两个工件</li>\n\t<li>每个工件 <strong>最多</strong> 只覆盖 <code>4</code> 个单元格</li>\n\t<li><code>dig</code> 中的元素互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2202.K 次操作后最大化顶端元素",
        "hardRate": "MEDIUM",
        "passRate": "21.67%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-the-topmost-element-after-k-moves/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-the-topmost-element-after-k-moves/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它表示一个 <strong>栈</strong> ，其中 <code>nums[0]</code>&nbsp;是栈顶的元素。</p>\n\n<p>每一次操作中，你可以执行以下操作 <strong>之一</strong>&nbsp;：</p>\n\n<ul>\n\t<li>如果栈非空，那么 <strong>删除</strong>&nbsp;栈顶端的元素。</li>\n\t<li>如果存在 1 个或者多个被删除的元素，你可以从它们中选择任何一个，<b>添加</b>&nbsp;回栈顶，这个元素成为新的栈顶元素。</li>\n</ul>\n\n<p>同时给你一个整数&nbsp;<code>k</code>&nbsp;，它表示你总共需要执行操作的次数。</p>\n\n<p>请你返回 <strong>恰好</strong>&nbsp;执行 <code>k</code>&nbsp;次操作以后，栈顶元素的 <strong>最大值</strong>&nbsp;。如果执行完 <code>k</code>&nbsp;次操作以后，栈一定为空，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,2,2,4,0,6], k = 4\n<b>输出：</b>5\n<strong>解释：</strong>\n4 次操作后，栈顶元素为 5 的方法之一为：\n- 第 1 次操作：删除栈顶元素 5 ，栈变为 [2,2,4,0,6] 。\n- 第 2 次操作：删除栈顶元素 2 ，栈变为 [2,4,0,6] 。\n- 第 3 次操作：删除栈顶元素 2 ，栈变为 [4,0,6] 。\n- 第 4 次操作：将 5 添加回栈顶，栈变为 [5,4,0,6] 。\n注意，这不是最后栈顶元素为 5 的唯一方式。但可以证明，4 次操作以后 5 是能得到的最大栈顶元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2], k = 1\n<b>输出：</b>-1\n<b>解释：</b>\n第 1 次操作中，我们唯一的选择是将栈顶元素弹出栈。\n由于 1 次操作后无法得到一个非空的栈，所以我们返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i], k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2203.得到要求路径的最小带权子图",
        "hardRate": "HARD",
        "passRate": "37.75%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-weighted-subgraph-with-the-required-paths/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-weighted-subgraph-with-the-required-paths/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，它表示一个 <strong>带权有向</strong> 图的节点数，节点编号为&nbsp;<code>0</code> 到&nbsp;<code>n - 1</code>&nbsp;。</p>\n\n<p>同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code>&nbsp;，表示从&nbsp;<code>from<sub>i</sub></code>&nbsp;到&nbsp;<code>to<sub>i</sub></code>&nbsp;有一条边权为&nbsp;<code>weight<sub>i</sub></code>&nbsp;的 <strong>有向</strong> 边。</p>\n\n<p>最后，给你三个 <strong>互不相同</strong>&nbsp;的整数&nbsp;<code>src1</code>&nbsp;，<code>src2</code>&nbsp;和&nbsp;<code>dest</code>&nbsp;，表示图中三个不同的点。</p>\n\n<p>请你从图中选出一个 <b>边权和最小</b>&nbsp;的子图，使得从 <code>src1</code>&nbsp;和 <code>src2</code>&nbsp;出发，在这个子图中，都 <strong>可以</strong>&nbsp;到达 <code>dest</code>&nbsp;。如果这样的子图不存在，请返回 <code>-1</code>&nbsp;。</p>\n\n<p><strong>子图</strong>&nbsp;中的点和边都应该属于原图的一部分。子图的边权和定义为它所包含的所有边的权值之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/17/example1drawio.png\" style=\"width: 263px; height: 250px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5\n<b>输出：</b>9\n<strong>解释：</strong>\n上图为输入的图。\n蓝色边为最优子图之一。\n注意，子图 [[1,0,3],[0,5,6]] 也能得到最优解，但无法在满足所有限制的前提下，得到更优解。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/17/example2-1drawio.png\" style=\"width: 350px; height: 51px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2\n<b>输出：</b>-1\n<strong>解释：</strong>\n上图为输入的图。\n可以看到，不存在从节点 1 到节点 2 的路径，所以不存在任何子图满足所有限制。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub>, src1, src2, dest &lt;= n - 1</code></li>\n\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\n\t<li><code>src1</code>&nbsp;，<code>src2</code>&nbsp;和&nbsp;<code>dest</code>&nbsp;两两不同。</li>\n\t<li><code>1 &lt;= weight[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2204.无向图中到环的距离",
        "hardRate": "HARD",
        "passRate": "75.45%",
        "problemsUrl": "https://leetcode.cn/problems/distance-to-a-cycle-in-undirected-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/distance-to-a-cycle-in-undirected-graph/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2205.有资格享受折扣的用户数量",
        "hardRate": "EASY",
        "passRate": "44.66%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-users-that-are-eligible-for-discount/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-users-that-are-eligible-for-discount/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2206.将数组划分成相等数对",
        "hardRate": "EASY",
        "passRate": "73.87%",
        "problemsUrl": "https://leetcode.cn/problems/divide-array-into-equal-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-array-into-equal-pairs/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;，它包含&nbsp;<code>2 * n</code>&nbsp;个整数。</p>\n\n<p>你需要将&nbsp;<code>nums</code> 划分成&nbsp;<code>n</code>&nbsp;个数对，满足：</p>\n\n<ul>\n\t<li>每个元素 <strong>只属于一个 </strong>数对。</li>\n\t<li>同一数对中的元素 <strong>相等</strong>&nbsp;。</li>\n</ul>\n\n<p>如果可以将 <code>nums</code>&nbsp;划分成 <code>n</code>&nbsp;个数对，请你返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,2,3,2,2,2]\n<b>输出：</b>true\n<b>解释：</b>\nnums<code>&nbsp;中总共有 6 个元素，所以它们应该被划分成</code> 6 / 2 = 3 个数对。\nnums 可以划分成 (2, 2) ，(3, 3) 和 (2, 2) ，满足所有要求。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4]\n<b>输出：</b>false\n<b>解释：</b>\n无法将 nums 划分成 4 / 2 = 2 个数对且满足所有要求。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == 2 * n</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2207.字符串中最多数目的子字符串",
        "hardRate": "MEDIUM",
        "passRate": "31.54%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-number-of-subsequences-in-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-number-of-subsequences-in-a-string/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>text</code>&nbsp;和另一个下标从 <strong>0</strong>&nbsp;开始且长度为 <code>2</code>&nbsp;的字符串&nbsp;<code>pattern</code>&nbsp;，两者都只包含小写英文字母。</p>\n\n<p>你可以在 <code>text</code>&nbsp;中任意位置插入 <strong>一个</strong> 字符，这个插入的字符必须是&nbsp;<code>pattern[0]</code>&nbsp;<b>或者</b>&nbsp;<code>pattern[1]</code>&nbsp;。注意，这个字符可以插入在 <code>text</code>&nbsp;开头或者结尾的位置。</p>\n\n<p>请你返回插入一个字符后，<code>text</code>&nbsp;中最多包含多少个等于 <code>pattern</code>&nbsp;的 <strong>子序列</strong>&nbsp;。</p>\n\n<p><strong>子序列</strong> 指的是将一个字符串删除若干个字符后（也可以不删除），剩余字符保持原本顺序得到的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>text = \"abdcdbc\", pattern = \"ac\"\n<b>输出：</b>4\n<strong>解释：</strong>\n如果我们在 text[1] 和 text[2] 之间添加 pattern[0] = 'a' ，那么我们得到 \"ab<em><strong>a</strong></em>dcdbc\" 。那么 \"ac\" 作为子序列出现 4 次。\n其他得到 4 个 \"ac\" 子序列的方案还有 \"<em><strong>a</strong></em>abdcdbc\" 和 \"abd<em><strong>a</strong></em>cdbc\" 。\n但是，\"abdc<em><strong>a</strong></em>dbc\" ，\"abd<em><strong>c</strong></em>cdbc\" 和 \"abdcdbc<em><strong>c</strong></em>\" 这些字符串虽然是可行的插入方案，但是只出现了 3 次 \"ac\" 子序列，所以不是最优解。\n可以证明插入一个字符后，无法得到超过 4 个 \"ac\" 子序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>text = \"aabb\", pattern = \"ab\"\n<b>输出：</b>6\n<strong>解释：</strong>\n可以得到 6 个 \"ab\" 子序列的部分方案为 \"<em><strong>a</strong></em>aabb\" ，\"aa<em><strong>a</strong></em>bb\" 和 \"aab<em><strong>b</strong></em>b\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pattern.length == 2</code></li>\n\t<li><code>text</code> 和&nbsp;<code>pattern</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2208.将数组和减半的最少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "40.90%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>nums</code>&nbsp;。每一次操作中，你可以从&nbsp;<code>nums</code>&nbsp;中选择 <strong>任意</strong>&nbsp;一个数并将它减小到 <strong>恰好</strong>&nbsp;一半。（注意，在后续操作中你可以对减半过的数继续执行操作）</p>\n\n<p>请你返回将 <code>nums</code>&nbsp;数组和 <strong>至少</strong>&nbsp;减少一半的 <strong>最少</strong>&nbsp;操作数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [5,19,8,1]\n<b>输出：</b>3\n<b>解释：</b>初始 nums 的和为 5 + 19 + 8 + 1 = 33 。\n以下是将数组和减少至少一半的一种方法：\n选择数字 19 并减小为 9.5 。\n选择数字 9.5 并减小为 4.75 。\n选择数字 8 并减小为 4 。\n最终数组为 [5, 4.75, 4, 1] ，和为 5 + 4.75 + 4 + 1 = 14.75 。\nnums 的和减小了 33 - 14.75 = 18.25 ，减小的部分超过了初始数组和的一半，18.25 &gt;= 33/2 = 16.5 。\n我们需要 3 个操作实现题目要求，所以返回 3 。\n可以证明，无法通过少于 3 个操作使数组和减少至少一半。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,8,20]\n<b>输出：</b>3\n<strong>解释：</strong>初始 nums 的和为 3 + 8 + 20 = 31 。\n以下是将数组和减少至少一半的一种方法：\n选择数字 20 并减小为 10 。\n选择数字 10 并减小为 5 。\n选择数字 3 并减小为 1.5 。\n最终数组为 [1.5, 8, 5] ，和为 1.5 + 8 + 5 = 14.5 。\nnums 的和减小了 31 - 14.5 = 16.5 ，减小的部分超过了初始数组和的一半， 16.5 &gt;= 31/2 = 16.5 。\n我们需要 3 个操作实现题目要求，所以返回 3 。\n可以证明，无法通过少于 3 个操作使数组和减少至少一半。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2209.用地毯覆盖后的最少白色砖块",
        "hardRate": "HARD",
        "passRate": "39.16%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/solution",
        "problemsDesc": "<p>给你一个下标从<strong>&nbsp;0</strong>&nbsp;开始的 <strong>二进制</strong>&nbsp;字符串&nbsp;<code>floor</code>&nbsp;，它表示地板上砖块的颜色。</p>\n\n<ul>\n\t<li><code>floor[i] = '0'</code>&nbsp;表示地板上第&nbsp;<code>i</code>&nbsp;块砖块的颜色是 <strong>黑色</strong>&nbsp;。</li>\n\t<li><code>floor[i] = '1'</code>&nbsp;表示地板上第&nbsp;<code>i</code>&nbsp;块砖块的颜色是 <strong>白色</strong>&nbsp;。</li>\n</ul>\n\n<p>同时给你&nbsp;<code>numCarpets</code> 和&nbsp;<code>carpetLen</code>&nbsp;。你有&nbsp;<code>numCarpets</code>&nbsp;条&nbsp;<strong>黑色</strong>&nbsp;的地毯，每一条&nbsp;<strong>黑色</strong>&nbsp;的地毯长度都为&nbsp;<code>carpetLen</code>&nbsp;块砖块。请你使用这些地毯去覆盖砖块，使得未被覆盖的剩余 <strong>白色</strong>&nbsp;砖块的数目 <strong>最小</strong>&nbsp;。地毯相互之间可以覆盖。</p>\n\n<p>请你返回没被覆盖的白色砖块的 <strong>最少</strong>&nbsp;数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/10/ex1-1.png\" style=\"width: 400px; height: 73px;\"></p>\n\n<pre><b>输入：</b>floor = \"10110101\", numCarpets = 2, carpetLen = 2\n<b>输出：</b>2\n<b>解释：</b>\n上图展示了剩余 2 块白色砖块的方案。\n没有其他方案可以使未被覆盖的白色砖块少于 2 块。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/10/ex2.png\" style=\"width: 353px; height: 123px;\"></p>\n\n<pre><b>输入：</b>floor = \"11111\", numCarpets = 2, carpetLen = 3\n<b>输出：</b>0\n<b>解释：</b>\n上图展示了所有白色砖块都被覆盖的一种方案。\n注意，地毯相互之间可以覆盖。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= carpetLen &lt;= floor.length &lt;= 1000</code></li>\n\t<li><code>floor[i]</code> 要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code>&nbsp;。</li>\n\t<li><code>1 &lt;= numCarpets &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2210.统计数组中峰和谷的数量",
        "hardRate": "EASY",
        "passRate": "58.70%",
        "problemsUrl": "https://leetcode.cn/problems/count-hills-and-valleys-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/count-hills-and-valleys-in-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。如果两侧距 <code>i</code> 最近的不相等邻居的值均小于 <code>nums[i]</code> ，则下标 <code>i</code> 是 <code>nums</code> 中，某个峰的一部分。类似地，如果两侧距 <code>i</code> 最近的不相等邻居的值均大于 <code>nums[i]</code> ，则下标 <code>i</code> 是 <code>nums</code> 中某个谷的一部分。对于相邻下标&nbsp;<code>i</code> 和 <code>j</code> ，如果&nbsp;<code>nums[i] == nums[j]</code> ， 则认为这两下标属于 <strong>同一个</strong> 峰或谷。</p>\n\n<p>注意，要使某个下标所做峰或谷的一部分，那么它左右两侧必须 <strong>都</strong> 存在不相等邻居。</p>\n\n<p>返回 <code>nums</code> 中峰和谷的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,1,1,6,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n在下标 0 ：由于 2 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。\n在下标 1 ：4 的最近不相等邻居是 2 和 1 。由于 4 &gt; 2 且 4 &gt; 1 ，下标 1 是一个峰。\n在下标 2 ：1 的最近不相等邻居是 4 和 6 。由于 1 &lt; 4 且 1 &lt; 6 ，下标 2 是一个谷。\n在下标 3 ：1 的最近不相等邻居是 4 和 6 。由于 1 &lt; 4 且 1 &lt; 6 ，下标 3 符合谷的定义，但需要注意它和下标 2 是同一个谷的一部分。\n在下标 4 ：6 的最近不相等邻居是 1 和 5 。由于 6 &gt; 1 且 6 &gt; 5 ，下标 4 是一个峰。\n在下标 5 ：由于 5 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。\n共有 3 个峰和谷，所以返回 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,6,5,5,4,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n在下标 0 ：由于 6 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。\n在下标 1 ：由于 6 的左侧不存在不相等邻居，所以下标 1 既不是峰也不是谷。\n在下标 2 ：5 的最近不相等邻居是 6 和 4 。由于 5 &lt; 6 且 5 &gt; 4 ，下标 2 既不是峰也不是谷。\n在下标 3 ：5 的最近不相等邻居是 6 和 4 。由于 5 &lt; 6 且 5 &gt; 4 ，下标 3 既不是峰也不是谷。\n在下标 4 ：4 的最近不相等邻居是 5 和 1 。由于 4 &lt; 5 且 4 &gt; 1 ，下标 4 既不是峰也不是谷。\n在下标 5 ：由于 1 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。\n共有 0 个峰和谷，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2211.统计道路上的碰撞次数",
        "hardRate": "MEDIUM",
        "passRate": "41.02%",
        "problemsUrl": "https://leetcode.cn/problems/count-collisions-on-a-road/",
        "solutionsUrl": "https://leetcode.cn/problems/count-collisions-on-a-road/solution",
        "problemsDesc": "<p>在一条无限长的公路上有 <code>n</code> 辆汽车正在行驶。汽车按从左到右的顺序按从 <code>0</code> 到 <code>n - 1</code> 编号，每辆车都在一个 <strong>独特的</strong> 位置。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>directions</code> ，长度为 <code>n</code> 。<code>directions[i]</code> 可以是 <code>'L'</code>、<code>'R'</code> 或 <code>'S'</code> 分别表示第 <code>i</code> 辆车是向 <strong>左</strong> 、向 <strong>右</strong> 或者 <strong>停留</strong> 在当前位置。每辆车移动时 <strong>速度相同</strong> 。</p>\n\n<p>碰撞次数可以按下述方式计算：</p>\n\n<ul>\n\t<li>当两辆移动方向&nbsp;<strong>相反</strong>&nbsp;的车相撞时，碰撞次数加 <code>2</code> 。</li>\n\t<li>当一辆移动的车和一辆静止的车相撞时，碰撞次数加 <code>1</code> 。</li>\n</ul>\n\n<p>碰撞发生后，涉及的车辆将无法继续移动并停留在碰撞位置。除此之外，汽车不能改变它们的状态或移动方向。</p>\n\n<p>返回在这条道路上发生的 <strong>碰撞总次数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>directions = \"RLRSLL\"\n<strong>输出：</strong>5\n<strong>解释：</strong>\n将会在道路上发生的碰撞列出如下：\n- 车 0 和车 1 会互相碰撞。由于它们按相反方向移动，碰撞数量变为 0 + 2 = 2 。\n- 车 2 和车 3 会互相碰撞。由于 3 是静止的，碰撞数量变为 2 + 1 = 3 。\n- 车 3 和车 4 会互相碰撞。由于 3 是静止的，碰撞数量变为 3 + 1 = 4 。\n- 车 4 和车 5 会互相碰撞。在车 4 和车 3 碰撞之后，车 4 会待在碰撞位置，接着和车 5 碰撞。碰撞数量变为 4 + 1 = 5 。\n因此，将会在道路上发生的碰撞总次数是 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>directions = \"LLRR\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\n不存在会发生碰撞的车辆。因此，将会在道路上发生的碰撞总次数是 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= directions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>directions[i]</code> 的值为 <code>'L'</code>、<code>'R'</code> 或 <code>'S'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2212.射箭比赛中的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "47.84%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-points-in-an-archery-competition/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-points-in-an-archery-competition/solution",
        "problemsDesc": "<p>Alice 和 Bob 是一场射箭比赛中的对手。比赛规则如下：</p>\n\n<ol>\n\t<li>Alice 先射 <code>numArrows</code> 支箭，然后 Bob 也射 <code>numArrows</code> 支箭。</li>\n\t<li>分数按下述规则计算：\n\t<ol>\n\t\t<li>箭靶有若干整数计分区域，范围从 <code>0</code> 到 <code>11</code> （含 <code>0</code> 和 <code>11</code>）。</li>\n\t\t<li>箭靶上每个区域都对应一个得分 <code>k</code>（范围是 <code>0</code> 到 <code>11</code>），Alice 和 Bob 分别在得分 <code>k</code>&nbsp;区域射中&nbsp;<code>a<sub>k</sub></code> 和 <code>b<sub>k</sub></code> 支箭。如果 <code>a<sub>k</sub> &gt;= b<sub>k</sub></code> ，那么 Alice 得 <code>k</code> 分。如果 <code>a<sub>k</sub> &lt; b<sub>k</sub></code> ，则 Bob 得 <code>k</code> 分</li>\n\t\t<li>如果 <code>a<sub>k</sub> == b<sub>k</sub> == 0</code> ，那么无人得到 <code>k</code> 分。</li>\n\t</ol>\n\t</li>\n</ol>\n\n<ul>\n\t<li>\n\t<p>例如，Alice 和 Bob 都向计分为 <code>11</code> 的区域射 <code>2</code> 支箭，那么 Alice 得 <code>11</code> 分。如果 Alice 向计分为 <code>11</code> 的区域射 <code>0</code> 支箭，但 Bob 向同一个区域射 <code>2</code> 支箭，那么 Bob 得&nbsp;<code>11</code> 分。</p>\n\t</li>\n</ul>\n\n<p>给你整数 <code>numArrows</code> 和一个长度为 <code>12</code> 的整数数组 <code>aliceArrows</code> ，该数组表示 Alice 射中&nbsp;<code>0</code> 到 <code>11</code> 每个计分区域的箭数量。现在，Bob 想要尽可能 <strong>最大化</strong> 他所能获得的总分。</p>\n\n<p>返回数组 <code>bobArrows</code><em> </em>，该数组表示 Bob 射中&nbsp;<code>0</code> 到 <code>11</code> <strong>每个</strong> 计分区域的箭数量。且 <code>bobArrows</code> 的总和应当等于 <code>numArrows</code> 。</p>\n\n<p>如果存在多种方法都可以使 Bob 获得最大总分，返回其中 <strong>任意一种</strong> 即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1647744752-kQKrXw-image.png\" style=\"width: 600px; height: 120px;\" /></p>\n\n<pre>\n<strong>输入：</strong>numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]\n<strong>输出：</strong>[0,0,0,0,1,1,0,0,1,2,3,1]\n<strong>解释：</strong>上表显示了比赛得分情况。\nBob 获得总分 4 + 5 + 8 + 9 + 10 + 11 = 47 。\n可以证明 Bob 无法获得比 47 更高的分数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1647744785-cMHzaC-image.png\" style=\"width: 600px; height: 117px;\" /></p>\n\n<pre>\n<strong>输入：</strong>numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]\n<strong>输出：</strong>[0,0,0,0,0,0,0,0,1,1,1,0]\n<strong>解释：</strong>上表显示了比赛得分情况。\nBob 获得总分 8 + 9 + 10 = 27 。\n可以证明 Bob 无法获得比 27 更高的分数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numArrows &lt;= 10<sup>5</sup></code></li>\n\t<li><code>aliceArrows.length == bobArrows.length == 12</code></li>\n\t<li><code>0 &lt;= aliceArrows[i], bobArrows[i] &lt;= numArrows</code></li>\n\t<li><code>sum(aliceArrows[i]) == numArrows</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2213.由单个字符重复的最长子字符串",
        "hardRate": "HARD",
        "passRate": "40.62%",
        "problemsUrl": "https://leetcode.cn/problems/longest-substring-of-one-repeating-character/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-substring-of-one-repeating-character/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> 。另给你一个下标从 <strong>0</strong> 开始、长度为 <code>k</code> 的字符串 <code>queryCharacters</code> ，一个下标从 <code>0</code> 开始、长度也是 <code>k</code> 的整数 <strong>下标</strong> 数组&nbsp;<code>queryIndices</code> ，这两个都用来描述 <code>k</code> 个查询。</p>\n\n<p>第 <code>i</code> 个查询会将 <code>s</code> 中位于下标 <code>queryIndices[i]</code> 的字符更新为 <code>queryCharacters[i]</code> 。</p>\n\n<p>返回一个长度为 <code>k</code> 的数组 <code>lengths</code> ，其中 <code>lengths[i]</code> 是在执行第 <code>i</code> 个查询 <strong>之后</strong> <code>s</code> 中仅由 <strong>单个字符重复</strong> 组成的 <strong>最长子字符串</strong> 的 <strong>长度</strong> <em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"babacc\", queryCharacters = \"bcb\", queryIndices = [1,3,3]\n<strong>输出：</strong>[3,3,4]\n<strong>解释：</strong>\n- 第 1 次查询更新后 s = \"<em>b<strong>b</strong>b</em>acc\" 。由单个字符重复组成的最长子字符串是 \"bbb\" ，长度为 3 。\n- 第 2 次查询更新后 s = \"bbb<em><strong>c</strong>cc</em>\" 。由单个字符重复组成的最长子字符串是 \"bbb\" 或 \"ccc\"，长度为 3 。\n- 第 3 次查询更新后 s = \"<em>bbb<strong>b</strong></em>cc\" 。由单个字符重复组成的最长子字符串是 \"bbbb\" ，长度为 4 。\n因此，返回 [3,3,4] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abyzz\", queryCharacters = \"aa\", queryIndices = [2,1]\n<strong>输出：</strong>[2,3]\n<strong>解释：</strong>\n- 第 1 次查询更新后 s = \"ab<strong>a</strong><em>zz</em>\" 。由单个字符重复组成的最长子字符串是 \"zz\" ，长度为 2 。\n- 第 2 次查询更新后 s = \"<em>a<strong>a</strong>a</em>zz\" 。由单个字符重复组成的最长子字符串是 \"aaa\" ，长度为 3 。\n因此，返回 [2,3] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n\t<li><code>k == queryCharacters.length == queryIndices.length</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queryCharacters</code> 由小写英文字母组成</li>\n\t<li><code>0 &lt;= queryIndices[i] &lt; s.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2214.通关游戏所需的最低生命值",
        "hardRate": "MEDIUM",
        "passRate": "55.39%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-health-to-beat-game/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-health-to-beat-game/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2215.找出两数组的不同",
        "hardRate": "EASY",
        "passRate": "66.89%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-difference-of-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-difference-of-two-arrays/solution",
        "problemsDesc": "<p>给你两个下标从 <code>0</code> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你返回一个长度为 <code>2</code> 的列表 <code>answer</code> ，其中：</p>\n\n<ul>\n\t<li><code>answer[0]</code> 是 <code>nums1</code> 中所有<strong> 不 </strong>存在于 <code>nums2</code> 中的 <strong>不同</strong> 整数组成的列表。</li>\n\t<li><code>answer[1]</code> 是 <code>nums2</code> 中所有<strong> 不 </strong>存在于 <code>nums1</code> 中的 <strong>不同</strong> 整数组成的列表。</li>\n</ul>\n\n<p><strong>注意：</strong>列表中的整数可以按 <strong>任意</strong> 顺序返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,3], nums2 = [2,4,6]\n<strong>输出：</strong>[[1,3],[4,6]]\n<strong>解释：\n</strong>对于 nums1 ，nums1[1] = 2 出现在 nums2 中下标 0 处，然而 nums1[0] = 1 和 nums1[2] = 3 没有出现在 nums2 中。因此，answer[0] = [1,3]。\n对于 nums2 ，nums2[0] = 2 出现在 nums1 中下标 1 处，然而 nums2[1] = 4 和 nums2[2] = 6 没有出现在 nums2 中。因此，answer[1] = [4,6]。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,3,3], nums2 = [1,1,2,2]\n<strong>输出：</strong>[[3],[]]\n<strong>解释：\n</strong>对于 nums1 ，nums1[2] 和 nums1[3] 没有出现在 nums2 中。由于 nums1[2] == nums1[3] ，二者的值只需要在 answer[0] 中出现一次，故 answer[0] = [3]。\nnums2 中的每个整数都在 nums1 中出现，因此，answer[1] = [] 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2216.美化数组的最少删除数",
        "hardRate": "MEDIUM",
        "passRate": "48.64%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-array-beautiful/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-array-beautiful/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，如果满足下述条件，则认为数组 <code>nums</code> 是一个 <strong>美丽数组</strong> ：</p>\n\n<ul>\n\t<li><code>nums.length</code> 为偶数</li>\n\t<li>对所有满足 <code>i % 2 == 0</code> 的下标 <code>i</code> ，<code>nums[i] != nums[i + 1]</code> 均成立</li>\n</ul>\n\n<p>注意，空数组同样认为是美丽数组。</p>\n\n<p>你可以从 <code>nums</code> 中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持 <strong>不变</strong> 。</p>\n\n<p>返回使 <code>nums</code> 变为美丽数组所需删除的 <strong>最少</strong> 元素数目<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,2,3,5]\n<strong>输出：</strong>1\n<strong>解释：</strong>可以删除 <code>nums[0]</code> 或 <code>nums[1]</code> ，这样得到的 <code>nums</code> = [1,2,3,5] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 1 个元素。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,2,2,3,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>可以删除 <code>nums[0]</code> 和 <code>nums[5]</code> ，这样得到的 nums = [1,2,2,3] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 2 个元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2217.找到指定长度的回文数",
        "hardRate": "MEDIUM",
        "passRate": "33.65%",
        "problemsUrl": "https://leetcode.cn/problems/find-palindrome-with-fixed-length/",
        "solutionsUrl": "https://leetcode.cn/problems/find-palindrome-with-fixed-length/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>queries</code>&nbsp;和一个 <strong>正</strong>&nbsp;整数&nbsp;<code>intLength</code>&nbsp;，请你返回一个数组&nbsp;<code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code> 是长度为&nbsp;<code>intLength</code>&nbsp;的&nbsp;<strong>正回文数</strong> 中第<em>&nbsp;</em><code>queries[i]</code>&nbsp;小的数字，如果不存在这样的回文数，则为 <code>-1</code>&nbsp;。</p>\n\n<p><strong>回文数</strong> 指的是从前往后和从后往前读一模一样的数字。回文数不能有前导 0 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>queries = [1,2,3,4,5,90], intLength = 3\n<b>输出：</b>[101,111,121,131,141,999]\n<strong>解释：</strong>\n长度为 3 的最小回文数依次是：\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, ...\n第 90 个长度为 3 的回文数是 999 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>queries = [2,4,6], intLength = 4\n<b>输出：</b>[1111,1331,1551]\n<strong>解释：</strong>\n长度为 4 的前 6 个回文数是：\n1001, 1111, 1221, 1331, 1441 和 1551 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= queries[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= intLength&nbsp;&lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2218.从栈中取出 K 个硬币的最大面值和",
        "hardRate": "HARD",
        "passRate": "55.31%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/solution",
        "problemsDesc": "<p>一张桌子上总共有 <code>n</code>&nbsp;个硬币 <b>栈</b>&nbsp;。每个栈有 <strong>正整数</strong>&nbsp;个带面值的硬币。</p>\n\n<p>每一次操作中，你可以从任意一个栈的 <strong>顶部</strong>&nbsp;取出 1 个硬币，从栈中移除它，并放入你的钱包里。</p>\n\n<p>给你一个列表&nbsp;<code>piles</code>&nbsp;，其中&nbsp;<code>piles[i]</code>&nbsp;是一个整数数组，分别表示第 <code>i</code>&nbsp;个栈里 <strong>从顶到底</strong>&nbsp;的硬币面值。同时给你一个正整数&nbsp;<code>k</code>&nbsp;，请你返回在&nbsp;<strong>恰好</strong>&nbsp;进行&nbsp;<code>k</code>&nbsp;次操作的前提下，你钱包里硬币面值之和&nbsp;<strong>最大为多少</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/09/e1.png\" style=\"width: 600px; height: 243px;\" /></p>\n\n<pre>\n<b>输入：</b>piles = [[1,100,3],[7,8,9]], k = 2\n<b>输出：</b>101\n<strong>解释：</strong>\n上图展示了几种选择 k 个硬币的不同方法。\n我们可以得到的最大面值为 101 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7\n<b>输出：</b>706\n<strong>解释：\n</strong>如果我们所有硬币都从最后一个栈中取，可以得到最大面值和。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == piles.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= piles[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= sum(piles[i].length) &lt;= 2000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2219.数组的最大总分",
        "hardRate": "MEDIUM",
        "passRate": "64.06%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-score-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-score-of-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2220.转换数字的最少位翻转次数",
        "hardRate": "EASY",
        "passRate": "82.61%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-bit-flips-to-convert-number/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-bit-flips-to-convert-number/solution",
        "problemsDesc": "<p>一次 <strong>位翻转</strong>&nbsp;定义为将数字&nbsp;<code>x</code>&nbsp;二进制中的一个位进行 <strong>翻转</strong>&nbsp;操作，即将&nbsp;<code>0</code>&nbsp;变成&nbsp;<code>1</code>&nbsp;，或者将&nbsp;<code>1</code>&nbsp;变成&nbsp;<code>0</code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，<code>x = 7</code>&nbsp;，二进制表示为&nbsp;<code>111</code>&nbsp;，我们可以选择任意一个位（包含没有显示的前导 0 ）并进行翻转。比方说我们可以翻转最右边一位得到&nbsp;<code>110</code>&nbsp;，或者翻转右边起第二位得到&nbsp;<code>101</code>&nbsp;，或者翻转右边起第五位（这一位是前导 0 ）得到&nbsp;<code>10111</code>&nbsp;等等。</li>\n</ul>\n\n<p>给你两个整数&nbsp;<code>start</code> 和&nbsp;<code>goal</code>&nbsp;，请你返回将&nbsp;<code>start</code>&nbsp;转变成&nbsp;<code>goal</code>&nbsp;的&nbsp;<strong>最少位翻转</strong>&nbsp;次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>start = 10, goal = 7\n<b>输出：</b>3\n<b>解释：</b>10 和 7 的二进制表示分别为 1010 和 0111 。我们可以通过 3 步将 10 转变成 7 ：\n- 翻转右边起第一位得到：101<strong><em>0</em></strong> -&gt; 101<strong><em>1 。</em></strong>\n- 翻转右边起第三位：1<strong><em>0</em></strong>11 -&gt; 1<strong><em>1</em></strong>11 。\n- 翻转右边起第四位：<strong><em>1</em></strong>111 -&gt; <strong><em>0</em></strong>111 。\n我们无法在 3 步内将 10 转变成 7 。所以我们返回 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>start = 3, goal = 4\n<b>输出：</b>3\n<b>解释：</b>3 和 4 的二进制表示分别为 011 和 100 。我们可以通过 3 步将 3 转变成 4 ：\n- 翻转右边起第一位：01<strong><em>1</em></strong> -&gt; 01<em><strong>0 </strong></em>。\n- 翻转右边起第二位：0<strong><em>1</em></strong>0 -&gt; 0<strong><em>0</em></strong>0 。\n- 翻转右边起第三位：<strong><em>0</em></strong>00 -&gt; <strong><em>1</em></strong>00 。\n我们无法在 3 步内将 3 变成 4 。所以我们返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= start, goal &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2221.数组的三角和",
        "hardRate": "MEDIUM",
        "passRate": "79.74%",
        "problemsUrl": "https://leetcode.cn/problems/find-triangular-sum-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-triangular-sum-of-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，其中&nbsp;<code>nums[i]</code>&nbsp;是 <code>0</code>&nbsp;到 <code>9</code>&nbsp;之间（两者都包含）的一个数字。</p>\n\n<p><code>nums</code>&nbsp;的 <strong>三角和</strong>&nbsp;是执行以下操作以后最后剩下元素的值：</p>\n\n<ol>\n\t<li><code>nums</code>&nbsp;初始包含&nbsp;<code>n</code>&nbsp;个元素。如果&nbsp;<code>n == 1</code>&nbsp;，<strong>终止</strong>&nbsp;操作。否则，<strong>创建</strong>&nbsp;一个新的下标从&nbsp;<strong>0</strong>&nbsp;开始的长度为 <code>n - 1</code>&nbsp;的整数数组&nbsp;<code>newNums</code>&nbsp;。</li>\n\t<li>对于满足&nbsp;<code>0 &lt;= i &lt;&nbsp;n - 1</code>&nbsp;的下标&nbsp;<code>i</code>&nbsp;，<code>newNums[i]</code> <strong>赋值</strong>&nbsp;为&nbsp;<code>(nums[i] + nums[i+1]) % 10</code>&nbsp;，<code>%</code>&nbsp;表示取余运算。</li>\n\t<li>将&nbsp;<code>newNums</code>&nbsp;<strong>替换</strong> 数组&nbsp;<code>nums</code>&nbsp;。</li>\n\t<li>从步骤 1 开始&nbsp;<strong>重复</strong>&nbsp;整个过程。</li>\n</ol>\n\n<p>请你返回&nbsp;<code>nums</code>&nbsp;的三角和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/22/ex1drawio.png\" style=\"width: 250px; height: 250px;\" /></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>8\n<strong>解释：</strong>\n上图展示了得到数组三角和的过程。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5]\n<b>输出：</b>5\n<b>解释：</b>\n由于 nums 中只有一个元素，数组的三角和为这个元素自己。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2222.选择建筑的方案数",
        "hardRate": "MEDIUM",
        "passRate": "49.92%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-select-buildings/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-select-buildings/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二进制字符串&nbsp;<code>s</code>&nbsp;，它表示一条街沿途的建筑类型，其中：</p>\n\n<ul>\n\t<li><code>s[i] = '0'</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;栋建筑是一栋办公楼，</li>\n\t<li><code>s[i] = '1'</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;栋建筑是一间餐厅。</li>\n</ul>\n\n<p>作为市政厅的官员，你需要随机<strong>&nbsp;选择</strong>&nbsp;3 栋建筑。然而，为了确保多样性，选出来的 3 栋建筑 <strong>相邻</strong>&nbsp;的两栋不能是同一类型。</p>\n\n<ul>\n\t<li>比方说，给你&nbsp;<code>s = \"0<em><strong>0</strong></em>1<em><strong>1</strong></em>0<em><strong>1</strong></em>\"</code>&nbsp;，我们不能选择第&nbsp;<code>1</code>&nbsp;，<code>3</code>&nbsp;和&nbsp;<code>5</code>&nbsp;栋建筑，因为得到的子序列是&nbsp;<code>\"0<em><strong>11</strong></em>\"</code>&nbsp;，有相邻两栋建筑是同一类型，所以 <strong>不合</strong>&nbsp;题意。</li>\n</ul>\n\n<p>请你返回可以选择 3 栋建筑的 <strong>有效方案数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"001101\"\n<b>输出：</b>6\n<b>解释：</b>\n以下下标集合是合法的：\n- [0,2,4] ，从 \"<em><strong>0</strong></em>0<em><strong>1</strong></em>1<em><strong>0</strong></em>1\" 得到 \"010\"\n- [0,3,4] ，从 \"<em><strong>0</strong></em>01<em><strong>10</strong></em>1\" 得到 \"010\"\n- [1,2,4] ，从 \"0<em><strong>01</strong></em>1<em><strong>0</strong></em>1\" 得到 \"010\"\n- [1,3,4] ，从 \"0<em><strong>0</strong></em>1<em><strong>10</strong></em>1\" 得到 \"010\"\n- [2,4,5] ，从 \"00<em><strong>1</strong></em>1<em><strong>01</strong></em>\" 得到 \"101\"\n- [3,4,5] ，从 \"001<em><strong>101</strong></em>\" 得到 \"101\"\n没有别的合法选择，所以总共有 6 种方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"11100\"\n<b>输出：</b>0\n<b>解释：</b>没有任何符合题意的选择。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2223.构造字符串的总得分和",
        "hardRate": "HARD",
        "passRate": "38.36%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-scores-of-built-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-scores-of-built-strings/solution",
        "problemsDesc": "<p>你需要从空字符串开始&nbsp;<strong>构造</strong> 一个长度为 <code>n</code>&nbsp;的字符串 <code>s</code>&nbsp;，构造的过程为每次给当前字符串 <strong>前面</strong>&nbsp;添加 <strong>一个</strong> 字符。构造过程中得到的所有字符串编号为 <code>1</code>&nbsp;到 <code>n</code>&nbsp;，其中长度为 <code>i</code>&nbsp;的字符串编号为 <code>s<sub>i</sub></code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，<code>s = \"abaca\"</code>&nbsp;，<code>s<sub>1</sub> == \"a\"</code>&nbsp;，<code>s<sub>2</sub> == \"ca\"</code>&nbsp;，<code>s<sub>3</sub> == \"aca\"</code>&nbsp;依次类推。</li>\n</ul>\n\n<p><code>s<sub>i</sub></code>&nbsp;的 <strong>得分</strong>&nbsp;为&nbsp;<code>s<sub>i</sub></code> 和&nbsp;<code>s<sub>n</sub></code>&nbsp;的 <strong>最长公共前缀</strong> 的长度（注意&nbsp;<code>s == s<sub>n</sub></code>&nbsp;）。</p>\n\n<p>给你最终的字符串&nbsp;<code>s</code>&nbsp;，请你返回每一个<em>&nbsp;</em><code>s<sub>i</sub></code>&nbsp;的&nbsp;<strong>得分之和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"babab\"\n<b>输出：</b>9\n<b>解释：</b>\ns<sub>1</sub> == \"b\" ，最长公共前缀是 \"b\" ，得分为 1 。\ns<sub>2</sub> == \"ab\" ，没有公共前缀，得分为 0 。\ns<sub>3</sub> == \"bab\" ，最长公共前缀为 \"bab\" ，得分为 3 。\ns<sub>4</sub> == \"abab\" ，没有公共前缀，得分为 0 。\ns<sub>5</sub> == \"babab\" ，最长公共前缀为 \"babab\" ，得分为 5 。\n得分和为 1 + 0 + 3 + 0 + 5 = 9 ，所以我们返回 9 。</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"azbazbzaz\"\n<b>输出：</b>14\n<b>解释：</b>\ns<sub>2</sub> == \"az\" ，最长公共前缀为 \"az\" ，得分为 2 。\ns<sub>6</sub> == \"azbzaz\" ，最长公共前缀为 \"azb\" ，得分为 3 。\ns<sub>9</sub> == \"azbazbzaz\" ，最长公共前缀为 \"azbazbzaz\" ，得分为 9 。\n其他 s<sub>i</sub> 得分均为 0 。\n得分和为 2 + 3 + 9 = 14 ，所以我们返回 14 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2224.转化时间需要的最少操作数",
        "hardRate": "EASY",
        "passRate": "69.39%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-convert-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-convert-time/solution",
        "problemsDesc": "<p>给你两个字符串 <code>current</code> 和 <code>correct</code> ，表示两个 <strong>24 小时制时间</strong> 。</p>\n\n<p><strong>24 小时制时间</strong> 按 <code>\"HH:MM\"</code> 进行格式化，其中 <code>HH</code> 在 <code>00</code> 和 <code>23</code> 之间，而 <code>MM</code> 在 <code>00</code> 和 <code>59</code> 之间。最早的 24 小时制时间为 <code>00:00</code> ，最晚的是 <code>23:59</code> 。</p>\n\n<p>在一步操作中，你可以将 <code>current</code> 这个时间增加 <code>1</code>、<code>5</code>、<code>15</code> 或 <code>60</code> 分钟。你可以执行这一操作 <strong>任意</strong> 次数。</p>\n\n<p>返回将&nbsp;<code>current</code><em> </em>转化为<em> </em><code>correct</code> 需要的 <strong>最少操作数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>current = \"02:30\", correct = \"04:35\"\n<strong>输出：</strong>3\n<strong>解释：\n</strong>可以按下述 3 步操作将 current 转换为 correct ：\n- 为 current 加 60 分钟，current 变为 \"03:30\" 。\n- 为 current 加 60 分钟，current 变为 \"04:30\" 。 \n- 为 current 加 5 分钟，current 变为 \"04:35\" 。\n可以证明，无法用少于 3 步操作将 current 转化为 correct 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>current = \"11:00\", correct = \"11:01\"\n<strong>输出：</strong>1\n<strong>解释：</strong>只需要为 current 加一分钟，所以最小操作数是 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>current</code> 和 <code>correct</code> 都符合 <code>\"HH:MM\"</code> 格式</li>\n\t<li><code>current &lt;= correct</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2225.找出输掉零场或一场比赛的玩家",
        "hardRate": "MEDIUM",
        "passRate": "62.99%",
        "problemsUrl": "https://leetcode.cn/problems/find-players-with-zero-or-one-losses/",
        "solutionsUrl": "https://leetcode.cn/problems/find-players-with-zero-or-one-losses/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>matches</code> 其中 <code>matches[i] = [winner<sub>i</sub>, loser<sub>i</sub>]</code> 表示在一场比赛中 <code>winner<sub>i</sub></code> 击败了 <code>loser<sub>i</sub></code> 。</p>\n\n<p>返回一个长度为 2 的列表<em> </em><code>answer</code> ：</p>\n\n<ul>\n\t<li><code>answer[0]</code> 是所有 <strong>没有</strong> 输掉任何比赛的玩家列表。</li>\n\t<li><code>answer[1]</code> 是所有恰好输掉 <strong>一场</strong> 比赛的玩家列表。</li>\n</ul>\n\n<p>两个列表中的值都应该按 <strong>递增</strong> 顺序返回。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>只考虑那些参与 <strong>至少一场</strong> 比赛的玩家。</li>\n\t<li>生成的测试用例保证 <strong>不存在</strong> 两场比赛结果 <strong>相同</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\n<strong>输出：</strong>[[1,2,10],[4,5,7,8]]\n<strong>解释：</strong>\n玩家 1、2 和 10 都没有输掉任何比赛。\n玩家 4、5、7 和 8 每个都输掉一场比赛。\n玩家 3、6 和 9 每个都输掉两场比赛。\n因此，answer[0] = [1,2,10] 和 answer[1] = [4,5,7,8] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matches = [[2,3],[1,3],[5,4],[6,4]]\n<strong>输出：</strong>[[1,2,5,6],[]]\n<strong>解释：</strong>\n玩家 1、2、5 和 6 都没有输掉任何比赛。\n玩家 3 和 4 每个都输掉两场比赛。\n因此，answer[0] = [1,2,5,6] 和 answer[1] = [] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= matches.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>matches[i].length == 2</code></li>\n\t<li><code>1 &lt;= winner<sub>i</sub>, loser<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>winner<sub>i</sub> != loser<sub>i</sub></code></li>\n\t<li>所有 <code>matches[i]</code> <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2226.每个小孩最多能分到多少糖果",
        "hardRate": "MEDIUM",
        "passRate": "34.17%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/solution",
        "problemsDesc": "<p>给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>candies</code> 。数组中的每个元素表示大小为 <code>candies[i]</code> 的一堆糖果。你可以将每堆糖果分成任意数量的 <strong>子堆</strong> ，但 <strong>无法</strong> 再将两堆合并到一起。</p>\n\n<p>另给你一个整数 <code>k</code> 。你需要将这些糖果分配给 <code>k</code> 个小孩，使每个小孩分到 <strong>相同</strong> 数量的糖果。每个小孩可以拿走 <strong>至多一堆</strong> 糖果，有些糖果可能会不被分配。</p>\n\n<p>返回每个小孩可以拿走的 <strong>最大糖果数目</strong><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>candies = [5,8,6], k = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>可以将 candies[1] 分成大小分别为 5 和 3 的两堆，然后把 candies[2] 分成大小分别为 5 和 1 的两堆。现在就有五堆大小分别为 5、5、3、5 和 1 的糖果。可以把 3 堆大小为 5 的糖果分给 3 个小孩。可以证明无法让每个小孩得到超过 5 颗糖果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>candies = [2,5], k = 11\n<strong>输出：</strong>0\n<strong>解释：</strong>总共有 11 个小孩，但只有 7 颗糖果，但如果要分配糖果的话，必须保证每个小孩至少能得到 1 颗糖果。因此，最后每个小孩都没有得到糖果，答案是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candies.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= candies[i] &lt;= 10<sup>7</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>12</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2227.加密解密字符串",
        "hardRate": "HARD",
        "passRate": "39.53%",
        "problemsUrl": "https://leetcode.cn/problems/encrypt-and-decrypt-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/encrypt-and-decrypt-strings/solution",
        "problemsDesc": "<p>给你一个字符数组 <code>keys</code> ，由若干 <strong>互不相同</strong> 的字符组成。还有一个字符串数组 <code>values</code> ，内含若干长度为 2 的字符串。另给你一个字符串数组 <code>dictionary</code> ，包含解密后所有允许的原字符串。请你设计并实现一个支持加密及解密下标从 <strong>0</strong> 开始字符串的数据结构。</p>\n\n<p>字符串 <strong>加密</strong> 按下述步骤进行：</p>\n\n<ol>\n\t<li>对字符串中的每个字符 <code>c</code> ，先从 <code>keys</code> 中找出满足 <code>keys[i] == c</code> 的下标 <code>i</code> 。</li>\n\t<li>在字符串中，用&nbsp;<code>values[i]</code> 替换字符 <code>c</code> 。</li>\n</ol>\n\n<p>字符串 <strong>解密</strong> 按下述步骤进行：</p>\n\n<ol>\n\t<li>将字符串每相邻 2 个字符划分为一个子字符串，对于每个子字符串 <code>s</code> ，找出满足 <code>values[i] == s</code> 的一个下标 <code>i</code> 。如果存在多个有效的 <code>i</code> ，从中选择 <strong>任意</strong> 一个。这意味着一个字符串解密可能得到多个解密字符串。</li>\n\t<li>在字符串中，用 <code>keys[i]</code> 替换 <code>s</code> 。</li>\n</ol>\n\n<p>实现 <code>Encrypter</code> 类：</p>\n\n<ul>\n\t<li><code>Encrypter(char[] keys, String[] values, String[] dictionary)</code> 用 <code>keys</code>、<code>values</code> 和 <code>dictionary</code> 初始化 <code>Encrypter</code> 类。</li>\n\t<li><code>String encrypt(String word1)</code> 按上述加密过程完成对 <code>word1</code> 的加密，并返回加密后的字符串。</li>\n\t<li><code>int decrypt(String word2)</code> 统计并返回可以由 <code>word2</code> 解密得到且出现在 <code>dictionary</code> 中的字符串数目。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Encrypter\", \"encrypt\", \"decrypt\"]\n[[['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]], [\"abcd\"], [\"eizfeiam\"]]\n<strong>输出：</strong>\n[null, \"eizfeiam\", 2]\n\n<strong>解释：</strong>\nEncrypter encrypter = new Encrypter([['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]);\nencrypter.encrypt(\"abcd\"); // 返回 \"eizfeiam\"。 \n&nbsp;                          // 'a' 映射为 \"ei\"，'b' 映射为 \"zf\"，'c' 映射为 \"ei\"，'d' 映射为 \"am\"。\nencrypter.decrypt(\"eizfeiam\"); // return 2. \n                              // \"ei\" 可以映射为 'a' 或 'c'，\"zf\" 映射为 'b'，\"am\" 映射为 'd'。 \n                              // 因此，解密后可以得到的字符串是 \"abad\"，\"cbad\"，\"abcd\" 和 \"cbcd\"。 \n                              // 其中 2 个字符串，\"abad\" 和 \"abcd\"，在 dictionary 中出现，所以答案是 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= keys.length == values.length &lt;= 26</code></li>\n\t<li><code>values[i].length == 2</code></li>\n\t<li><code>1 &lt;= dictionary.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= dictionary[i].length &lt;= 100</code></li>\n\t<li>所有 <code>keys[i]</code> 和 <code>dictionary[i]</code> <strong>互不相同</strong></li>\n\t<li><code>1 &lt;= word1.length &lt;= 2000</code></li>\n\t<li><code>1 &lt;= word2.length &lt;= 200</code></li>\n\t<li>所有 <code>word1[i]</code> 都出现在 <code>keys</code> 中</li>\n\t<li><code>word2.length</code> 是偶数</li>\n\t<li><code>keys</code>、<code>values[i]</code>、<code>dictionary[i]</code>、<code>word1</code> 和 <code>word2</code> 只含小写英文字母</li>\n\t<li>至多调用 <code>encrypt</code> 和 <code>decrypt</code> <strong>总计</strong> <code>200</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2228.7 天内两次购买的用户",
        "hardRate": "MEDIUM",
        "passRate": "47.25%",
        "problemsUrl": "https://leetcode.cn/problems/users-with-two-purchases-within-seven-days/",
        "solutionsUrl": "https://leetcode.cn/problems/users-with-two-purchases-within-seven-days/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2229.检查数组是否连贯",
        "hardRate": "EASY",
        "passRate": "69.83%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-an-array-is-consecutive/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-an-array-is-consecutive/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2230.查找可享受优惠的用户",
        "hardRate": "EASY",
        "passRate": "49.43%",
        "problemsUrl": "https://leetcode.cn/problems/the-users-that-are-eligible-for-discount/",
        "solutionsUrl": "https://leetcode.cn/problems/the-users-that-are-eligible-for-discount/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2231.按奇偶性交换后的最大数字",
        "hardRate": "EASY",
        "passRate": "64.25%",
        "problemsUrl": "https://leetcode.cn/problems/largest-number-after-digit-swaps-by-parity/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-number-after-digit-swaps-by-parity/solution",
        "problemsDesc": "<p>给你一个正整数 <code>num</code> 。你可以交换 <code>num</code> 中 <strong>奇偶性</strong> 相同的任意两位数字（即，都是奇数或者偶数）。</p>\n\n<p>返回交换 <strong>任意</strong> 次之后 <code>num</code> 的 <strong>最大</strong> 可能值<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 1234\n<strong>输出：</strong>3412\n<strong>解释：</strong>交换数字 3 和数字 1 ，结果得到 3214 。\n交换数字 2 和数字 4 ，结果得到 3412 。\n注意，可能存在其他交换序列，但是可以证明 3412 是最大可能值。\n注意，不能交换数字 4 和数字 1 ，因为它们奇偶性不同。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 65875\n<strong>输出：</strong>87655\n<strong>解释：</strong>交换数字 8 和数字 6 ，结果得到 85675 。\n交换数字 5 和数字 7 ，结果得到 87655 。\n注意，可能存在其他交换序列，但是可以证明 87655 是最大可能值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2232.向表达式添加括号后的最小结果",
        "hardRate": "MEDIUM",
        "passRate": "61.23%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-result-by-adding-parentheses-to-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-result-by-adding-parentheses-to-expression/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>expression</code> ，格式为 <code>\"&lt;num1&gt;+&lt;num2&gt;\"</code> ，其中 <code>&lt;num1&gt;</code> 和 <code>&lt;num2&gt;</code> 表示正整数。</p>\n\n<p>请你向 <code>expression</code> 中添加一对括号，使得在添加之后， <code>expression</code> 仍然是一个有效的数学表达式，并且计算后可以得到 <strong>最小</strong> 可能值。左括号 <strong>必须</strong> 添加在 <code>'+'</code> 的左侧，而右括号必须添加在 <code>'+'</code> 的右侧。</p>\n\n<p>返回添加一对括号后形成的表达式&nbsp;<code>expression</code> ，且满足<em> </em><code>expression</code><em> </em>计算得到 <strong>最小</strong> 可能值<em>。</em>如果存在多个答案都能产生相同结果，返回任意一个答案。</p>\n\n<p>生成的输入满足：<code>expression</code> 的原始值和添加满足要求的任一对括号之后 <code>expression</code> 的值，都符合 32-bit 带符号整数范围。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>expression = \"247+38\"\n<strong>输出：</strong>\"2(47+38)\"\n<strong>解释：</strong>表达式计算得到 2 * (47 + 38) = 2 * 85 = 170 。\n注意 \"2(4)7+38\" 不是有效的结果，因为右括号必须添加在 <code>'+' 的右侧。</code>\n可以证明 170 是最小可能值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>expression = \"12+34\"\n<strong>输出：</strong>\"1(2+3)4\"\n<strong>解释：</strong>表达式计算得到 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>expression = \"999+999\"\n<strong>输出：</strong>\"(999+999)\"\n<strong>解释：</strong>表达式计算得到 999 + 999 = 1998 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= expression.length &lt;= 10</code></li>\n\t<li><code>expression</code> 仅由数字 <code>'1'</code> 到 <code>'9'</code> 和 <code>'+'</code> 组成</li>\n\t<li><code>expression</code> 由数字开始和结束</li>\n\t<li><code>expression</code> 恰好仅含有一个 <code>'+'</code>.</li>\n\t<li><code>expression</code> 的原始值和添加满足要求的任一对括号之后 <code>expression</code> 的值，都符合 32-bit 带符号整数范围</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2233.K 次增加后的最大乘积",
        "hardRate": "MEDIUM",
        "passRate": "36.66%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-after-k-increments/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-after-k-increments/solution",
        "problemsDesc": "<p>给你一个非负整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。每次操作，你可以选择&nbsp;<code>nums</code>&nbsp;中 <strong>任一</strong>&nbsp;元素并将它 <strong>增加</strong>&nbsp;<code>1</code>&nbsp;。</p>\n\n<p>请你返回 <strong>至多</strong>&nbsp;<code>k</code>&nbsp;次操作后，能得到的<em>&nbsp;</em><code>nums</code>的&nbsp;<strong>最大乘积</strong>&nbsp;。由于答案可能很大，请你将答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [0,4], k = 5\n<b>输出：</b>20\n<b>解释：</b>将第一个数增加 5 次。\n得到 nums = [5, 4] ，乘积为 5 * 4 = 20 。\n可以证明 20 是能得到的最大乘积，所以我们返回 20 。\n存在其他增加 nums 的方法，也能得到最大乘积。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [6,3,3,2], k = 2\n<b>输出：</b>216\n<b>解释：</b>将第二个数增加 1 次，将第四个数增加 1 次。\n得到 nums = [6, 4, 3, 3] ，乘积为 6 * 4 * 3 * 3 = 216 。\n可以证明 216 是能得到的最大乘积，所以我们返回 216 。\n存在其他增加 nums 的方法，也能得到最大乘积。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2234.花园的最大总美丽值",
        "hardRate": "HARD",
        "passRate": "27.88%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-total-beauty-of-the-gardens/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-total-beauty-of-the-gardens/solution",
        "problemsDesc": "<p>Alice 是&nbsp;<code>n</code>&nbsp;个花园的园丁，她想通过种花，最大化她所有花园的总美丽值。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始大小为 <code>n</code>&nbsp;的整数数组&nbsp;<code>flowers</code>&nbsp;，其中&nbsp;<code>flowers[i]</code>&nbsp;是第 <code>i</code>&nbsp;个花园里已经种的花的数目。已经种了的花 <strong>不能</strong>&nbsp;移走。同时给你&nbsp;<code>newFlowers</code>&nbsp;，表示 Alice 额外可以种花的&nbsp;<strong>最大数目</strong>&nbsp;。同时给你的还有整数&nbsp;<code>target</code>&nbsp;，<code>full</code>&nbsp;和&nbsp;<code>partial</code>&nbsp;。</p>\n\n<p>如果一个花园有 <strong>至少</strong>&nbsp;<code>target</code>&nbsp;朵花，那么这个花园称为 <strong>完善的</strong>&nbsp;，花园的 <strong>总美丽值</strong>&nbsp;为以下分数之 <strong>和</strong> ：</p>\n\n<ul>\n\t<li><b>完善</b> 花园数目乘以&nbsp;<code>full</code>.</li>\n\t<li>剩余 <strong>不完善</strong>&nbsp;花园里，花的 <strong>最少数目</strong>&nbsp;乘以&nbsp;<code>partial</code>&nbsp;。如果没有不完善花园，那么这一部分的值为&nbsp;<code>0</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回 Alice 种最多 <code>newFlowers</code>&nbsp;朵花以后，能得到的<strong>&nbsp;最大</strong>&nbsp;总美丽值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1\n<b>输出：</b>14\n<b>解释：</b>Alice 可以按以下方案种花\n- 在第 0 个花园种 2 朵花\n- 在第 1 个花园种 3 朵花\n- 在第 2 个花园种 1 朵花\n- 在第 3 个花园种 1 朵花\n花园里花的数目为 [3,6,2,2] 。总共种了 2 + 3 + 1 + 1 = 7 朵花。\n只有 1 个花园是完善的。\n不完善花园里花的最少数目是 2 。\n所以总美丽值为 1 * 12 + 2 * 1 = 12 + 2 = 14 。\n没有其他方案可以让花园总美丽值超过 14 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6\n<b>输出：</b>30\n<b>解释：</b>Alice 可以按以下方案种花\n- 在第 0 个花园种 3 朵花\n- 在第 1 个花园种 0 朵花\n- 在第 2 个花园种 0 朵花\n- 在第 3 个花园种 2 朵花\n花园里花的数目为 [5,4,5,5] 。总共种了 3 + 0 + 0 + 2 = 5 朵花。\n有 3 个花园是完善的。\n不完善花园里花的最少数目为 4 。\n所以总美丽值为 3 * 2 + 4 * 6 = 6 + 24 = 30 。\n没有其他方案可以让花园总美丽值超过 30 。\n注意，Alice可以让所有花园都变成完善的，但这样她的总美丽值反而更小。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= flowers.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= flowers[i], target &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= newFlowers &lt;= 10<sup>10</sup></code></li>\n\t<li><code>1 &lt;= full, partial &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2235.两整数相加",
        "hardRate": "EASY",
        "passRate": "84.94%",
        "problemsUrl": "https://leetcode.cn/problems/add-two-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/add-two-integers/solution",
        "problemsDesc": "给你两个整数&nbsp;<code>num1</code> 和 <code>num2</code>，返回这两个整数的和。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = 12, num2 = 5\n<strong>输出：</strong>17\n<strong>解释：</strong>num1 是 12，num2 是 5 ，它们的和是 12 + 5 = 17 ，因此返回 17 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = -10, num2 = 4\n<strong>输出：</strong>-6\n<strong>解释：</strong>num1 + num2 = -6 ，因此返回 -6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-100 &lt;= num1, num2 &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2236.判断根结点是否等于子结点之和",
        "hardRate": "EASY",
        "passRate": "85.78%",
        "problemsUrl": "https://leetcode.cn/problems/root-equals-sum-of-children/",
        "solutionsUrl": "https://leetcode.cn/problems/root-equals-sum-of-children/solution",
        "problemsDesc": "<p>给你一个 <strong>二叉树 </strong>的根结点&nbsp;<code>root</code>，该二叉树由恰好&nbsp;<code>3</code>&nbsp;个结点组成：根结点、左子结点和右子结点。</p>\n\n<p>如果根结点值等于两个子结点值之和，返回&nbsp;<code>true</code>&nbsp;，否则返回<em>&nbsp;</em><code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/08/graph3drawio.png\" style=\"width: 281px; height: 199px;\" />\n<pre>\n<strong>输入：</strong>root = [10,4,6]\n<strong>输出：</strong>true\n<strong>解释：</strong>根结点、左子结点和右子结点的值分别是 10 、4 和 6 。\n由于 10 等于 4 + 6 ，因此返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/08/graph3drawio-1.png\" style=\"width: 281px; height: 199px;\" />\n<pre>\n<strong>输入：</strong>root = [5,3,1]\n<strong>输出：</strong>false\n<strong>解释：</strong>根结点、左子结点和右子结点的值分别是 5 、3 和 1 。\n由于 5 不等于 3 + 1 ，因此返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树只包含根结点、左子结点和右子结点</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2237.计算街道上满足所需亮度的位置数量",
        "hardRate": "MEDIUM",
        "passRate": "74.52%",
        "problemsUrl": "https://leetcode.cn/problems/count-positions-on-street-with-required-brightness/",
        "solutionsUrl": "https://leetcode.cn/problems/count-positions-on-street-with-required-brightness/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2238.司机成为乘客的次数",
        "hardRate": "MEDIUM",
        "passRate": "69.43%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-times-a-driver-was-a-passenger/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-times-a-driver-was-a-passenger/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2239.找到最接近 0 的数字",
        "hardRate": "EASY",
        "passRate": "53.46%",
        "problemsUrl": "https://leetcode.cn/problems/find-closest-number-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/find-closest-number-to-zero/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;，请你返回 <code>nums</code>&nbsp;中最 <strong>接近</strong>&nbsp;<code>0</code>&nbsp;的数字。如果有多个答案，请你返回它们中的 <strong>最大值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [-4,-2,1,4,8]\n<b>输出：</b>1\n<strong>解释：</strong>\n-4 到 0 的距离为 |-4| = 4 。\n-2 到 0 的距离为 |-2| = 2 。\n1 到 0 的距离为 |1| = 1 。\n4 到 0 的距离为 |4| = 4 。\n8 到 0 的距离为 |8| = 8 。\n所以，数组中距离 0 最近的数字为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,-1,1]\n<b>输出：</b>1\n<b>解释：</b>1 和 -1 都是距离 0 最近的数字，所以返回较大值 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2240.买钢笔和铅笔的方案数",
        "hardRate": "MEDIUM",
        "passRate": "57.42%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-buy-pens-and-pencils/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-buy-pens-and-pencils/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>total</code>&nbsp;，表示你拥有的总钱数。同时给你两个整数&nbsp;<code>cost1</code> 和&nbsp;<code>cost2</code>&nbsp;，分别表示一支钢笔和一支铅笔的价格。你可以花费你部分或者全部的钱，去买任意数目的两种笔。</p>\n\n<p>请你返回购买钢笔和铅笔的&nbsp;<strong>不同方案数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>total = 20, cost1 = 10, cost2 = 5\n<b>输出：</b>9\n<b>解释：</b>一支钢笔的价格为 10 ，一支铅笔的价格为 5 。\n- 如果你买 0 支钢笔，那么你可以买 0 ，1 ，2 ，3 或者 4 支铅笔。\n- 如果你买 1 支钢笔，那么你可以买 0 ，1 或者 2 支铅笔。\n- 如果你买 2 支钢笔，那么你没法买任何铅笔。\n所以买钢笔和铅笔的总方案数为 5 + 3 + 1 = 9 种。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>total = 5, cost1 = 10, cost2 = 10\n<b>输出：</b>1\n<b>解释：</b>钢笔和铅笔的价格都为 10 ，都比拥有的钱数多，所以你没法购买任何文具。所以只有 1 种方案：买 0 支钢笔和 0 支铅笔。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= total, cost1, cost2 &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2241.设计一个 ATM 机器",
        "hardRate": "MEDIUM",
        "passRate": "36.25%",
        "problemsUrl": "https://leetcode.cn/problems/design-an-atm-machine/",
        "solutionsUrl": "https://leetcode.cn/problems/design-an-atm-machine/solution",
        "problemsDesc": "<p>一个 ATM 机器，存有&nbsp;<code>5</code>&nbsp;种面值的钞票：<code>20</code>&nbsp;，<code>50</code>&nbsp;，<code>100</code>&nbsp;，<code>200</code>&nbsp;和&nbsp;<code>500</code>&nbsp;美元。初始时，ATM 机是空的。用户可以用它存或者取任意数目的钱。</p>\n\n<p>取款时，机器会优先取 <b>较大</b>&nbsp;数额的钱。</p>\n\n<ul>\n\t<li>比方说，你想取&nbsp;<code>$300</code>&nbsp;，并且机器里有&nbsp;<code>2</code>&nbsp;张 <code>$50</code>&nbsp;的钞票，<code>1</code>&nbsp;张&nbsp;<code>$100</code>&nbsp;的钞票和<code>1</code>&nbsp;张&nbsp;<code>$200</code>&nbsp;的钞票，那么机器会取出&nbsp;<code>$100</code> 和&nbsp;<code>$200</code>&nbsp;的钞票。</li>\n\t<li>但是，如果你想取&nbsp;<code>$600</code>&nbsp;，机器里有&nbsp;<code>3</code>&nbsp;张&nbsp;<code>$200</code>&nbsp;的钞票和<code>1</code>&nbsp;张&nbsp;<code>$500</code>&nbsp;的钞票，那么取款请求会被拒绝，因为机器会先取出&nbsp;<code>$500</code>&nbsp;的钞票，然后无法取出剩余的&nbsp;<code>$100</code>&nbsp;。注意，因为有&nbsp;<code>$500</code>&nbsp;钞票的存在，机器&nbsp;<strong>不能</strong>&nbsp;取&nbsp;<code>$200</code>&nbsp;的钞票。</li>\n</ul>\n\n<p>请你实现 ATM 类：</p>\n\n<ul>\n\t<li><code>ATM()</code>&nbsp;初始化 ATM 对象。</li>\n\t<li><code>void deposit(int[] banknotesCount)</code>&nbsp;分别存入&nbsp;<code>$20</code>&nbsp;，<code>$50</code>，<code>$100</code>，<code>$200</code>&nbsp;和&nbsp;<code>$500</code>&nbsp;钞票的数目。</li>\n\t<li><code>int[] withdraw(int amount)</code>&nbsp;返回一个长度为&nbsp;<code>5</code>&nbsp;的数组，分别表示&nbsp;<code>$20</code>&nbsp;，<code>$50</code>，<code>$100</code>&nbsp;，<code>$200</code>&nbsp;和&nbsp;<code>$500</code>&nbsp;钞票的数目，并且更新 ATM 机里取款后钞票的剩余数量。如果无法取出指定数额的钱，请返回&nbsp;<code>[-1]</code>&nbsp;（这种情况下 <strong>不</strong>&nbsp;取出任何钞票）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"ATM\", \"deposit\", \"withdraw\", \"deposit\", \"withdraw\", \"withdraw\"]\n[[], [[0,0,1,2,1]], [600], [[0,1,0,1,1]], [600], [550]]\n<strong>输出：</strong>\n[null, null, [0,0,1,0,1], null, [-1], [0,1,0,0,1]]\n\n<strong>解释：</strong>\nATM atm = new ATM();\natm.deposit([0,0,1,2,1]); // 存入 1 张 $100 ，2 张 $200 和 1 张 $500 的钞票。\natm.withdraw(600);        // 返回 [0,0,1,0,1] 。机器返回 1 张 $100 和 1 张 $500 的钞票。机器里剩余钞票的数量为 [0,0,0,2,0] 。\natm.deposit([0,1,0,1,1]); // 存入 1 张 $50 ，1 张 $200 和 1 张 $500 的钞票。\n                          // 机器中剩余钞票数量为 [0,1,0,3,1] 。\natm.withdraw(600);        // 返回 [-1] 。机器会尝试取出 $500 的钞票，然后无法得到剩余的 $100 ，所以取款请求会被拒绝。\n                          // 由于请求被拒绝，机器中钞票的数量不会发生改变。\natm.withdraw(550);        // 返回 [0,1,0,0,1] ，机器会返回 1 张 $50 的钞票和 1 张 $500 的钞票。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>banknotesCount.length == 5</code></li>\n\t<li><code>0 &lt;= banknotesCount[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= amount &lt;= 10<sup>9</sup></code></li>\n\t<li><strong>总共</strong>&nbsp;最多有&nbsp;<code>5000</code>&nbsp;次&nbsp;<code>withdraw</code> 和&nbsp;<code>deposit</code>&nbsp;的调用。</li>\n\t<li><span style=\"\">函数 </span><code>withdraw</code> 和&nbsp;<code>deposit</code>&nbsp;至少各有 <strong>一次&nbsp;</strong>调用。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2242.节点序列的最大得分",
        "hardRate": "HARD",
        "passRate": "33.98%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-of-a-node-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-of-a-node-sequence/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>n</code>&nbsp;个节点的&nbsp;<strong>无向图</strong>&nbsp;，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>scores</code>&nbsp;，其中&nbsp;<code>scores[i]</code>&nbsp;是第 <code>i</code>&nbsp;个节点的分数。同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;，表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条&nbsp;<strong>无向</strong>&nbsp;边。</p>\n\n<p>一个合法的节点序列如果满足以下条件，我们称它是 <strong>合法的</strong>&nbsp;：</p>\n\n<ul>\n\t<li>序列中每&nbsp;<b>相邻</b>&nbsp;节点之间有边相连。</li>\n\t<li>序列中没有节点出现超过一次。</li>\n</ul>\n\n<p>节点序列的分数定义为序列中节点分数之 <strong>和</strong> 。</p>\n\n<p>请你返回一个长度为 <code>4</code>&nbsp;的合法节点序列的最大分数。如果不存在这样的序列，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/15/ex1new3.png\" style=\"width: 290px; height: 215px;\" /></p>\n\n<pre>\n<b>输入：</b>scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\n<b>输出：</b>24\n<b>解释：</b>上图为输入的图，节点序列为 [0,1,2,3] 。\n节点序列的分数为 5 + 2 + 9 + 8 = 24 。\n观察可知，没有其他节点序列得分和超过 24 。\n注意节点序列 [3,1,2,0] 和 [1,0,2,3] 也是合法的，且分数为 24 。\n序列 [0,3,2,4] 不是合法的，因为没有边连接节点 0 和 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/17/ex2.png\" style=\"width: 333px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]\n<b>输出：</b>-1\n<b>解释：</b>上图为输入的图。\n没有长度为 4 的合法序列，所以我们返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == scores.length</code></li>\n\t<li><code>4 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= scores[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>不会有重边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2243.计算字符串的数字和",
        "hardRate": "EASY",
        "passRate": "63.52%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-digit-sum-of-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-digit-sum-of-a-string/solution",
        "problemsDesc": "<p>给你一个由若干数字（<code>0</code> - <code>9</code>）组成的字符串 <code>s</code> ，和一个整数。</p>\n\n<p>如果 <code>s</code> 的长度大于 <code>k</code> ，则可以执行一轮操作。在一轮操作中，需要完成以下工作：</p>\n\n<ol>\n\t<li>将 <code>s</code> <strong>拆分 </strong>成长度为 <code>k</code> 的若干 <strong>连续数字组</strong> ，使得前 <code>k</code> 个字符都分在第一组，接下来的 <code>k</code> 个字符都分在第二组，依此类推。<strong>注意</strong>，最后一个数字组的长度可以小于 <code>k</code> 。</li>\n\t<li>用表示每个数字组中所有数字之和的字符串来 <strong>替换</strong> 对应的数字组。例如，<code>\"346\"</code> 会替换为 <code>\"13\"</code> ，因为 <code>3 + 4 + 6 = 13</code> 。</li>\n\t<li><strong>合并</strong> 所有组以形成一个新字符串。如果新字符串的长度大于 <code>k</code> 则重复第一步。</li>\n</ol>\n\n<p>返回在完成所有轮操作后的 <code>s</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"11111222223\", k = 3\n<strong>输出：</strong>\"135\"\n<strong>解释：</strong>\n- 第一轮，将 s 分成：\"111\"、\"112\"、\"222\" 和 \"23\" 。\n  接着，计算每一组的数字和：1 + 1 + 1 = 3、1 + 1 + 2 = 4、2 + 2 + 2 = 6 和 2 + 3 = 5 。 \n&nbsp; 这样，s 在第一轮之后变成 \"3\" + \"4\" + \"6\" + \"5\" = \"3465\" 。\n- 第二轮，将 s 分成：\"346\" 和 \"5\" 。\n&nbsp; 接着，计算每一组的数字和：3 + 4 + 6 = 13 、5 = 5 。\n&nbsp; 这样，s 在第二轮之后变成 \"13\" + \"5\" = \"135\" 。 \n现在，s.length &lt;= k ，所以返回 \"135\" 作为答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"00000000\", k = 3\n<strong>输出：</strong>\"000\"\n<strong>解释：</strong>\n将 \"000\", \"000\", and \"00\".\n接着，计算每一组的数字和：0 + 0 + 0 = 0 、0 + 0 + 0 = 0 和 0 + 0 = 0 。 \ns 变为 \"0\" + \"0\" + \"0\" = \"000\" ，其长度等于 k ，所以返回 \"000\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>2 &lt;= k &lt;= 100</code></li>\n\t<li><code>s</code> 仅由数字（<code>0</code> - <code>9</code>）组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2244.完成所有任务需要的最少轮数",
        "hardRate": "MEDIUM",
        "passRate": "57.13%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-rounds-to-complete-all-tasks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-rounds-to-complete-all-tasks/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>tasks</code> ，其中 <code>tasks[i]</code> 表示任务的难度级别。在每一轮中，你可以完成 2 个或者 3 个 <strong>相同难度级别</strong> 的任务。</p>\n\n<p>返回完成所有任务需要的 <strong>最少</strong> 轮数，如果无法完成所有任务，返回<em> </em><code>-1</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>tasks = [2,2,3,3,2,4,4,4,4,4]\n<strong>输出：</strong>4\n<strong>解释：</strong>要想完成所有任务，一个可能的计划是：\n- 第一轮，完成难度级别为 2 的 3 个任务。 \n- 第二轮，完成难度级别为 3 的 2 个任务。 \n- 第三轮，完成难度级别为 4 的 3 个任务。 \n- 第四轮，完成难度级别为 4 的 2 个任务。 \n可以证明，无法在少于 4 轮的情况下完成所有任务，所以答案为 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>tasks = [2,3,3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>难度级别为 2 的任务只有 1 个，但每一轮执行中，只能选择完成 2 个或者 3 个相同难度级别的任务。因此，无法完成所有任务，答案为 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= tasks[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2245.转角路径的乘积中最多能有几个尾随零",
        "hardRate": "MEDIUM",
        "passRate": "36.08%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-trailing-zeros-in-a-cornered-path/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-trailing-zeros-in-a-cornered-path/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>grid</code> ，大小为 <code>m x n</code>，其中每个单元格都含一个正整数。</p>\n\n<p><strong>转角路径</strong> 定义为：包含至多一个弯的一组相邻单元。具体而言，路径应该完全 <strong>向水平方向</strong> 或者 <strong>向竖直方向</strong> 移动过弯（如果存在弯），而不能访问之前访问过的单元格。在过弯之后，路径应当完全朝 <strong>另一个</strong> 方向行进：如果之前是向水平方向，那么就应该变为向竖直方向；反之亦然。当然，同样不能访问之前已经访问过的单元格。</p>\n\n<p>一条路径的 <strong>乘积</strong> 定义为：路径上所有值的乘积。</p>\n\n<p>请你从 <code>grid</code> 中找出一条乘积中尾随零数目最多的转角路径，并返回该路径中尾随零的数目。</p>\n\n<p>注意：</p>\n\n<ul>\n\t<li><strong>水平</strong> 移动是指向左或右移动。</li>\n\t<li><strong>竖直 </strong>移动是指向上或下移动。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/23/ex1new2.jpg\" style=\"width: 577px; height: 190px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]\n<strong>输出：</strong>3\n<strong>解释：</strong>左侧的图展示了一条有效的转角路径。\n其乘积为 15 * 20 * 6 * 1 * 10 = 18000 ，共计 3 个尾随零。\n可以证明在这条转角路径的乘积中尾随零数目最多。\n\n中间的图不是一条有效的转角路径，因为它有不止一个弯。\n右侧的图也不是一条有效的转角路径，因为它需要重复访问已经访问过的单元格。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/25/ex2.jpg\" style=\"width: 150px; height: 157px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[4,3,2],[7,6,1],[8,8,8]]\n<strong>输出：</strong>0\n<strong>解释：</strong>网格如上图所示。\n不存在乘积含尾随零的转角路径。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2246.相邻字符不同的最长路径",
        "hardRate": "HARD",
        "passRate": "46.99%",
        "problemsUrl": "https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/solution",
        "problemsDesc": "<p>给你一棵 <strong>树</strong>（即一个连通、无向、无环图），根节点是节点 <code>0</code> ，这棵树由编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个节点组成。用下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>parent</code> 来表示这棵树，其中 <code>parent[i]</code> 是节点 <code>i</code> 的父节点，由于节点 <code>0</code> 是根节点，所以 <code>parent[0] == -1</code> 。</p>\n\n<p>另给你一个字符串 <code>s</code> ，长度也是 <code>n</code> ，其中 <code>s[i]</code> 表示分配给节点 <code>i</code> 的字符。</p>\n\n<p>请你找出路径上任意一对相邻节点都没有分配到相同字符的 <strong>最长路径</strong> ，并返回该路径的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/25/testingdrawio.png\" style=\"width: 201px; height: 241px;\" /></p>\n\n<pre>\n<strong>输入：</strong>parent = [-1,0,0,1,1,2], s = \"abacbe\"\n<strong>输出：</strong>3\n<strong>解释：</strong>任意一对相邻节点字符都不同的最长路径是：0 -&gt; 1 -&gt; 3 。该路径的长度是 3 ，所以返回 3 。\n可以证明不存在满足上述条件且比 3 更长的路径。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/25/graph2drawio.png\" style=\"width: 201px; height: 221px;\" /></p>\n\n<pre>\n<strong>输入：</strong>parent = [-1,0,0,0], s = \"aabc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>任意一对相邻节点字符都不同的最长路径是：2 -&gt; 0 -&gt; 3 。该路径的长度为 3 ，所以返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == parent.length == s.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li>对所有 <code>i &gt;= 1</code> ，<code>0 &lt;= parent[i] &lt;= n - 1</code> 均成立</li>\n\t<li><code>parent[0] == -1</code></li>\n\t<li><code>parent</code> 表示一棵有效的树</li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2247.K 条高速公路的最大旅行费用",
        "hardRate": "HARD",
        "passRate": "56.51%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-cost-of-trip-with-k-highways/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-cost-of-trip-with-k-highways/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2248.多个数组求交集",
        "hardRate": "EASY",
        "passRate": "67.09%",
        "problemsUrl": "https://leetcode.cn/problems/intersection-of-multiple-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/intersection-of-multiple-arrays/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 是由 <strong>不同</strong> 正整数组成的一个非空数组，按 <strong>升序排列</strong> 返回一个数组，数组中的每个元素在 <code>nums</code>&nbsp;<strong>所有数组</strong> 中都出现过。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[<em><strong>3</strong></em>,1,2,<em><strong>4</strong></em>,5],[1,2,<em><strong>3</strong></em>,<em><strong>4</strong></em>],[<em><strong>3</strong></em>,<em><strong>4</strong></em>,5,6]]\n<strong>输出：</strong>[3,4]\n<strong>解释：</strong>\nnums[0] = [<em><strong>3</strong></em>,1,2,<em><strong>4</strong></em>,5]，nums[1] = [1,2,<em><strong>3</strong></em>,<em><strong>4</strong></em>]，nums[2] = [<em><strong>3</strong></em>,<em><strong>4</strong></em>,5,6]，在 nums 中每个数组中都出现的数字是 3 和 4 ，所以返回 [3,4] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[1,2,3],[4,5,6]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>\n不存在同时出现在 nums[0] 和 nums[1] 的整数，所以返回一个空列表 [] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= sum(nums[i].length) &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i][j] &lt;= 1000</code></li>\n\t<li><code>nums[i]</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2249.统计圆内格点数目",
        "hardRate": "MEDIUM",
        "passRate": "53.31%",
        "problemsUrl": "https://leetcode.cn/problems/count-lattice-points-inside-a-circle/",
        "solutionsUrl": "https://leetcode.cn/problems/count-lattice-points-inside-a-circle/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>circles</code> ，其中 <code>circles[i] = [x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub>]</code> 表示网格上圆心为 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> 且半径为 <code>r<sub>i</sub></code> 的第 <code>i</code> 个圆，返回出现在<strong> 至少一个 </strong>圆内的 <strong>格点数目</strong> 。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><strong>格点</strong> 是指整数坐标对应的点。</li>\n\t<li><strong>圆周上的点</strong> 也被视为出现在圆内的点。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/exa-11.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>circles = [[2,2,1]]\n<strong>输出：</strong>5\n<strong>解释：</strong>\n给定的圆如上图所示。\n出现在圆内的格点为 (1, 2)、(2, 1)、(2, 2)、(2, 3) 和 (3, 2)，在图中用绿色标识。\n像 (1, 1) 和 (1, 3) 这样用红色标识的点，并未出现在圆内。\n因此，出现在至少一个圆内的格点数目是 5 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/exa-22.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>circles = [[2,2,2],[3,4,1]]\n<strong>输出：</strong>16\n<strong>解释：</strong>\n给定的圆如上图所示。\n共有 16 个格点出现在至少一个圆内。\n其中部分点的坐标是 (0, 2)、(2, 0)、(2, 4)、(3, 2) 和 (4, 4) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= circles.length &lt;= 200</code></li>\n\t<li><code>circles[i].length == 3</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 100</code></li>\n\t<li><code>1 &lt;= r<sub>i</sub> &lt;= min(x<sub>i</sub>, y<sub>i</sub>)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2250.统计包含每个点的矩形数目",
        "hardRate": "MEDIUM",
        "passRate": "34.89%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-rectangles-containing-each-point/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-rectangles-containing-each-point/solution",
        "problemsDesc": "<p>给你一个二维整数数组&nbsp;<code>rectangles</code>&nbsp;，其中&nbsp;<code>rectangles[i] = [l<sub>i</sub>, h<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个矩形长为&nbsp;<code>l<sub>i</sub></code>&nbsp;高为&nbsp;<code>h<sub>i</sub></code>&nbsp;。给你一个二维整数数组&nbsp;<code>points</code>&nbsp;，其中&nbsp;<code>points[j] = [x<sub>j</sub>, y<sub>j</sub>]</code>&nbsp;是坐标为&nbsp;<code>(x<sub>j</sub>, y<sub>j</sub>)</code>&nbsp;的一个点。</p>\n\n<p>第&nbsp;<code>i</code>&nbsp;个矩形的 <strong>左下角</strong>&nbsp;在&nbsp;<code>(0, 0)</code>&nbsp;处，<strong>右上角</strong>&nbsp;在&nbsp;<code>(l<sub>i</sub>, h<sub>i</sub>)</code>&nbsp;。</p>\n\n<p>请你返回一个整数数组<em>&nbsp;</em><code>count</code>&nbsp;，长度为&nbsp;<code>points.length</code>，其中<em>&nbsp;</em><code>count[j]</code>是 <strong>包含</strong> 第<em>&nbsp;</em><code>j</code>&nbsp;个点的矩形数目。</p>\n\n<p>如果&nbsp;<code>0 &lt;= x<sub>j</sub> &lt;= l<sub>i</sub></code> 且&nbsp;<code>0 &lt;= y<sub>j</sub> &lt;= h<sub>i</sub></code>&nbsp;，那么我们说第&nbsp;<code>i</code>&nbsp;个矩形包含第&nbsp;<code>j</code>&nbsp;个点。如果一个点刚好在矩形的 <strong>边上</strong>&nbsp;，这个点也被视为被矩形包含。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/example1.png\" style=\"width: 300px; height: 509px;\"></p>\n\n<pre><b>输入：</b>rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]\n<b>输出：</b>[2,1]\n<b>解释：</b>\n第一个矩形不包含任何点。\n第二个矩形只包含一个点 (2, 1) 。\n第三个矩形包含点 (2, 1) 和 (1, 4) 。\n包含点 (2, 1) 的矩形数目为 2 。\n包含点 (1, 4) 的矩形数目为 1 。\n所以，我们返回 [2, 1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/example2.png\" style=\"width: 300px; height: 312px;\"></p>\n\n<pre><b>输入：</b>rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]\n<b>输出：</b>[1,3]\n<strong>解释：\n</strong>第一个矩形只包含点 (1, 1) 。\n第二个矩形只包含点 (1, 1) 。\n第三个矩形包含点 (1, 3) 和 (1, 1) 。\n包含点 (1, 3) 的矩形数目为 1 。\n包含点 (1, 1) 的矩形数目为 3 。\n所以，我们返回 [1, 3] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rectangles.length, points.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>rectangles[i].length == points[j].length == 2</code></li>\n\t<li><code>1 &lt;= l<sub>i</sub>, x<sub>j</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= h<sub>i</sub>, y<sub>j</sub> &lt;= 100</code></li>\n\t<li>所有&nbsp;<code>rectangles</code>&nbsp;<strong>互不相同</strong>&nbsp;。</li>\n\t<li>所有&nbsp;<code>points</code> <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2251.花期内花的数目",
        "hardRate": "HARD",
        "passRate": "49.10%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-flowers-in-full-bloom/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-flowers-in-full-bloom/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>flowers</code>&nbsp;，其中&nbsp;<code>flowers[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;朵花的 <strong>花期</strong>&nbsp;从&nbsp;<code>start<sub>i</sub></code>&nbsp;到&nbsp;<code>end<sub>i</sub></code>&nbsp;（都 <strong>包含</strong>）。同时给你一个下标从 <strong>0</strong>&nbsp;开始大小为 <code>n</code>&nbsp;的整数数组&nbsp;<code>persons</code>&nbsp;，<code>persons[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个人来看花的时间。</p>\n\n<p>请你返回一个大小为 <code>n</code>&nbsp;的整数数组<em>&nbsp;</em><code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>是第&nbsp;<code>i</code>&nbsp;个人到达时在花期内花的&nbsp;<strong>数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/ex1new.jpg\" style=\"width: 550px; height: 216px;\"></p>\n\n<pre><b>输入：</b>flowers = [[1,6],[3,7],[9,12],[4,13]], persons = [2,3,7,11]\n<b>输出：</b>[1,2,2,2]\n<strong>解释：</strong>上图展示了每朵花的花期时间，和每个人的到达时间。\n对每个人，我们返回他们到达时在花期内花的数目。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/ex2new.jpg\" style=\"width: 450px; height: 195px;\"></p>\n\n<pre><b>输入：</b>flowers = [[1,10],[3,3]], persons = [3,3,2]\n<b>输出：</b>[2,2,1]\n<b>解释：</b>上图展示了每朵花的花期时间，和每个人的到达时间。\n对每个人，我们返回他们到达时在花期内花的数目。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= flowers.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>flowers[i].length == 2</code></li>\n\t<li><code>1 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= persons.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= persons[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2252.表的动态旋转",
        "hardRate": "HARD",
        "passRate": "57.31%",
        "problemsUrl": "https://leetcode.cn/problems/dynamic-pivoting-of-a-table/",
        "solutionsUrl": "https://leetcode.cn/problems/dynamic-pivoting-of-a-table/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2253.动态取消表的旋转",
        "hardRate": "HARD",
        "passRate": "71.20%",
        "problemsUrl": "https://leetcode.cn/problems/dynamic-unpivoting-of-a-table/",
        "solutionsUrl": "https://leetcode.cn/problems/dynamic-unpivoting-of-a-table/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2254.设计视频共享平台",
        "hardRate": "HARD",
        "passRate": "61.30%",
        "problemsUrl": "https://leetcode.cn/problems/design-video-sharing-platform/",
        "solutionsUrl": "https://leetcode.cn/problems/design-video-sharing-platform/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2255.统计是给定字符串前缀的字符串数目",
        "hardRate": "EASY",
        "passRate": "78.61%",
        "problemsUrl": "https://leetcode.cn/problems/count-prefixes-of-a-given-string/",
        "solutionsUrl": "https://leetcode.cn/problems/count-prefixes-of-a-given-string/solution",
        "problemsDesc": "<p>给你一个字符串数组&nbsp;<code>words</code>&nbsp;和一个字符串&nbsp;<code>s</code>&nbsp;，其中&nbsp;<code>words[i]</code> 和&nbsp;<code>s</code>&nbsp;只包含 <strong>小写英文字母</strong>&nbsp;。</p>\n\n<p>请你返回 <code>words</code>&nbsp;中是字符串 <code>s</code>&nbsp;<strong>前缀&nbsp;</strong>的 <strong>字符串数目</strong>&nbsp;。</p>\n\n<p>一个字符串的 <strong>前缀</strong>&nbsp;是出现在字符串开头的子字符串。<strong>子字符串</strong>&nbsp;是一个字符串中的连续一段字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>words = [\"a\",\"b\",\"c\",\"ab\",\"bc\",\"abc\"], s = \"abc\"\n<b>输出：</b>3\n<strong>解释：</strong>\nwords 中是 s = \"abc\" 前缀的字符串为：\n\"a\" ，\"ab\" 和 \"abc\" 。\n所以 words 中是字符串 s 前缀的字符串数目为 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>words = [\"a\",\"a\"], s = \"aa\"\n<b>输出：</b>2\n<strong>解释：\n</strong>两个字符串都是 s 的前缀。\n注意，相同的字符串可能在 words 中出现多次，它们应该被计数多次。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length, s.length &lt;= 10</code></li>\n\t<li><code>words[i]</code> 和&nbsp;<code>s</code>&nbsp;<strong>只</strong>&nbsp;包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2256.最小平均差",
        "hardRate": "MEDIUM",
        "passRate": "36.76%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-average-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-average-difference/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>下标 <code>i</code>&nbsp;处的 <strong>平均差</strong>&nbsp;指的是 <code>nums</code>&nbsp;中 <strong>前</strong>&nbsp;<code>i + 1</code>&nbsp;个元素平均值和 <strong>后</strong>&nbsp;<code>n - i - 1</code>&nbsp;个元素平均值的 <strong>绝对差</strong>&nbsp;。两个平均值都需要 <strong>向下取整</strong>&nbsp;到最近的整数。</p>\n\n<p>请你返回产生 <strong>最小平均差</strong>&nbsp;的下标。如果有多个下标最小平均差相等，请你返回 <strong>最小</strong>&nbsp;的一个下标。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>两个数的<strong>&nbsp;绝对差</strong>&nbsp;是两者差的绝对值。</li>\n\t<li>&nbsp;<code>n</code>&nbsp;个元素的平均值是 <code>n</code>&nbsp;个元素之 <strong>和</strong>&nbsp;除以（整数除法）&nbsp;<code>n</code>&nbsp;。</li>\n\t<li><code>0</code>&nbsp;个元素的平均值视为&nbsp;<code>0</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,5,3,9,5,3]\n<b>输出：</b>3\n<strong>解释：</strong>\n- 下标 0 处的平均差为：|2 / 1 - (5 + 3 + 9 + 5 + 3) / 5| = |2 / 1 - 25 / 5| = |2 - 5| = 3 。\n- 下标 1 处的平均差为：|(2 + 5) / 2 - (3 + 9 + 5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2 。\n- 下标 2 处的平均差为：|(2 + 5 + 3) / 3 - (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2 。\n- 下标 3 处的平均差为：|(2 + 5 + 3 + 9) / 4 - (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0 。 \n- 下标 4 处的平均差为：|(2 + 5 + 3 + 9 + 5) / 5 - 3 / 1| = |24 / 5 - 3 / 1| = |4 - 3| = 1 。\n- 下标 5 处的平均差为：|(2 + 5 + 3 + 9 + 5 + 3) / 6 - 0| = |27 / 6 - 0| = |4 - 0| = 4 。\n下标 3 处的平均差为最小平均差，所以返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [0]\n<b>输出：</b>0\n<strong>解释：</strong>\n唯一的下标是 0 ，所以我们返回 0 。\n下标 0 处的平均差为：|0 / 1 - 0| = |0 - 0| = 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2257.统计网格图中没有被保卫的格子数",
        "hardRate": "MEDIUM",
        "passRate": "52.69%",
        "problemsUrl": "https://leetcode.cn/problems/count-unguarded-cells-in-the-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/count-unguarded-cells-in-the-grid/solution",
        "problemsDesc": "<p>给你两个整数&nbsp;<code>m</code>&nbsp;和&nbsp;<code>n</code>&nbsp;表示一个下标从<strong>&nbsp;0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;网格图。同时给你两个二维整数数组&nbsp;<code>guards</code> 和&nbsp;<code>walls</code>&nbsp;，其中&nbsp;<code>guards[i] = [row<sub>i</sub>, col<sub>i</sub>]</code>&nbsp;且&nbsp;<code>walls[j] = [row<sub>j</sub>, col<sub>j</sub>]</code>&nbsp;，分别表示第 <code>i</code>&nbsp;个警卫和第 <code>j</code>&nbsp;座墙所在的位置。</p>\n\n<p>一个警卫能看到 4 个坐标轴方向（即东、南、西、北）的 <strong>所有</strong>&nbsp;格子，除非他们被一座墙或者另外一个警卫 <strong>挡住</strong>&nbsp;了视线。如果一个格子能被 <strong>至少</strong>&nbsp;一个警卫看到，那么我们说这个格子被 <strong>保卫</strong>&nbsp;了。</p>\n\n<p>请你返回空格子中，有多少个格子是 <strong>没被保卫</strong>&nbsp;的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/example1drawio2.png\" style=\"width: 300px; height: 204px;\"></p>\n\n<pre><b>输入：</b>m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]\n<b>输出：</b>7\n<strong>解释：</strong>上图中，被保卫和没有被保卫的格子分别用红色和绿色表示。\n总共有 7 个没有被保卫的格子，所以我们返回 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/example2drawio.png\" style=\"width: 200px; height: 201px;\"></p>\n\n<pre><b>输入：</b>m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]\n<b>输出：</b>4\n<b>解释：</b>上图中，没有被保卫的格子用绿色表示。\n总共有 4 个没有被保卫的格子，所以我们返回 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= guards.length, walls.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>2 &lt;= guards.length + walls.length &lt;= m * n</code></li>\n\t<li><code>guards[i].length == walls[j].length == 2</code></li>\n\t<li><code>0 &lt;= row<sub>i</sub>, row<sub>j</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= col<sub>i</sub>, col<sub>j</sub> &lt; n</code></li>\n\t<li><code>guards</code>&nbsp;和&nbsp;<code>walls</code>&nbsp;中所有位置 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2258.逃离火灾",
        "hardRate": "HARD",
        "passRate": "35.95%",
        "problemsUrl": "https://leetcode.cn/problems/escape-the-spreading-fire/",
        "solutionsUrl": "https://leetcode.cn/problems/escape-the-spreading-fire/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始大小为 <code>m x n</code>&nbsp;的二维整数数组&nbsp;<code>grid</code>&nbsp;，它表示一个网格图。每个格子为下面 3 个值之一：</p>\n\n<ul>\n\t<li><code>0</code> 表示草地。</li>\n\t<li><code>1</code> 表示着火的格子。</li>\n\t<li><code>2</code>&nbsp;表示一座墙，你跟火都不能通过这个格子。</li>\n</ul>\n\n<p>一开始你在最左上角的格子&nbsp;<code>(0, 0)</code>&nbsp;，你想要到达最右下角的安全屋格子&nbsp;<code>(m - 1, n - 1)</code>&nbsp;。每一分钟，你可以移动到&nbsp;<strong>相邻</strong>&nbsp;的草地格子。每次你移动 <strong>之后</strong>&nbsp;，着火的格子会扩散到所有不是墙的 <strong>相邻</strong>&nbsp;格子。</p>\n\n<p>请你返回你在初始位置可以停留的 <strong>最多 </strong>分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 <code>-1</code>&nbsp;。如果不管你在初始位置停留多久，你 <strong>总是</strong>&nbsp;能到达安全屋，请你返回&nbsp;<code>10<sup>9</sup></code>&nbsp;。</p>\n\n<p>注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。</p>\n\n<p>如果两个格子有共同边，那么它们为 <strong>相邻</strong>&nbsp;格子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg\" style=\"width: 650px; height: 404px;\"></p>\n\n<pre><b>输入：</b>grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]\n<b>输出：</b>3\n<b>解释：</b>上图展示了你在初始位置停留 3 分钟后的情形。\n你仍然可以安全到达安全屋。\n停留超过 3 分钟会让你无法安全到达安全屋。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg\" style=\"width: 515px; height: 150px;\"></p>\n\n<pre><b>输入：</b>grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]\n<b>输出：</b>-1\n<b>解释：</b>上图展示了你马上开始朝安全屋移动的情形。\n火会蔓延到你可以移动的所有格子，所以无法安全到达安全屋。\n所以返回 -1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg\" style=\"width: 174px; height: 150px;\"></p>\n\n<pre><b>输入：</b>grid = [[0,0,0],[2,2,0],[1,2,0]]\n<b>输出：</b>1000000000\n<b>解释：</b>上图展示了初始网格图。\n注意，由于火被墙围了起来，所以无论如何你都能安全到达安全屋。\n所以返回 10<sup>9</sup> 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>4 &lt;= m * n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>grid[i][j]</code>&nbsp;是&nbsp;<code>0</code>&nbsp;，<code>1</code>&nbsp;或者&nbsp;<code>2</code>&nbsp;。</li>\n\t<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2259.移除指定数字得到的最大结果",
        "hardRate": "EASY",
        "passRate": "50.10%",
        "problemsUrl": "https://leetcode.cn/problems/remove-digit-from-number-to-maximize-result/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-digit-from-number-to-maximize-result/solution",
        "problemsDesc": "<p>给你一个表示某个正整数的字符串 <code>number</code> 和一个字符 <code>digit</code> 。</p>\n\n<p>从 <code>number</code> 中 <strong>恰好</strong> 移除 <strong>一个</strong> 等于&nbsp;<code>digit</code> 的字符后，找出并返回按 <strong>十进制</strong> 表示 <strong>最大</strong> 的结果字符串。生成的测试用例满足 <code>digit</code> 在 <code>number</code> 中出现至少一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"123\", digit = \"3\"\n<strong>输出：</strong>\"12\"\n<strong>解释：</strong>\"123\" 中只有一个 '3' ，在移除 '3' 之后，结果为 \"12\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"1231\", digit = \"1\"\n<strong>输出：</strong>\"231\"\n<strong>解释：</strong>可以移除第一个 '1' 得到 \"231\" 或者移除第二个 '1' 得到 \"123\" 。\n由于 231 &gt; 123 ，返回 \"231\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"551\", digit = \"5\"\n<strong>输出：</strong>\"51\"\n<strong>解释：</strong>可以从 \"551\" 中移除第一个或者第二个 '5' 。\n两种方案的结果都是 \"51\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= number.length &lt;= 100</code></li>\n\t<li><code>number</code> 由数字 <code>'1'</code> 到 <code>'9'</code> 组成</li>\n\t<li><code>digit</code> 是 <code>'1'</code> 到 <code>'9'</code> 中的一个数字</li>\n\t<li><code>digit</code> 在 <code>number</code> 中出现至少一次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2260.必须拿起的最小连续卡牌数",
        "hardRate": "MEDIUM",
        "passRate": "51.19%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-consecutive-cards-to-pick-up/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-consecutive-cards-to-pick-up/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>cards</code> ，其中 <code>cards[i]</code> 表示第 <code>i</code> 张卡牌的 <strong>值</strong> 。如果两张卡牌的值相同，则认为这一对卡牌 <strong>匹配</strong> 。</p>\n\n<p>返回你必须拿起的最小连续卡牌数，以使在拿起的卡牌中有一对匹配的卡牌。如果无法得到一对匹配的卡牌，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>cards = [3,4,2,3,4,7]\n<strong>输出：</strong>4\n<strong>解释：</strong>拿起卡牌 [3,4,2,3] 将会包含一对值为 3 的匹配卡牌。注意，拿起 [4,2,3,4] 也是最优方案。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>cards = [1,0,5,3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法找出含一对匹配卡牌的一组连续卡牌。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= cards.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= cards[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2261.含最多 K 个可整除元素的子数组",
        "hardRate": "MEDIUM",
        "passRate": "52.92%",
        "problemsUrl": "https://leetcode.cn/problems/k-divisible-elements-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/k-divisible-elements-subarrays/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>p</code> ，找出并返回满足要求的不同的子数组数，要求子数组中最多 <code>k</code> 个可被 <code>p</code> 整除的元素。</p>\n\n<p>如果满足下述条件之一，则认为数组 <code>nums1</code> 和 <code>nums2</code> 是 <strong>不同</strong> 数组：</p>\n\n<ul>\n\t<li>两数组长度 <strong>不同</strong> ，或者</li>\n\t<li>存在 <strong>至少 </strong>一个下标 <code>i</code> 满足 <code>nums1[i] != nums2[i]</code> 。</li>\n</ul>\n\n<p><strong>子数组</strong> 定义为：数组中的连续元素组成的一个 <strong>非空</strong> 序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<em><strong>2</strong></em>,3,3,<em><strong>2</strong></em>,<em><strong>2</strong></em>], k = 2, p = 2\n<strong>输出：</strong>11\n<strong>解释：</strong>\n位于下标 0、3 和 4 的元素都可以被 p = 2 整除。\n共计 11 个不同子数组都满足最多含 k = 2 个可以被 2 整除的元素：\n[2]、[2,3]、[2,3,3]、[2,3,3,2]、[3]、[3,3]、[3,3,2]、[3,3,2,2]、[3,2]、[3,2,2] 和 [2,2] 。\n注意，尽管子数组 [2] 和 [3] 在 nums 中出现不止一次，但统计时只计数一次。\n子数组 [2,3,3,2,2] 不满足条件，因为其中有 3 个元素可以被 2 整除。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], k = 4, p = 1\n<strong>输出：</strong>10\n<strong>解释：</strong>\nnums 中的所有元素都可以被 p = 1 整除。\n此外，nums 中的每个子数组都满足最多 4 个元素可以被 1 整除。\n因为所有子数组互不相同，因此满足所有限制条件的子数组总数为 10 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i], p &lt;= 200</code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你可以设计并实现时间复杂度为 <code>O(n<sup>2</sup>)</code> 的算法解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2262.字符串的总引力",
        "hardRate": "HARD",
        "passRate": "57.54%",
        "problemsUrl": "https://leetcode.cn/problems/total-appeal-of-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/total-appeal-of-a-string/solution",
        "problemsDesc": "<p>字符串的 <strong>引力</strong> 定义为：字符串中 <strong>不同</strong> 字符的数量。</p>\n\n<ul>\n\t<li>例如，<code>\"abbca\"</code> 的引力为 <code>3</code> ，因为其中有 <code>3</code> 个不同字符 <code>'a'</code>、<code>'b'</code> 和 <code>'c'</code> 。</li>\n</ul>\n\n<p>给你一个字符串 <code>s</code> ，返回 <strong>其所有子字符串的总引力</strong> <strong>。</strong></p>\n\n<p><strong>子字符串</strong> 定义为：字符串中的一个连续字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abbca\"\n<strong>输出：</strong>28\n<strong>解释：</strong>\"abbca\" 的子字符串有：\n- 长度为 1 的子字符串：\"a\"、\"b\"、\"b\"、\"c\"、\"a\" 的引力分别为 1、1、1、1、1，总和为 5 。\n- 长度为 2 的子字符串：\"ab\"、\"bb\"、\"bc\"、\"ca\" 的引力分别为 2、1、2、2 ，总和为 7 。\n- 长度为 3 的子字符串：\"abb\"、\"bbc\"、\"bca\" 的引力分别为 2、2、3 ，总和为 7 。\n- 长度为 4 的子字符串：\"abbc\"、\"bbca\" 的引力分别为 3、3 ，总和为 6 。\n- 长度为 5 的子字符串：\"abbca\" 的引力为 3 ，总和为 3 。\n引力总和为 5 + 7 + 7 + 6 + 3 = 28 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"code\"\n<strong>输出：</strong>20\n<strong>解释：</strong>\"code\" 的子字符串有：\n- 长度为 1 的子字符串：\"c\"、\"o\"、\"d\"、\"e\" 的引力分别为 1、1、1、1 ，总和为 4 。\n- 长度为 2 的子字符串：\"co\"、\"od\"、\"de\" 的引力分别为 2、2、2 ，总和为 6 。\n- 长度为 3 的子字符串：\"cod\"、\"ode\" 的引力分别为 3、3 ，总和为 6 。\n- 长度为 4 的子字符串：\"code\" 的引力为 4 ，总和为 4 。\n引力总和为 4 + 6 + 6 + 4 = 20 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2263.数组变为有序的最小操作次数",
        "hardRate": "HARD",
        "passRate": "73.96%",
        "problemsUrl": "https://leetcode.cn/problems/make-array-non-decreasing-or-non-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/make-array-non-decreasing-or-non-increasing/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2264.字符串中最大的 3 位相同数字",
        "hardRate": "EASY",
        "passRate": "61.96%",
        "problemsUrl": "https://leetcode.cn/problems/largest-3-same-digit-number-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-3-same-digit-number-in-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>num</code> ，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个 <strong>优质整数</strong> ：</p>\n\n<ul>\n\t<li>该整数是 <code>num</code> 的一个长度为 <code>3</code> 的 <strong>子字符串</strong> 。</li>\n\t<li>该整数由唯一一个数字重复 <code>3</code> 次组成。</li>\n</ul>\n\n<p>以字符串形式返回 <strong>最大的优质整数</strong> 。如果不存在满足要求的整数，则返回一个空字符串 <code>\"\"</code> 。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><strong>子字符串</strong> 是字符串中的一个连续字符序列。</li>\n\t<li><code>num</code> 或优质整数中可能存在 <strong>前导零</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"6<em><strong>777</strong></em>133339\"\n<strong>输出：</strong>\"777\"\n<strong>解释：</strong>num 中存在两个优质整数：\"777\" 和 \"333\" 。\n\"777\" 是最大的那个，所以返回 \"777\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"23<em><strong>000</strong></em>19\"\n<strong>输出：</strong>\"000\"\n<strong>解释：</strong>\"000\" 是唯一一个优质整数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"42352338\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>不存在长度为 3 且仅由一个唯一数字组成的整数。因此，不存在优质整数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= num.length &lt;= 1000</code></li>\n\t<li><code>num</code> 仅由数字（<code>0</code> - <code>9</code>）组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2265.统计值等于子树平均值的节点数",
        "hardRate": "MEDIUM",
        "passRate": "82.65%",
        "problemsUrl": "https://leetcode.cn/problems/count-nodes-equal-to-average-of-subtree/",
        "solutionsUrl": "https://leetcode.cn/problems/count-nodes-equal-to-average-of-subtree/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，找出并返回满足要求的节点数，要求节点的值等于其 <strong>子树</strong> 中值的 <strong>平均值</strong> 。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><code>n</code> 个元素的平均值可以由 <code>n</code> 个元素 <strong>求和</strong> 然后再除以 <code>n</code> ，并 <strong>向下舍入</strong> 到最近的整数。</li>\n\t<li><code>root</code> 的 <strong>子树</strong> 由 <code>root</code> 和它的所有后代组成。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/03/15/image-20220315203925-1.png\" style=\"width: 300px; height: 212px;\">\n<pre><strong>输入：</strong>root = [4,8,5,0,1,null,6]\n<strong>输出：</strong>5\n<strong>解释：</strong>\n对值为 4 的节点：子树的平均值 (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4 。\n对值为 5 的节点：子树的平均值 (5 + 6) / 2 = 11 / 2 = 5 。\n对值为 0 的节点：子树的平均值 0 / 1 = 0 。\n对值为 1 的节点：子树的平均值 1 / 1 = 1 。\n对值为 6 的节点：子树的平均值 6 / 1 = 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/03/26/image-20220326133920-1.png\" style=\"width: 80px; height: 76px;\">\n<pre><strong>输入：</strong>root = [1]\n<strong>输出：</strong>1\n<strong>解释：</strong>对值为 1 的节点：子树的平均值 1 / 1 = 1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 1000]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2266.统计打字方案数",
        "hardRate": "MEDIUM",
        "passRate": "43.59%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-texts/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-texts/solution",
        "problemsDesc": "<p>Alice 在给 Bob 用手机打字。数字到字母的 <strong>对应</strong>&nbsp;如下图所示。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png\" style=\"width: 200px; height: 162px;\"></p>\n\n<p>为了 <strong>打出</strong>&nbsp;一个字母，Alice 需要 <strong>按</strong>&nbsp;对应字母 <code>i</code>&nbsp;次，<code>i</code>&nbsp;是该字母在这个按键上所处的位置。</p>\n\n<ul>\n\t<li>比方说，为了按出字母&nbsp;<code>'s'</code>&nbsp;，Alice 需要按&nbsp;<code>'7'</code>&nbsp;四次。类似的， Alice 需要按&nbsp;<code>'5'</code>&nbsp;两次得到字母&nbsp;&nbsp;<code>'k'</code>&nbsp;。</li>\n\t<li>注意，数字&nbsp;<code>'0'</code> 和&nbsp;<code>'1'</code>&nbsp;不映射到任何字母，所以&nbsp;Alice <strong>不</strong>&nbsp;使用它们。</li>\n</ul>\n\n<p>但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了 <strong>按键的字符串信息</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，Alice 发出的信息为&nbsp;<code>\"bob\"</code>&nbsp;，Bob 将收到字符串&nbsp;<code>\"2266622\"</code>&nbsp;。</li>\n</ul>\n\n<p>给你一个字符串&nbsp;<code>pressedKeys</code>&nbsp;，表示 Bob 收到的字符串，请你返回 Alice <strong>总共可能发出多少种文字信息</strong>&nbsp;。</p>\n\n<p>由于答案可能很大，将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong> 后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>pressedKeys = \"22233\"\n<b>输出：</b>8\n<strong>解释：</strong>\nAlice 可能发出的文字信息包括：\n\"aaadd\", \"abdd\", \"badd\", \"cdd\", \"aaae\", \"abe\", \"bae\" 和 \"ce\" 。\n由于总共有 8 种可能的信息，所以我们返回 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>pressedKeys = \"222222222222222222222222222222222222\"\n<b>输出：</b>82876089\n<strong>解释：</strong>\n总共有 2082876103 种 Alice 可能发出的文字信息。\n由于我们需要将答案对 10<sup>9</sup> + 7 取余，所以我们返回 2082876103 % (10<sup>9</sup> + 7) = 82876089 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pressedKeys.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pressedKeys</code> 只包含数字&nbsp;<code>'2'</code>&nbsp;到&nbsp;<code>'9'</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2267.检查是否有合法括号字符串路径",
        "hardRate": "HARD",
        "passRate": "37.91%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-parentheses-string-path/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-parentheses-string-path/solution",
        "problemsDesc": "<p>一个括号字符串是一个 <strong>非空</strong>&nbsp;且只包含&nbsp;<code>'('</code>&nbsp;和&nbsp;<code>')'</code>&nbsp;的字符串。如果下面&nbsp;<strong>任意</strong>&nbsp;条件为&nbsp;<strong>真</strong>&nbsp;，那么这个括号字符串就是&nbsp;<strong>合法的</strong>&nbsp;。</p>\n\n<ul>\n\t<li>字符串是&nbsp;<code>()</code>&nbsp;。</li>\n\t<li>字符串可以表示为&nbsp;<code>AB</code>（<code>A</code>&nbsp;连接&nbsp;<code>B</code>），<code>A</code> 和&nbsp;<code>B</code>&nbsp;都是合法括号序列。</li>\n\t<li>字符串可以表示为&nbsp;<code>(A)</code>&nbsp;，其中&nbsp;<code>A</code>&nbsp;是合法括号序列。</li>\n</ul>\n\n<p>给你一个&nbsp;<code>m x n</code>&nbsp;的括号网格图矩阵&nbsp;<code>grid</code>&nbsp;。网格图中一个&nbsp;<strong>合法括号路径</strong>&nbsp;是满足以下所有条件的一条路径：</p>\n\n<ul>\n\t<li>路径开始于左上角格子&nbsp;<code>(0, 0)</code>&nbsp;。</li>\n\t<li>路径结束于右下角格子&nbsp;<code>(m - 1, n - 1)</code>&nbsp;。</li>\n\t<li>路径每次只会向 <strong>下</strong>&nbsp;或者向 <strong>右</strong>&nbsp;移动。</li>\n\t<li>路径经过的格子组成的括号字符串是<strong>&nbsp;合法</strong>&nbsp;的。</li>\n</ul>\n\n<p>如果网格图中存在一条 <strong>合法括号路径</strong>&nbsp;，请返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/example1drawio.png\" style=\"width: 521px; height: 300px;\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[\"(\",\"(\",\"(\"],[\")\",\"(\",\")\"],[\"(\",\"(\",\")\"],[\"(\",\"(\",\")\"]]\n<b>输出：</b>true\n<b>解释：</b>上图展示了两条路径，它们都是合法括号字符串路径。\n第一条路径得到的合法字符串是 \"()(())\" 。\n第二条路径得到的合法字符串是 \"((()))\" 。\n注意可能有其他的合法括号字符串路径。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/example2drawio.png\" style=\"width: 165px; height: 165px;\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[\")\",\")\"],[\"(\",\"(\"]]\n<b>输出：</b>false\n<b>解释：</b>两条可行路径分别得到 \"))(\" 和 \")((\" 。由于它们都不是合法括号字符串，我们返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;要么是&nbsp;<code>'('</code>&nbsp;，要么是&nbsp;<code>')'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2268.最少按键次数",
        "hardRate": "MEDIUM",
        "passRate": "68.16%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-keypresses/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-keypresses/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2269.找到一个数字的 K 美丽值",
        "hardRate": "EASY",
        "passRate": "62.71%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-k-beauty-of-a-number/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-k-beauty-of-a-number/solution",
        "problemsDesc": "<p>一个整数 <code>num</code>&nbsp;的&nbsp;<strong>k&nbsp;</strong>美丽值定义为&nbsp;<code>num</code>&nbsp;中符合以下条件的&nbsp;<strong>子字符串</strong>&nbsp;数目：</p>\n\n<ul>\n\t<li>子字符串长度为&nbsp;<code>k</code>&nbsp;。</li>\n\t<li>子字符串能整除 <code>num</code> 。</li>\n</ul>\n\n<p>给你整数&nbsp;<code>num</code> 和&nbsp;<code>k</code>&nbsp;，请你返回<em>&nbsp;</em><code>num</code>&nbsp;的 k 美丽值。</p>\n\n<p>注意：</p>\n\n<ul>\n\t<li>允许有&nbsp;<strong>前缀</strong>&nbsp;<strong>0</strong>&nbsp;。</li>\n\t<li><code>0</code>&nbsp;不能整除任何值。</li>\n</ul>\n\n<p>一个 <strong>子字符串</strong>&nbsp;是一个字符串里的连续一段字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>num = 240, k = 2\n<b>输出：</b>2\n<b>解释：</b>以下是 num 里长度为 k 的子字符串：\n- \"<em><strong>24</strong></em>0\" 中的 \"24\" ：24 能整除 240 。\n- \"2<em><strong>40</strong></em>\" 中的 \"40\" ：40 能整除 240 。\n所以，k 美丽值为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>num = 430043, k = 2\n<b>输出：</b>2\n<b>解释：</b>以下是 num 里长度为 k 的子字符串：\n- \"<em><strong>43</strong></em>0043\" 中的 \"43\" ：43 能整除 430043 。\n- \"4<em><strong>30</strong></em>043\" 中的 \"30\" ：30 不能整除 430043 。\n- \"43<em><strong>00</strong></em>43\" 中的 \"00\" ：0 不能整除 430043 。\n- \"430<em><strong>04</strong></em>3\" 中的 \"04\" ：4 不能整除 430043 。\n- \"4300<em><strong>43</strong></em>\" 中的 \"43\" ：43 能整除 430043 。\n所以，k 美丽值为 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= num.length</code>&nbsp;（将&nbsp;<code>num</code>&nbsp;视为字符串）</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2270.分割数组的方案数",
        "hardRate": "MEDIUM",
        "passRate": "46.46%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-split-array/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-split-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;。<br />\n<span style=\"\">如果以下描述为真，那么</span><span style=\"\"> </span><code>nums</code>&nbsp;在下标 <code>i</code>&nbsp;处有一个 <strong>合法的分割</strong>&nbsp;：</p>\n\n<ul>\n\t<li>前&nbsp;<code>i + 1</code>&nbsp;个元素的和 <strong>大于等于</strong>&nbsp;剩下的&nbsp;<code>n - i - 1</code>&nbsp;个元素的和。</li>\n\t<li>下标 <code>i</code>&nbsp;的右边 <strong>至少有一个</strong>&nbsp;元素，也就是说下标&nbsp;<code>i</code>&nbsp;满足&nbsp;<code>0 &lt;= i &lt; n - 1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回&nbsp;<code>nums</code>&nbsp;中的&nbsp;<strong>合法分割</strong>&nbsp;方案数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [10,4,-8,7]\n<b>输出：</b>2\n<b>解释：</b>\n总共有 3 种不同的方案可以将 nums 分割成两个非空的部分：\n- 在下标 0 处分割 nums 。那么第一部分为 [10] ，和为 10 。第二部分为 [4,-8,7] ，和为 3 。因为 10 &gt;= 3 ，所以 i = 0 是一个合法的分割。\n- 在下标 1 处分割 nums 。那么第一部分为 [10,4] ，和为 14 。第二部分为 [-8,7] ，和为 -1 。因为 14 &gt;= -1 ，所以 i = 1 是一个合法的分割。\n- 在下标 2 处分割 nums 。那么第一部分为 [10,4,-8] ，和为 6 。第二部分为 [7] ，和为 7 。因为 6 &lt; 7 ，所以 i = 2 不是一个合法的分割。\n所以 nums 中总共合法分割方案受为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3,1,0]\n<b>输出：</b>2\n<b>解释：</b>\n总共有 2 种 nums 的合法分割：\n- 在下标 1 处分割 nums 。那么第一部分为 [2,3] ，和为 5 。第二部分为 [1,0] ，和为 1 。因为 5 &gt;= 1 ，所以 i = 1 是一个合法的分割。\n- 在下标 2 处分割 nums 。那么第一部分为 [2,3,1] ，和为 6 。第二部分为 [0] ，和为 0 。因为 6 &gt;= 0 ，所以 i = 2 是一个合法的分割。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2271.毯子覆盖的最多白色砖块数",
        "hardRate": "MEDIUM",
        "passRate": "32.77%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet/solution",
        "problemsDesc": "<p>给你一个二维整数数组&nbsp;<code>tiles</code>&nbsp;，其中&nbsp;<code>tiles[i] = [l<sub>i</sub>, r<sub>i</sub>]</code>&nbsp;，表示所有在&nbsp;<code>l<sub>i</sub> &lt;= j &lt;= r<sub>i</sub></code>&nbsp;之间的每个瓷砖位置 <code>j</code>&nbsp;都被涂成了白色。</p>\n\n<p>同时给你一个整数&nbsp;<code>carpetLen</code>&nbsp;，表示可以放在&nbsp;<strong>任何位置</strong>&nbsp;的一块毯子。</p>\n\n<p>请你返回使用这块毯子，<strong>最多</strong>&nbsp;可以盖住多少块瓷砖。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/25/example1drawio3.png\" style=\"width: 644px; height: 158px;\" /></p>\n\n<pre>\n<b>输入：</b>tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10\n<b>输出：</b>9\n<b>解释：</b>将毯子从瓷砖 10 开始放置。\n总共覆盖 9 块瓷砖，所以返回 9 。\n注意可能有其他方案也可以覆盖 9 块瓷砖。\n可以看出，瓷砖无法覆盖超过 9 块瓷砖。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/24/example2drawio.png\" style=\"width: 231px; height: 168px;\" /></p>\n\n<pre>\n<strong>输入：</strong>tiles = [[10,11],[1,1]], carpetLen = 2\n<b>输出：</b>2\n<b>解释：</b>将毯子从瓷砖 10 开始放置。\n总共覆盖 2 块瓷砖，所以我们返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tiles.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>tiles[i].length == 2</code></li>\n\t<li><code>1 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= carpetLen &lt;= 10<sup>9</sup></code></li>\n\t<li><code>tiles</code>&nbsp;互相 <strong>不会重叠</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2272.最大波动的子字符串",
        "hardRate": "HARD",
        "passRate": "38.83%",
        "problemsUrl": "https://leetcode.cn/problems/substring-with-largest-variance/",
        "solutionsUrl": "https://leetcode.cn/problems/substring-with-largest-variance/solution",
        "problemsDesc": "<p>字符串的 <strong>波动</strong>&nbsp;定义为子字符串中出现次数 <strong>最多</strong>&nbsp;的字符次数与出现次数 <strong>最少</strong>&nbsp;的字符次数之差。</p>\n\n<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，它只包含小写英文字母。请你返回 <code>s</code>&nbsp;里所有 <strong>子字符串的</strong>&nbsp;<strong>最大波动</strong>&nbsp;值。</p>\n\n<p><strong>子字符串</strong> 是一个字符串的一段连续字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aababbb\"\n<b>输出：</b>3\n<strong>解释：</strong>\n所有可能的波动值和它们对应的子字符串如以下所示：\n- 波动值为 0 的子字符串：\"a\" ，\"aa\" ，\"ab\" ，\"abab\" ，\"aababb\" ，\"ba\" ，\"b\" ，\"bb\" 和 \"bbb\" 。\n- 波动值为 1 的子字符串：\"aab\" ，\"aba\" ，\"abb\" ，\"aabab\" ，\"ababb\" ，\"aababbb\" 和 \"bab\" 。\n- 波动值为 2 的子字符串：\"aaba\" ，\"ababbb\" ，\"abbb\" 和 \"babb\" 。\n- 波动值为 3 的子字符串 \"babbb\" 。\n所以，最大可能波动值为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abcde\"\n<b>输出：</b>0\n<strong>解释：</strong>\ns 中没有字母出现超过 1 次，所以 s 中每个子字符串的波动值都是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp; 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2273.移除字母异位词后的结果数组",
        "hardRate": "EASY",
        "passRate": "59.73%",
        "problemsUrl": "https://leetcode.cn/problems/find-resultant-array-after-removing-anagrams/",
        "solutionsUrl": "https://leetcode.cn/problems/find-resultant-array-after-removing-anagrams/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>words</code> ，其中 <code>words[i]</code> 由小写英文字符组成。</p>\n\n<p>在一步操作中，需要选出任一下标 <code>i</code> ，从 <code>words</code> 中 <strong>删除</strong> <code>words[i]</code> 。其中下标 <code>i</code> 需要同时满足下述两个条件：</p>\n\n<ol>\n\t<li><code>0 &lt; i &lt; words.length</code></li>\n\t<li><code>words[i - 1]</code> 和 <code>words[i]</code> 是 <strong>字母异位词</strong> 。</li>\n</ol>\n\n<p>只要可以选出满足条件的下标，就一直执行这个操作。</p>\n\n<p>在执行所有操作后，返回 <code>words</code> 。可以证明，按任意顺序为每步操作选择下标都会得到相同的结果。</p>\n\n<p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。例如，<code>\"dacb\"</code> 是 <code>\"abdc\"</code> 的一个字母异位词。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"abba\",\"baba\",\"bbaa\",\"cd\",\"cd\"]\n<strong>输出：</strong>[\"abba\",\"cd\"]\n<strong>解释：</strong>\n获取结果数组的方法之一是执行下述步骤：\n- 由于 words[2] = \"bbaa\" 和 words[1] = \"baba\" 是字母异位词，选择下标 2 并删除 words[2] 。\n  现在 words = [\"abba\",\"baba\",\"cd\",\"cd\"] 。\n- 由于 words[1] = \"baba\" 和 words[0] = \"abba\" 是字母异位词，选择下标 1 并删除 words[1] 。\n  现在 words = [\"abba\",\"cd\",\"cd\"] 。\n- 由于 words[2] = \"cd\" 和 words[1] = \"cd\" 是字母异位词，选择下标 2 并删除 words[2] 。\n  现在 words = [\"abba\",\"cd\"] 。\n无法再执行任何操作，所以 [\"abba\",\"cd\"] 是最终答案。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"a\",\"b\",\"c\",\"d\",\"e\"]\n<strong>输出：</strong>[\"a\",\"b\",\"c\",\"d\",\"e\"]\n<strong>解释：</strong>\nwords 中不存在互为字母异位词的两个相邻字符串，所以无需执行任何操作。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2274.不含特殊楼层的最大连续楼层数",
        "hardRate": "MEDIUM",
        "passRate": "52.55%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-consecutive-floors-without-special-floors/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-consecutive-floors-without-special-floors/solution",
        "problemsDesc": "<p>Alice 管理着一家公司，并租用大楼的部分楼层作为办公空间。Alice 决定将一些楼层作为 <strong>特殊楼层</strong> ，仅用于放松。</p>\n\n<p>给你两个整数 <code>bottom</code> 和 <code>top</code> ，表示 Alice 租用了从 <code>bottom</code> 到 <code>top</code>（含 <code>bottom</code> 和 <code>top</code> 在内）的所有楼层。另给你一个整数数组 <code>special</code> ，其中 <code>special[i]</code> 表示&nbsp; Alice 指定用于放松的特殊楼层。</p>\n\n<p>返回不含特殊楼层的 <strong>最大</strong> 连续楼层数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>bottom = 2, top = 9, special = [4,6]\n<strong>输出：</strong>3\n<strong>解释：</strong>下面列出的是不含特殊楼层的连续楼层范围：\n- (2, 3) ，楼层数为 2 。\n- (5, 5) ，楼层数为 1 。\n- (7, 9) ，楼层数为 3 。\n因此，返回最大连续楼层数 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>bottom = 6, top = 8, special = [7,6,8]\n<strong>输出：</strong>0\n<strong>解释：</strong>每层楼都被规划为特殊楼层，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= special.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= bottom &lt;= special[i] &lt;= top &lt;= 10<sup>9</sup></code></li>\n\t<li><code>special</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2275.按位与结果大于零的最长组合",
        "hardRate": "MEDIUM",
        "passRate": "60.11%",
        "problemsUrl": "https://leetcode.cn/problems/largest-combination-with-bitwise-and-greater-than-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-combination-with-bitwise-and-greater-than-zero/solution",
        "problemsDesc": "<p>对数组&nbsp;<code>nums</code> 执行 <strong>按位与</strong> 相当于对数组&nbsp;<code>nums</code> 中的所有整数执行 <strong>按位与</strong> 。</p>\n\n<ul>\n\t<li>例如，对 <code>nums = [1, 5, 3]</code> 来说，按位与等于 <code>1 &amp; 5 &amp; 3 = 1</code> 。</li>\n\t<li>同样，对 <code>nums = [7]</code> 而言，按位与等于 <code>7</code> 。</li>\n</ul>\n\n<p>给你一个正整数数组 <code>candidates</code> 。计算 <code>candidates</code> 中的数字每种组合下 <strong>按位与</strong> 的结果。 <code>candidates</code> 中的每个数字在每种组合中只能使用 <strong>一次</strong> 。</p>\n\n<p>返回按位与结果大于 <code>0</code> 的 <strong>最长</strong> 组合的长度<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>candidates = [16,17,71,62,12,24,14]\n<strong>输出：</strong>4\n<strong>解释：</strong>组合 [16,17,62,24] 的按位与结果是 16 &amp; 17 &amp; 62 &amp; 24 = 16 &gt; 0 。\n组合长度是 4 。\n可以证明不存在按位与结果大于 0 且长度大于 4 的组合。\n注意，符合长度最大的组合可能不止一种。\n例如，组合 [62,12,24,14] 的按位与结果是 62 &amp; 12 &amp; 24 &amp; 14 = 8 &gt; 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>candidates = [8,8]\n<strong>输出：</strong>2\n<strong>解释：</strong>最长组合是 [8,8] ，按位与结果 8 &amp; 8 = 8 &gt; 0 。\n组合长度是 2 ，所以返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candidates.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= candidates[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2276.统计区间中的整数数目",
        "hardRate": "HARD",
        "passRate": "36.96%",
        "problemsUrl": "https://leetcode.cn/problems/count-integers-in-intervals/",
        "solutionsUrl": "https://leetcode.cn/problems/count-integers-in-intervals/solution",
        "problemsDesc": "<p>给你区间的 <strong>空</strong> 集，请你设计并实现满足要求的数据结构：</p>\n\n<ul>\n\t<li><strong>新增：</strong>添加一个区间到这个区间集合中。</li>\n\t<li><strong>统计：</strong>计算出现在 <strong>至少一个</strong> 区间中的整数个数。</li>\n</ul>\n\n<p>实现 <code>CountIntervals</code> 类：</p>\n\n<ul>\n\t<li><code>CountIntervals()</code> 使用区间的空集初始化对象</li>\n\t<li><code>void add(int left, int right)</code> 添加区间 <code>[left, right]</code> 到区间集合之中。</li>\n\t<li><code>int count()</code> 返回出现在 <strong>至少一个</strong> 区间中的整数个数。</li>\n</ul>\n\n<p><strong>注意：</strong>区间 <code>[left, right]</code> 表示满足 <code>left &lt;= x &lt;= right</code> 的所有整数 <code>x</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"CountIntervals\", \"add\", \"add\", \"count\", \"add\", \"count\"]\n[[], [2, 3], [7, 10], [], [5, 8], []]\n<strong>输出</strong>\n[null, null, null, 6, null, 8]\n\n<strong>解释</strong>\nCountIntervals countIntervals = new CountIntervals(); // 用一个区间空集初始化对象\ncountIntervals.add(2, 3);  // 将 [2, 3] 添加到区间集合中\ncountIntervals.add(7, 10); // 将 [7, 10] 添加到区间集合中\ncountIntervals.count();    // 返回 6\n                           // 整数 2 和 3 出现在区间 [2, 3] 中\n                           // 整数 7、8、9、10 出现在区间 [7, 10] 中\ncountIntervals.add(5, 8);  // 将 [5, 8] 添加到区间集合中\ncountIntervals.count();    // 返回 8\n                           // 整数 2 和 3 出现在区间 [2, 3] 中\n                           // 整数 5 和 6 出现在区间 [5, 8] 中\n                           // 整数 7 和 8 出现在区间 [5, 8] 和区间 [7, 10] 中\n                           // 整数 9 和 10 出现在区间 [7, 10] 中</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>9</sup></code></li>\n\t<li>最多调用&nbsp; <code>add</code> 和 <code>count</code> 方法 <strong>总计</strong> <code>10<sup>5</sup></code> 次</li>\n\t<li>调用 <code>count</code> 方法至少一次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2277.树中最接近路径的节点",
        "hardRate": "HARD",
        "passRate": "71.86%",
        "problemsUrl": "https://leetcode.cn/problems/closest-node-to-path-in-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-node-to-path-in-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2278.字母在字符串中的百分比",
        "hardRate": "EASY",
        "passRate": "80.80%",
        "problemsUrl": "https://leetcode.cn/problems/percentage-of-letter-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/percentage-of-letter-in-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个字符 <code>letter</code> ，返回在 <code>s</code> 中等于&nbsp;<code>letter</code>&nbsp;字符所占的 <strong>百分比</strong> ，向下取整到最接近的百分比。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"foobar\", letter = \"o\"\n<strong>输出：</strong>33\n<strong>解释：</strong>\n等于字母 'o' 的字符在 s 中占到的百分比是 2 / 6 * 100% = 33% ，向下取整，所以返回 33 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"jjjj\", letter = \"k\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\n等于字母 'k' 的字符在 s 中占到的百分比是 0% ，所以返回 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n\t<li><code>letter</code> 是一个小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2279.装满石头的背包的最大数量",
        "hardRate": "MEDIUM",
        "passRate": "63.74%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/solution",
        "problemsDesc": "<p>现有编号从&nbsp;<code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个背包。给你两个下标从 <strong>0</strong> 开始的整数数组 <code>capacity</code> 和 <code>rocks</code> 。第 <code>i</code> 个背包最大可以装 <code>capacity[i]</code> 块石头，当前已经装了 <code>rocks[i]</code> 块石头。另给你一个整数 <code>additionalRocks</code> ，表示<span class=\"text-only\" data-eleid=\"10\" style=\"white-space: pre;\">你可以放置的额外石头数量，石头可以往 </span><strong><span class=\"text-only\" data-eleid=\"11\" style=\"white-space: pre;\">任意</span></strong><span class=\"text-only\" data-eleid=\"12\" style=\"white-space: pre;\"> 背包中放置。</span></p>\n\n<p>请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的 <strong>最大 </strong>数量<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>\n1 块石头放入背包 0 ，1 块石头放入背包 1 。\n每个背包中的石头总数是 [2,3,4,4] 。\n背包 0 、背包 1 和 背包 2 都装满石头。\n总计 3 个背包装满石头，所以返回 3 。\n可以证明不存在超过 3 个背包装满石头的情况。\n注意，可能存在其他放置石头的方案同样能够得到 3 这个结果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100\n<strong>输出：</strong>3\n<strong>解释：</strong>\n8 块石头放入背包 0 ，2 块石头放入背包 2 。\n每个背包中的石头总数是 [10,2,2] 。\n背包 0 、背包 1 和背包 2 都装满石头。\n总计 3 个背包装满石头，所以返回 3 。\n可以证明不存在超过 3 个背包装满石头的情况。\n注意，不必用完所有的额外石头。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == capacity.length == rocks.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= capacity[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= rocks[i] &lt;= capacity[i]</code></li>\n\t<li><code>1 &lt;= additionalRocks &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2280.表示一个折线图的最少线段数",
        "hardRate": "MEDIUM",
        "passRate": "22.44%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-lines-to-represent-a-line-chart/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-lines-to-represent-a-line-chart/solution",
        "problemsDesc": "<p>给你一个二维整数数组&nbsp;<code>stockPrices</code> ，其中&nbsp;<code>stockPrices[i] = [day<sub>i</sub>, price<sub>i</sub>]</code>&nbsp;表示股票在&nbsp;<code>day<sub>i</sub></code>&nbsp;的价格为&nbsp;<code>price<sub>i</sub></code>&nbsp;。<strong>折线图</strong>&nbsp;是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。比方说下图是一个例子：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/30/1920px-pushkin_population_historysvg.png\" style=\"width: 500px; height: 313px;\">\n<p>请你返回要表示一个折线图所需要的 <strong>最少线段数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/30/ex0.png\" style=\"width: 400px; height: 400px;\"></p>\n\n<pre><b>输入：</b>stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]\n<b>输出：</b>3\n<strong>解释：</strong>\n上图为输入对应的图，横坐标表示日期，纵坐标表示价格。\n以下 3 个线段可以表示折线图：\n- 线段 1 （红色）从 (1,7) 到 (4,4) ，经过 (1,7) ，(2,6) ，(3,5) 和 (4,4) 。\n- 线段 2 （蓝色）从 (4,4) 到 (5,4) 。\n- 线段 3 （绿色）从 (5,4) 到 (8,1) ，经过 (5,4) ，(6,3) ，(7,2) 和 (8,1) 。\n可以证明，无法用少于 3 条线段表示这个折线图。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/30/ex1.png\" style=\"width: 325px; height: 325px;\"></p>\n\n<pre><b>输入：</b>stockPrices = [[3,4],[1,2],[7,8],[2,3]]\n<b>输出：</b>1\n<strong>解释：</strong>\n如上图所示，折线图可以用一条线段表示。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= stockPrices.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>stockPrices[i].length == 2</code></li>\n\t<li><code>1 &lt;= day<sub>i</sub>, price<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li>所有&nbsp;<code>day<sub>i</sub></code>&nbsp;<strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2281.巫师的总力量和",
        "hardRate": "HARD",
        "passRate": "26.64%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-total-strength-of-wizards/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-total-strength-of-wizards/solution",
        "problemsDesc": "<p>作为国王的统治者，你有一支巫师军队听你指挥。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>strength</code>&nbsp;，其中&nbsp;<code>strength[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;位巫师的力量值。对于连续的一组巫师（也就是这些巫师的力量值是&nbsp;<code>strength</code>&nbsp;的&nbsp;<strong>子数组</strong>），<strong>总力量</strong>&nbsp;定义为以下两个值的&nbsp;<strong>乘积</strong>&nbsp;：</p>\n\n<ul>\n\t<li>巫师中 <strong>最弱</strong>&nbsp;的能力值。</li>\n\t<li>组中所有巫师的个人力量值 <strong>之和</strong>&nbsp;。</li>\n</ul>\n\n<p>请你返回 <strong>所有</strong>&nbsp;巫师组的 <strong>总</strong>&nbsp;力量之和。由于答案可能很大，请将答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p><strong>子数组</strong>&nbsp;是一个数组里 <strong>非空</strong>&nbsp;连续子序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>strength = [1,3,1,2]\n<b>输出：</b>44\n<b>解释：</b>以下是所有连续巫师组：\n- [<em><strong>1</strong></em>,3,1,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1\n- [1,<em><strong>3</strong></em>,1,2] 中 [3] ，总力量值为 min([3]) * sum([3]) = 3 * 3 = 9\n- [1,3,<em><strong>1</strong></em>,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1\n- [1,3,1,<em><strong>2</strong></em>] 中 [2] ，总力量值为 min([2]) * sum([2]) = 2 * 2 = 4\n- [<em><strong>1,3</strong></em>,1,2] 中 [1,3] ，总力量值为 min([1,3]) * sum([1,3]) = 1 * 4 = 4\n- [1,<em><strong>3,1</strong></em>,2] 中 [3,1] ，总力量值为 min([3,1]) * sum([3,1]) = 1 * 4 = 4\n- [1,3,<em><strong>1,2</strong></em>] 中 [1,2] ，总力量值为 min([1,2]) * sum([1,2]) = 1 * 3 = 3\n- [<em><strong>1,3,1</strong></em>,2] 中 [1,3,1] ，总力量值为 min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5\n- [1,<em><strong>3,1,2</strong></em>] 中 [3,1,2] ，总力量值为 min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6\n- [<em><strong>1,3,1,2</strong></em>] 中 [1,3,1,2] ，总力量值为 min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7\n所有力量值之和为 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>strength = [5,4,6]\n<b>输出：</b>213\n<b>解释：</b>以下是所有连续巫师组：\n- [<em><strong>5</strong></em>,4,6] 中 [5] ，总力量值为 min([5]) * sum([5]) = 5 * 5 = 25\n- [5,<em><strong>4</strong></em>,6] 中 [4] ，总力量值为 min([4]) * sum([4]) = 4 * 4 = 16\n- [5,4,<em><strong>6</strong></em>] 中 [6] ，总力量值为 min([6]) * sum([6]) = 6 * 6 = 36\n- [<em><strong>5,4</strong></em>,6] 中 [5,4] ，总力量值为 min([5,4]) * sum([5,4]) = 4 * 9 = 36\n- [5,<em><strong>4,6</strong></em>] 中 [4,6] ，总力量值为 min([4,6]) * sum([4,6]) = 4 * 10 = 40\n- [<em><strong>5,4,6</strong></em>] 中 [5,4,6] ，总力量值为 min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60\n所有力量值之和为 25 + 16 + 36 + 36 + 40 + 60 = 213 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strength.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= strength[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2282.在一个网格中可以看到的人数",
        "hardRate": "MEDIUM",
        "passRate": "48.33%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-people-that-can-be-seen-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-people-that-can-be-seen-in-a-grid/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2283.判断一个数的数字计数是否等于数位的值",
        "hardRate": "EASY",
        "passRate": "78.96%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-number-has-equal-digit-count-and-digit-value/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-number-has-equal-digit-count-and-digit-value/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的字符串&nbsp;<code>num</code>&nbsp;，它只包含数字。</p>\n\n<p>如果对于 <strong>每个</strong><em>&nbsp;</em><code>0 &lt;= i &lt; n</code>&nbsp;的下标&nbsp;<code>i</code>&nbsp;，都满足数位<em>&nbsp;</em><code>i</code>&nbsp;在 <code>num</code>&nbsp;中出现了&nbsp;<code>num[i]</code>次，那么请你返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>num = \"1210\"\n<b>输出：</b>true\n<strong>解释：</strong>\nnum[0] = '1' 。数字 0 在 num 中出现了一次。\nnum[1] = '2' 。数字 1 在 num 中出现了两次。\nnum[2] = '1' 。数字 2 在 num 中出现了一次。\nnum[3] = '0' 。数字 3 在 num 中出现了零次。\n\"1210\" 满足题目要求条件，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>num = \"030\"\n<b>输出：</b>false\n<strong>解释：</strong>\nnum[0] = '0' 。数字 0 应该出现 0 次，但是在 num 中出现了两次。\nnum[1] = '3' 。数字 1 应该出现 3 次，但是在 num 中出现了零次。\nnum[2] = '0' 。数字 2 在 num 中出现了 0 次。\n下标 0 和 1 都违反了题目要求，所以返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == num.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>num</code>&nbsp;只包含数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2284.最多单词数的发件人",
        "hardRate": "MEDIUM",
        "passRate": "56.84%",
        "problemsUrl": "https://leetcode.cn/problems/sender-with-largest-word-count/",
        "solutionsUrl": "https://leetcode.cn/problems/sender-with-largest-word-count/solution",
        "problemsDesc": "<p>给你一个聊天记录，共包含 <code>n</code>&nbsp;条信息。给你两个字符串数组&nbsp;<code>messages</code> 和&nbsp;<code>senders</code>&nbsp;，其中&nbsp;<code>messages[i]</code>&nbsp;是&nbsp;<code>senders[i]</code>&nbsp;发出的一条&nbsp;<strong>信息</strong>&nbsp;。</p>\n\n<p>一条 <strong>信息</strong>&nbsp;是若干用单个空格连接的 <strong>单词</strong>&nbsp;，信息开头和结尾不会有多余空格。发件人的 <strong>单词计数</strong>&nbsp;是这个发件人总共发出的 <strong>单词数</strong>&nbsp;。注意，一个发件人可能会发出多于一条信息。</p>\n\n<p>请你返回发出单词数 <strong>最多</strong>&nbsp;的发件人名字。如果有多个发件人发出最多单词数，请你返回 <strong>字典序</strong>&nbsp;最大的名字。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>字典序里，大写字母小于小写字母。</li>\n\t<li><code>\"Alice\"</code> 和&nbsp;<code>\"alice\"</code>&nbsp;是不同的名字。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>messages = [\"Hello userTwooo\",\"Hi userThree\",\"Wonderful day Alice\",\"Nice day userThree\"], senders = [\"Alice\",\"userTwo\",\"userThree\",\"Alice\"]\n<b>输出：</b>\"Alice\"\n<b>解释：</b>Alice 总共发出了 2 + 3 = 5 个单词。\nuserTwo 发出了 2 个单词。\nuserThree 发出了 3 个单词。\n由于 Alice 发出单词数最多，所以我们返回 \"Alice\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>messages = [\"How is leetcode for everyone\",\"Leetcode is useful for practice\"], senders = [\"Bob\",\"Charlie\"]\n<b>输出：</b>\"Charlie\"\n<b>解释：</b>Bob 总共发出了 5 个单词。\nCharlie 总共发出了 5 个单词。\n由于最多单词数打平，返回字典序最大的名字，也就是 Charlie 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == messages.length == senders.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= messages[i].length &lt;= 100</code></li>\n\t<li><code>1 &lt;= senders[i].length &lt;= 10</code></li>\n\t<li><code>messages[i]</code>&nbsp;包含大写字母、小写字母和&nbsp;<code>' '</code>&nbsp;。</li>\n\t<li><code>messages[i]</code>&nbsp;中所有单词都由 <strong>单个空格</strong>&nbsp;隔开。</li>\n\t<li><code>messages[i]</code>&nbsp;不包含前导和后缀空格。</li>\n\t<li><code>senders[i]</code>&nbsp;只包含大写英文字母和小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2285.道路的最大总重要性",
        "hardRate": "MEDIUM",
        "passRate": "57.55%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-total-importance-of-roads/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-total-importance-of-roads/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，表示一个国家里的城市数目。城市编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。</p>\n\n<p>给你一个二维整数数组&nbsp;<code>roads</code>&nbsp;，其中&nbsp;<code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示城市&nbsp;<code>a<sub>i</sub></code>&nbsp;和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条&nbsp;<strong>双向</strong>&nbsp;道路。</p>\n\n<p>你需要给每个城市安排一个从 <code>1</code>&nbsp;到 <code>n</code>&nbsp;之间的整数值，且每个值只能被使用 <strong>一次</strong>&nbsp;。道路的 <strong>重要性</strong>&nbsp;定义为这条道路连接的两座城市数值 <strong>之和</strong>&nbsp;。</p>\n\n<p>请你返回在最优安排下，<strong>所有道路重要性</strong> 之和 <strong>最大</strong>&nbsp;为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/07/ex1drawio.png\" style=\"width: 290px; height: 215px;\"></p>\n\n<pre><b>输入：</b>n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\n<b>输出：</b>43\n<b>解释：</b>上图展示了国家图和每个城市被安排的值 [2,4,5,3,1] 。\n- 道路 (0,1) 重要性为 2 + 4 = 6 。\n- 道路 (1,2) 重要性为 4 + 5 = 9 。\n- 道路 (2,3) 重要性为 5 + 3 = 8 。\n- 道路 (0,2) 重要性为 2 + 5 = 7 。\n- 道路 (1,3) 重要性为 4 + 3 = 7 。\n- 道路 (2,4) 重要性为 5 + 1 = 6 。\n所有道路重要性之和为 6 + 9 + 8 + 7 + 7 + 6 = 43 。\n可以证明，重要性之和不可能超过 43 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/07/ex2drawio.png\" style=\"width: 281px; height: 151px;\"></p>\n\n<pre><b>输入：</b>n = 5, roads = [[0,3],[2,4],[1,3]]\n<b>输出：</b>20\n<b>解释：</b>上图展示了国家图和每个城市被安排的值 [4,3,2,5,1] 。\n- 道路 (0,3) 重要性为 4 + 5 = 9 。\n- 道路 (2,4) 重要性为 2 + 1 = 3 。\n- 道路 (1,3) 重要性为 3 + 5 = 8 。\n所有道路重要性之和为 9 + 3 + 8 = 20 。\n可以证明，重要性之和不可能超过 20 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= roads.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>roads[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>没有重复道路。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2286.以组为单位订音乐会的门票",
        "hardRate": "HARD",
        "passRate": "23.40%",
        "problemsUrl": "https://leetcode.cn/problems/booking-concert-tickets-in-groups/",
        "solutionsUrl": "https://leetcode.cn/problems/booking-concert-tickets-in-groups/solution",
        "problemsDesc": "<p>一个音乐会总共有&nbsp;<code>n</code>&nbsp;排座位，编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，每一排有&nbsp;<code>m</code>&nbsp;个座椅，编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>m - 1</code>&nbsp;。你需要设计一个买票系统，针对以下情况进行座位安排：</p>\n\n<ul>\n\t<li>同一组的 <code>k</code>&nbsp;位观众坐在<strong> 同一排座位，且座位连续 </strong>。</li>\n\t<li><code>k</code>&nbsp;位观众中 <strong>每一位</strong>&nbsp;都有座位坐，但他们 <strong>不一定</strong>&nbsp;坐在一起。</li>\n</ul>\n\n<p>由于观众非常挑剔，所以：</p>\n\n<ul>\n\t<li>只有当一个组里所有成员座位的排数都 <strong>小于等于</strong>&nbsp;<code>maxRow</code>&nbsp;，这个组才能订座位。每一组的&nbsp;<code>maxRow</code>&nbsp;可能 <strong>不同</strong>&nbsp;。</li>\n\t<li>如果有多排座位可以选择，优先选择 <strong>最小</strong>&nbsp;的排数。如果同一排中有多个座位可以坐，优先选择号码 <strong>最小</strong>&nbsp;的。</li>\n</ul>\n\n<p>请你实现&nbsp;<code>BookMyShow</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>BookMyShow(int n, int m)</code>&nbsp;，初始化对象，<code>n</code>&nbsp;是排数，<code>m</code>&nbsp;是每一排的座位数。</li>\n\t<li><code>int[] gather(int k, int maxRow)</code>&nbsp;返回长度为 <code>2</code>&nbsp;的数组，表示 <code>k</code>&nbsp;个成员中 <strong>第一个座位</strong>&nbsp;的排数和座位编号，这 <code>k</code>&nbsp;位成员必须坐在 <strong>同一排座位，且座位连续 </strong>。换言之，返回最小可能的&nbsp;<code>r</code> 和&nbsp;<code>c</code>&nbsp;满足第&nbsp;<code>r</code>&nbsp;排中&nbsp;<code>[c, c + k - 1]</code>&nbsp;的座位都是空的，且&nbsp;<code>r &lt;= maxRow</code>&nbsp;。如果&nbsp;<strong>无法</strong>&nbsp;安排座位，返回&nbsp;<code>[]</code>&nbsp;。</li>\n\t<li><code>boolean scatter(int k, int maxRow)</code>&nbsp;如果组里所有&nbsp;<code>k</code>&nbsp;个成员&nbsp;<strong>不一定</strong>&nbsp;要坐在一起的前提下，都能在第&nbsp;<code>0</code> 排到第&nbsp;<code>maxRow</code>&nbsp;排之间找到座位，那么请返回&nbsp;<code>true</code>&nbsp;。这种情况下，每个成员都优先找排数&nbsp;<strong>最小</strong>&nbsp;，然后是座位编号最小的座位。如果不能安排所有&nbsp;<code>k</code>&nbsp;个成员的座位，请返回&nbsp;<code>false</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"BookMyShow\", \"gather\", \"gather\", \"scatter\", \"scatter\"]\n[[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]]\n<strong>输出：</strong>\n[null, [0, 0], [], true, false]\n\n<strong>解释：</strong>\nBookMyShow bms = new BookMyShow(2, 5); // 总共有 2 排，每排 5 个座位。\nbms.gather(4, 0); // 返回 [0, 0]\n                  // 这一组安排第 0 排 [0, 3] 的座位。\nbms.gather(2, 0); // 返回 []\n                  // 第 0 排只剩下 1 个座位。\n                  // 所以无法安排 2 个连续座位。\nbms.scatter(5, 1); // 返回 True\n                   // 这一组安排第 0 排第 4 个座位和第 1 排 [0, 3] 的座位。\nbms.scatter(5, 1); // 返回 False\n                   // 总共只剩下 2 个座位。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m, k &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= maxRow &lt;= n - 1</code></li>\n\t<li><code>gather</code> 和&nbsp;<code>scatter</code>&nbsp;<strong>总</strong> 调用次数不超过&nbsp;<code>5 * 10<sup>4</sup></code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2287.重排字符形成目标字符串",
        "hardRate": "EASY",
        "passRate": "65.14%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-characters-to-make-target-string/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-characters-to-make-target-string/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的字符串 <code>s</code> 和 <code>target</code> 。你可以从 <code>s</code> 取出一些字符并将其重排，得到若干新的字符串。</p>\n\n<p>从 <code>s</code> 中取出字符并重新排列，返回可以形成 <code>target</code> 的 <strong>最大</strong> 副本数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"ilovecodingonleetcode\", target = \"code\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\n对于 \"code\" 的第 1 个副本，选取下标为 4 、5 、6 和 7 的字符。\n对于 \"code\" 的第 2 个副本，选取下标为 17 、18 、19 和 20 的字符。\n形成的字符串分别是 \"ecod\" 和 \"code\" ，都可以重排为 \"code\" 。\n可以形成最多 2 个 \"code\" 的副本，所以返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abcba\", target = \"abc\"\n<strong>输出：</strong>1\n<strong>解释：</strong>\n选取下标为 0 、1 和 2 的字符，可以形成 \"abc\" 的 1 个副本。 \n可以形成最多 1 个 \"abc\" 的副本，所以返回 1 。\n注意，尽管下标 3 和 4 分别有额外的 'a' 和 'b' ，但不能重用下标 2 处的 'c' ，所以无法形成 \"abc\" 的第 2 个副本。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abbaccaddaeea\", target = \"aaaaa\"\n<strong>输出：</strong>1\n<strong>解释：</strong>\n选取下标为 0 、3 、6 、9 和 12 的字符，可以形成 \"aaaaa\" 的 1 个副本。\n可以形成最多 1 个 \"aaaaa\" 的副本，所以返回 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= target.length &lt;= 10</code></li>\n\t<li><code>s</code> 和 <code>target</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2288.价格减免",
        "hardRate": "MEDIUM",
        "passRate": "31.47%",
        "problemsUrl": "https://leetcode.cn/problems/apply-discount-to-prices/",
        "solutionsUrl": "https://leetcode.cn/problems/apply-discount-to-prices/solution",
        "problemsDesc": "<p><strong>句子</strong> 是由若干个单词组成的字符串，单词之间用单个空格分隔，其中每个单词可以包含数字、小写字母、和美元符号 <code>'$'</code> 。如果单词的形式为美元符号后跟着一个非负实数，那么这个单词就表示一个 <strong>价格</strong> 。</p>\n\n<ul>\n\t<li>例如 <code>\"$100\"</code>、<code>\"$23\"</code> 和 <code>\"$6\"</code> 表示价格，而 <code>\"100\"</code>、<code>\"$\"</code> 和 <code>\"$1e5</code> 不是。</li>\n</ul>\n\n<p>给你一个字符串 <code>sentence</code> 表示一个句子和一个整数 <code>discount</code> 。对于每个表示价格的单词，都在价格的基础上减免 <code>discount%</code> ，并 <strong>更新</strong> 该单词到句子中。所有更新后的价格应该表示为一个 <strong>恰好保留小数点后两位</strong> 的数字。</p>\n\n<p>返回表示修改后句子的字符串。</p>\n\n<p>注意：所有价格 <strong>最多</strong> 为&nbsp; <code>10</code> 位数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"there are $1 $2 and 5$ candies in the shop\", discount = 50\n<strong>输出：</strong>\"there are $0.50 $1.00 and 5$ candies in the shop\"\n<strong>解释：</strong>\n表示价格的单词是 \"$1\" 和 \"$2\" 。 \n- \"$1\" 减免 50% 为 \"$0.50\" ，所以 \"$1\" 替换为 \"$0.50\" 。\n- \"$2\" 减免 50% 为 \"$1\" ，所以 \"$1\" 替换为 \"$1.00\" 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"1 2 $3 4 $5 $6 7 8$ $9 $10$\", discount = 100\n<strong>输出：</strong>\"1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$\"\n<strong>解释：</strong>\n任何价格减免 100% 都会得到 0 。\n表示价格的单词分别是 \"$3\"、\"$5\"、\"$6\" 和 \"$9\"。\n每个单词都替换为 \"$0.00\"。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>sentence</code> 由小写英文字母、数字、<code>' '</code> 和&nbsp;<code>'$'</code> 组成</li>\n\t<li><code>sentence</code> 不含前导和尾随空格</li>\n\t<li><code>sentence</code> 的所有单词都用单个空格分隔</li>\n\t<li>所有价格都是 <strong>正</strong> 整数且不含前导零</li>\n\t<li>所有价格 <strong>最多</strong> 为&nbsp; <code>10</code> 位数字</li>\n\t<li><code>0 &lt;= discount &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2289.使数组按非递减顺序排列",
        "hardRate": "MEDIUM",
        "passRate": "21.91%",
        "problemsUrl": "https://leetcode.cn/problems/steps-to-make-array-non-decreasing/",
        "solutionsUrl": "https://leetcode.cn/problems/steps-to-make-array-non-decreasing/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。在一步操作中，移除所有满足&nbsp;<code>nums[i - 1] &gt; nums[i]</code> 的 <code>nums[i]</code> ，其中 <code>0 &lt; i &lt; nums.length</code> 。</p>\n\n<p>重复执行步骤，直到 <code>nums</code> 变为 <strong>非递减</strong> 数组，返回所需执行的操作数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,3,4,4,7,3,6,11,8,5,11]\n<strong>输出：</strong>3\n<strong>解释：</strong>执行下述几个步骤：\n- 步骤 1 ：[5,<em><strong>3</strong></em>,4,4,7,<em><strong>3</strong></em>,6,11,<em><strong>8</strong></em>,<em><strong>5</strong></em>,11] 变为 [5,4,4,7,6,11,11]\n- 步骤 2 ：[5,<em><strong>4</strong></em>,4,7,<em><strong>6</strong></em>,11,11] 变为 [5,4,7,11,11]\n- 步骤 3 ：[5,<em><strong>4</strong></em>,7,11,11] 变为 [5,7,11,11]\n[5,7,11,11] 是一个非递减数组，因此，返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,5,7,7,13]\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 已经是一个非递减数组，因此，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2290.到达角落需要移除障碍物的最小数目",
        "hardRate": "HARD",
        "passRate": "56.17%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>grid</code> ，数组大小为 <code>m x n</code> 。每个单元格都是两个值之一：</p>\n\n<ul>\n\t<li><code>0</code> 表示一个 <strong>空</strong> 单元格，</li>\n\t<li><code>1</code> 表示一个可以移除的 <strong>障碍物</strong> 。</li>\n</ul>\n\n<p>你可以向上、下、左、右移动，从一个空单元格移动到另一个空单元格。</p>\n\n<p>现在你需要从左上角&nbsp;<code>(0, 0)</code> 移动到右下角 <code>(m - 1, n - 1)</code> ，返回需要移除的障碍物的 <strong>最小</strong> 数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png\" style=\"width: 605px; height: 246px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,1,1],[1,1,0],[1,1,0]]\n<strong>输出：</strong>2\n<strong>解释：</strong>可以移除位于 (0, 1) 和 (0, 2) 的障碍物来创建从 (0, 0) 到 (2, 2) 的路径。\n可以证明我们至少需要移除两个障碍物，所以返回 2 。\n注意，可能存在其他方式来移除 2 个障碍物，创建出可行的路径。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png\" style=\"width: 405px; height: 246px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>不移除任何障碍物就能从 (0, 0) 到 (2, 4) ，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> <strong>或</strong> <code>1</code></li>\n\t<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2291.最大股票收益",
        "hardRate": "MEDIUM",
        "passRate": "58.69%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-profit-from-trading-stocks/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-profit-from-trading-stocks/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2292.连续两年有 3 个及以上订单的产品",
        "hardRate": "MEDIUM",
        "passRate": "44.01%",
        "problemsUrl": "https://leetcode.cn/problems/products-with-three-or-more-orders-in-two-consecutive-years/",
        "solutionsUrl": "https://leetcode.cn/problems/products-with-three-or-more-orders-in-two-consecutive-years/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2293.极大极小游戏",
        "hardRate": "EASY",
        "passRate": "73.04%",
        "problemsUrl": "https://leetcode.cn/problems/min-max-game/",
        "solutionsUrl": "https://leetcode.cn/problems/min-max-game/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，其长度是 <code>2</code> 的幂。</p>\n\n<p>对 <code>nums</code> 执行下述算法：</p>\n\n<ol>\n\t<li>设 <code>n</code> 等于 <code>nums</code> 的长度，如果 <code>n == 1</code> ，<strong>终止</strong> 算法过程。否则，<strong>创建</strong> 一个新的整数数组&nbsp;<code>newNums</code> ，新数组长度为 <code>n / 2</code> ，下标从 <strong>0</strong> 开始。</li>\n\t<li>对于满足&nbsp;<code>0 &lt;= i &lt; n / 2</code> 的每个 <strong>偶数</strong> 下标 <code>i</code> ，将 <code>newNums[i]</code> <strong>赋值</strong> 为 <code>min(nums[2 * i], nums[2 * i + 1])</code> 。</li>\n\t<li>对于满足&nbsp;<code>0 &lt;= i &lt; n / 2</code> 的每个 <strong>奇数</strong> 下标 <code>i</code> ，将 <code>newNums[i]</code> <strong>赋值</strong> 为 <code>max(nums[2 * i], nums[2 * i + 1])</code> 。</li>\n\t<li>用 <code>newNums</code> 替换 <code>nums</code> 。</li>\n\t<li>从步骤 1 开始 <strong>重复</strong> 整个过程。</li>\n</ol>\n\n<p>执行算法后，返回 <code>nums</code> 中剩下的那个数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/13/example1drawio-1.png\" style=\"width: 500px; height: 240px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,5,2,4,8,2,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>重复执行算法会得到下述数组。\n第一轮：nums = [1,5,4,2]\n第二轮：nums = [1,4]\n第三轮：nums = [1]\n1 是最后剩下的那个数字，返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3]\n<strong>输出：</strong>3\n<strong>解释：</strong>3 就是最后剩下的数字，返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1024</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums.length</code> 是 <code>2</code> 的幂</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2294.划分数组使最大差为 K",
        "hardRate": "MEDIUM",
        "passRate": "68.01%",
        "problemsUrl": "https://leetcode.cn/problems/partition-array-such-that-maximum-difference-is-k/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-array-such-that-maximum-difference-is-k/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。你可以将 <code>nums</code> 划分成一个或多个 <strong>子序列</strong> ，使 <code>nums</code> 中的每个元素都 <strong>恰好</strong> 出现在一个子序列中。</p>\n\n<p>在满足每个子序列中最大值和最小值之间的差值最多为 <code>k</code> 的前提下，返回需要划分的 <strong>最少</strong> 子序列数目。</p>\n\n<p><strong>子序列</strong> 本质是一个序列，可以通过删除另一个序列中的某些元素（或者不删除）但不改变剩下元素的顺序得到。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,6,1,2,5], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n可以将 nums 划分为两个子序列 [3,1,2] 和 [6,5] 。\n第一个子序列中最大值和最小值的差值是 3 - 1 = 2 。\n第二个子序列中最大值和最小值的差值是 6 - 5 = 1 。\n由于创建了两个子序列，返回 2 。可以证明需要划分的最少子序列数目就是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], k = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>\n可以将 nums 划分为两个子序列 [1,2] 和 [3] 。\n第一个子序列中最大值和最小值的差值是 2 - 1 = 1 。\n第二个子序列中最大值和最小值的差值是 3 - 3 = 0 。\n由于创建了两个子序列，返回 2 。注意，另一种最优解法是将 nums 划分成子序列 [1] 和 [2,3] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,4,5], k = 0\n<strong>输出：</strong>3\n<strong>解释：</strong>\n可以将 nums 划分为三个子序列 [2,2]、[4] 和 [5] 。\n第一个子序列中最大值和最小值的差值是 2 - 2 = 0 。\n第二个子序列中最大值和最小值的差值是 4 - 4 = 0 。\n第三个子序列中最大值和最小值的差值是 5 - 5 = 0 。\n由于创建了三个子序列，返回 3 。可以证明需要划分的最少子序列数目就是 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2295.替换数组中的元素",
        "hardRate": "MEDIUM",
        "passRate": "57.75%",
        "problemsUrl": "https://leetcode.cn/problems/replace-elements-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-elements-in-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>nums</code>&nbsp;，它包含 <code>n</code>&nbsp;个 <strong>互不相同</strong>&nbsp;的正整数。请你对这个数组执行 <code>m</code>&nbsp;个操作，在第 <code>i</code>&nbsp;个操作中，你需要将数字&nbsp;<code>operations[i][0]</code> 替换成&nbsp;<code>operations[i][1]</code>&nbsp;。</p>\n\n<p>题目保证在第 <code>i</code>&nbsp;个操作中：</p>\n\n<ul>\n\t<li><code>operations[i][0]</code>&nbsp;在&nbsp;<code>nums</code>&nbsp;中存在。</li>\n\t<li><code>operations[i][1]</code>&nbsp;在&nbsp;<code>nums</code>&nbsp;中不存在。</li>\n</ul>\n\n<p>请你返回执行完所有操作后的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]\n<b>输出：</b>[3,2,7,1]\n<b>解释：</b>我们对 nums 执行以下操作：\n- 将数字 1 替换为 3 。nums 变为 [<em><strong>3</strong></em>,2,4,6] 。\n- 将数字 4 替换为 7 。nums 变为 [3,2,<em><strong>7</strong></em>,6] 。\n- 将数字 6 替换为 1 。nums 变为 [3,2,7,<em><strong>1</strong></em>] 。\n返回最终数组 [3,2,7,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2], operations = [[1,3],[2,1],[3,2]]\n<b>输出：</b>[2,1]\n<b>解释：</b>我们对 nums 执行以下操作：\n- 将数字 1 替换为 3 。nums 变为 [<em><strong>3</strong></em>,2] 。\n- 将数字 2 替换为 1 。nums 变为 [3,<em><strong>1</strong></em>] 。\n- 将数字 3 替换为 2 。nums 变为 [<em><strong>2</strong></em>,1] 。\n返回最终数组 [2,1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == operations.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums</code>&nbsp;中所有数字 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>operations[i].length == 2</code></li>\n\t<li><code>1 &lt;= nums[i], operations[i][0], operations[i][1] &lt;= 10<sup>6</sup></code></li>\n\t<li>在执行第&nbsp;<code>i</code> 个操作时，<code>operations[i][0]</code>&nbsp;在&nbsp;<code>nums</code>&nbsp;中存在。</li>\n\t<li>在执行第&nbsp;<code>i</code>&nbsp;个操作时，<code>operations[i][1]</code>&nbsp;在&nbsp;<code>nums</code>&nbsp;中不存在。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2296.设计一个文本编辑器",
        "hardRate": "HARD",
        "passRate": "43.78%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-text-editor/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-text-editor/solution",
        "problemsDesc": "<p>请你设计一个带光标的文本编辑器，它可以实现以下功能：</p>\n\n<ul>\n\t<li><strong>添加：</strong>在光标所在处添加文本。</li>\n\t<li><strong>删除：</strong>在光标所在处删除文本（模拟键盘的删除键）。</li>\n\t<li><strong>移动：</strong>将光标往左或者往右移动。</li>\n</ul>\n\n<p>当删除文本时，只有光标左边的字符会被删除。光标会留在文本内，也就是说任意时候&nbsp;<code>0 &lt;= cursor.position &lt;= currentText.length</code>&nbsp;都成立。</p>\n\n<p>请你实现&nbsp;<code>TextEditor</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>TextEditor()</code>&nbsp;用空文本初始化对象。</li>\n\t<li><code>void addText(string text)</code>&nbsp;将&nbsp;<code>text</code>&nbsp;添加到光标所在位置。添加完后光标在&nbsp;<code>text</code>&nbsp;的右边。</li>\n\t<li><code>int deleteText(int k)</code>&nbsp;删除光标左边&nbsp;<code>k</code>&nbsp;个字符。返回实际删除的字符数目。</li>\n\t<li><code>string cursorLeft(int k)</code> 将光标向左移动&nbsp;<code>k</code>&nbsp;次。返回移动后光标左边&nbsp;<code>min(10, len)</code>&nbsp;个字符，其中&nbsp;<code>len</code>&nbsp;是光标左边的字符数目。</li>\n\t<li><code>string cursorRight(int k)</code>&nbsp;将光标向右移动&nbsp;<code>k</code>&nbsp;次。返回移动后光标左边&nbsp;<code>min(10, len)</code>&nbsp;个字符，其中&nbsp;<code>len</code>&nbsp;是光标左边的字符数目。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"TextEditor\", \"addText\", \"deleteText\", \"addText\", \"cursorRight\", \"cursorLeft\", \"deleteText\", \"cursorLeft\", \"cursorRight\"]\n[[], [\"leetcode\"], [4], [\"practice\"], [3], [8], [10], [2], [6]]\n<strong>输出：</strong>\n[null, null, 4, null, \"etpractice\", \"leet\", 4, \"\", \"practi\"]\n\n<strong>解释：</strong>\nTextEditor textEditor = new TextEditor(); // 当前 text 为 \"|\" 。（'|' 字符表示光标）\ntextEditor.addText(\"leetcode\"); // 当前文本为 \"leetcode|\" 。\ntextEditor.deleteText(4); // 返回 4\n                          // 当前文本为 \"leet|\" 。\n                          // 删除了 4 个字符。\ntextEditor.addText(\"practice\"); // 当前文本为 \"leetpractice|\" 。\ntextEditor.cursorRight(3); // 返回 \"etpractice\"\n                           // 当前文本为 \"leetpractice|\". \n                           // 光标无法移动到文本以外，所以无法移动。\n                           // \"etpractice\" 是光标左边的 10 个字符。\ntextEditor.cursorLeft(8); // 返回 \"leet\"\n                          // 当前文本为 \"leet|practice\" 。\n                          // \"leet\" 是光标左边的 min(10, 4) = 4 个字符。\ntextEditor.deleteText(10); // 返回 4\n                           // 当前文本为 \"|practice\" 。\n                           // 只有 4 个字符被删除了。\ntextEditor.cursorLeft(2); // 返回 \"\"\n                          // 当前文本为 \"|practice\" 。\n                          // 光标无法移动到文本以外，所以无法移动。\n                          // \"\" 是光标左边的 min(10, 0) = 0 个字符。\ntextEditor.cursorRight(6); // 返回 \"practi\"\n                           // 当前文本为 \"practi|ce\" 。\n                           // \"practi\" 是光标左边的 min(10, 6) = 6 个字符。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length, k &lt;= 40</code></li>\n\t<li><code>text</code>&nbsp;只含有小写英文字母。</li>\n\t<li>调用 <code>addText</code>&nbsp;，<code>deleteText</code>&nbsp;，<code>cursorLeft</code> 和&nbsp;<code>cursorRight</code>&nbsp;的 <strong>总</strong> 次数不超过&nbsp;<code>2 * 10<sup>4</sup></code>&nbsp;次。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能设计并实现一个每次调用时间复杂度为 <code>O(k)</code> 的解决方案吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2297.跳跃游戏 VIII",
        "hardRate": "MEDIUM",
        "passRate": "57.07%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game-viii/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game-viii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2298.周末任务计数",
        "hardRate": "MEDIUM",
        "passRate": "78.84%",
        "problemsUrl": "https://leetcode.cn/problems/tasks-count-in-the-weekend/",
        "solutionsUrl": "https://leetcode.cn/problems/tasks-count-in-the-weekend/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2299.强密码检验器 II",
        "hardRate": "EASY",
        "passRate": "65.61%",
        "problemsUrl": "https://leetcode.cn/problems/strong-password-checker-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/strong-password-checker-ii/solution",
        "problemsDesc": "<p>如果一个密码满足以下所有条件，我们称它是一个 <strong>强</strong>&nbsp;密码：</p>\n\n<ul>\n\t<li>它有至少 <code>8</code>&nbsp;个字符。</li>\n\t<li>至少包含 <strong>一个小写英文</strong>&nbsp;字母。</li>\n\t<li>至少包含 <strong>一个大写英文</strong>&nbsp;字母。</li>\n\t<li>至少包含 <strong>一个数字</strong>&nbsp;。</li>\n\t<li>至少包含 <strong>一个特殊字符</strong>&nbsp;。特殊字符为：<code>\"!@#$%^&amp;*()-+\"</code>&nbsp;中的一个。</li>\n\t<li>它 <strong>不</strong>&nbsp;包含&nbsp;<code>2</code>&nbsp;个连续相同的字符（比方说&nbsp;<code>\"aab\"</code>&nbsp;不符合该条件，但是&nbsp;<code>\"aba\"</code>&nbsp;符合该条件）。</li>\n</ul>\n\n<p>给你一个字符串&nbsp;<code>password</code>&nbsp;，如果它是一个&nbsp;<strong>强</strong>&nbsp;密码，返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>password = \"IloveLe3tcode!\"\n<b>输出：</b>true\n<b>解释：</b>密码满足所有的要求，所以我们返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>password = \"Me+You--IsMyDream\"\n<b>输出：</b>false\n<b>解释：</b>密码不包含数字，且包含 2 个连续相同的字符。所以我们返回 false 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>password = \"1aB!\"\n<b>输出：</b>false\n<b>解释：</b>密码不符合长度要求。所以我们返回 false 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= password.length &lt;= 100</code></li>\n\t<li><code>password</code>&nbsp;包含字母，数字和&nbsp;<code>\"!@#$%^&amp;*()-+\"</code>&nbsp;这些特殊字符。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2300.咒语和药水的成功对数",
        "hardRate": "MEDIUM",
        "passRate": "39.35%",
        "problemsUrl": "https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/",
        "solutionsUrl": "https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/solution",
        "problemsDesc": "<p>给你两个正整数数组&nbsp;<code>spells</code> 和&nbsp;<code>potions</code>&nbsp;，长度分别为&nbsp;<code>n</code> 和&nbsp;<code>m</code>&nbsp;，其中&nbsp;<code>spells[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个咒语的能量强度，<code>potions[j]</code>&nbsp;表示第&nbsp;<code>j</code>&nbsp;瓶药水的能量强度。</p>\n\n<p>同时给你一个整数&nbsp;<code>success</code>&nbsp;。一个咒语和药水的能量强度 <strong>相乘</strong> 如果&nbsp;<strong>大于等于</strong>&nbsp;<code>success</code>&nbsp;，那么它们视为一对&nbsp;<strong>成功</strong>&nbsp;的组合。</p>\n\n<p>请你返回一个长度为 <code>n</code>&nbsp;的整数数组<em>&nbsp;</em><code>pairs</code>，其中<em>&nbsp;</em><code>pairs[i]</code>&nbsp;是能跟第 <code>i</code>&nbsp;个咒语成功组合的 <b>药水</b>&nbsp;数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>spells = [5,1,3], potions = [1,2,3,4,5], success = 7\n<b>输出：</b>[4,0,3]\n<strong>解释：</strong>\n- 第 0 个咒语：5 * [1,2,3,4,5] = [5,<em><strong>10</strong></em>,<em><strong>15</strong></em>,<em><strong>20</strong></em>,<em><strong>25</strong></em>] 。总共 4 个成功组合。\n- 第 1 个咒语：1 * [1,2,3,4,5] = [1,2,3,4,5] 。总共 0 个成功组合。\n- 第 2 个咒语：3 * [1,2,3,4,5] = [3,6,<em><strong>9</strong></em>,<em><strong>12</strong></em>,<em><strong>15</strong></em>] 。总共 3 个成功组合。\n所以返回 [4,0,3] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>spells = [3,1,2], potions = [8,5,8], success = 16\n<b>输出：</b>[2,0,2]\n<strong>解释：</strong>\n- 第 0 个咒语：3 * [8,5,8] = [<em><strong>24</strong></em>,15,<em><strong>24</strong></em>] 。总共 2 个成功组合。\n- 第 1 个咒语：1 * [8,5,8] = [8,5,8] 。总共 0 个成功组合。\n- 第 2 个咒语：2 * [8,5,8] = [<em><strong>16</strong></em>,10,<em><strong>16</strong></em>] 。总共 2 个成功组合。\n所以返回 [2,0,2] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == spells.length</code></li>\n\t<li><code>m == potions.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= spells[i], potions[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= success &lt;= 10<sup>10</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2301.替换字符后匹配",
        "hardRate": "HARD",
        "passRate": "45.41%",
        "problemsUrl": "https://leetcode.cn/problems/match-substring-after-replacement/",
        "solutionsUrl": "https://leetcode.cn/problems/match-substring-after-replacement/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s</code> 和&nbsp;<code>sub</code>&nbsp;。同时给你一个二维字符数组&nbsp;<code>mappings</code> ，其中&nbsp;<code>mappings[i] = [old<sub>i</sub>, new<sub>i</sub>]</code>&nbsp;表示你可以将&nbsp;<code>sub</code>&nbsp;中任意数目的&nbsp;<code>old<sub>i</sub></code>&nbsp;字符替换为&nbsp;<code>new<sub>i</sub></code>&nbsp;。<code>sub</code>&nbsp;中每个字符 <b>不能</b>&nbsp;被替换超过一次。</p>\n\n<p>如果使用 <code>mappings</code>&nbsp;替换 0 个或者若干个字符，可以将 <code>sub</code>&nbsp;变成 <code>s</code>&nbsp;的一个子字符串，请你返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>一个 <strong>子字符串</strong>&nbsp;是字符串中连续非空的字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"fool3e7bar\", sub = \"leet\", mappings = [[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"]]\n<b>输出：</b>true\n<b>解释：</b>将 sub 中第一个 'e' 用 '3' 替换，将 't' 用 '7' 替换。\n现在 sub = \"l3e7\" ，它是 s 的子字符串，所以我们返回 true 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"fooleetbar\", sub = \"f00l\", mappings = [[\"o\",\"0\"]]\n<b>输出：</b>false\n<b>解释：</b>字符串 \"f00l\" 不是 s 的子串且没有可以进行的修改。\n注意我们不能用 'o' 替换 '0' 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"Fool33tbaR\", sub = \"leetd\", mappings = [[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"],[\"d\",\"b\"],[\"p\",\"b\"]]\n<b>输出：</b>true\n<b>解释：</b>将 sub 里第一个和第二个 'e' 用 '3' 替换，用 'b' 替换 sub 里的 'd' 。\n得到 sub = \"l33tb\" ，它是 s 的子字符串，所以我们返回 true 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sub.length &lt;= s.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= mappings.length &lt;= 1000</code></li>\n\t<li><code>mappings[i].length == 2</code></li>\n\t<li><code>old<sub>i</sub> != new<sub>i</sub></code></li>\n\t<li><code>s</code> 和&nbsp;<code>sub</code>&nbsp;只包含大写和小写英文字母和数字。</li>\n\t<li><code>old<sub>i</sub></code> 和&nbsp;<code>new<sub>i</sub></code>&nbsp;是大写、小写字母或者是个数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2302.统计得分小于 K 的子数组数目",
        "hardRate": "HARD",
        "passRate": "50.94%",
        "problemsUrl": "https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/",
        "solutionsUrl": "https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/solution",
        "problemsDesc": "<p>一个数组的 <strong>分数</strong>&nbsp;定义为数组之和 <strong>乘以</strong>&nbsp;数组的长度。</p>\n\n<ul>\n\t<li>比方说，<code>[1, 2, 3, 4, 5]</code>&nbsp;的分数为&nbsp;<code>(1 + 2 + 3 + 4 + 5) * 5 = 75</code>&nbsp;。</li>\n</ul>\n\n<p>给你一个正整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，请你返回&nbsp;<code>nums</code>&nbsp;中分数&nbsp;<strong>严格小于&nbsp;</strong><code>k</code>&nbsp;的&nbsp;<strong>非空整数子数组数目</strong>。</p>\n\n<p><strong>子数组</strong> 是数组中的一个连续元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,4,3,5], k = 10\n<b>输出：</b>6\n<strong>解释：</strong>\n有 6 个子数组的分数小于 10 ：\n- [2] 分数为 2 * 1 = 2 。\n- [1] 分数为 1 * 1 = 1 。\n- [4] 分数为 4 * 1 = 4 。\n- [3] 分数为 3 * 1 = 3 。 \n- [5] 分数为 5 * 1 = 5 。\n- [2,1] 分数为 (2 + 1) * 2 = 6 。\n注意，子数组 [1,4] 和 [4,3,5] 不符合要求，因为它们的分数分别为 10 和 36，但我们要求子数组的分数严格小于 10 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,1], k = 5\n<b>输出：</b>5\n<strong>解释：</strong>\n除了 [1,1,1] 以外每个子数组分数都小于 5 。\n[1,1,1] 分数为 (1 + 1 + 1) * 3 = 9 ，大于 5 。\n所以总共有 5 个子数组得分小于 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2303.计算应缴税款总额",
        "hardRate": "EASY",
        "passRate": "70.42%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-amount-paid-in-taxes/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-amount-paid-in-taxes/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>brackets</code> ，其中 <code>brackets[i] = [upper<sub>i</sub>, percent<sub>i</sub>]</code> ，表示第 <code>i</code> 个税级的上限是 <code>upper<sub>i</sub></code> ，征收的税率为 <code>percent<sub>i</sub></code> 。税级按上限 <strong>从低到高排序</strong>（在满足 <code>0 &lt; i &lt; brackets.length</code> 的前提下，<code>upper<sub>i-1</sub> &lt; upper<sub>i</sub></code>）。</p>\n\n<p>税款计算方式如下：</p>\n\n<ul>\n\t<li>不超过 <code>upper<sub>0</sub></code> 的收入按税率 <code>percent<sub>0</sub></code> 缴纳</li>\n\t<li>接着 <code>upper<sub>1</sub> - upper<sub>0</sub></code> 的部分按税率 <code>percent<sub>1</sub></code> 缴纳</li>\n\t<li>然后 <code>upper<sub>2</sub> - upper<sub>1</sub></code> 的部分按税率 <code>percent<sub>2</sub></code> 缴纳</li>\n\t<li>以此类推</li>\n</ul>\n\n<p>给你一个整数 <code>income</code> 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 <code>10<sup>-5</sup></code> 的结果将被视作正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>brackets = [[3,50],[7,10],[12,25]], income = 10\n<strong>输出：</strong>2.65000\n<strong>解释：</strong>\n前 $3 的税率为 50% 。需要支付税款 $3 * 50% = $1.50 。\n接下来 $7 - $3 = $4 的税率为 10% 。需要支付税款 $4 * 10% = $0.40 。\n最后 $10 - $7 = $3 的税率为 25% 。需要支付税款 $3 * 25% = $0.75 。\n需要支付的税款总计 $1.50 + $0.40 + $0.75 = $2.65 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>brackets = [[1,0],[4,25],[5,50]], income = 2\n<strong>输出：</strong>0.25000\n<strong>解释：</strong>\n前 $1 的税率为 0% 。需要支付税款 $1 * 0% = $0 。\n剩下 $1 的税率为 25% 。需要支付税款 $1 * 25% = $0.25 。\n需要支付的税款总计 $0 + $0.25 = $0.25 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>brackets = [[2,50]], income = 0\n<strong>输出：</strong>0.00000\n<strong>解释：</strong>\n没有收入，无需纳税，需要支付的税款总计 $0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= brackets.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= upper<sub>i</sub> &lt;= 1000</code></li>\n\t<li><code>0 &lt;= percent<sub>i</sub> &lt;= 100</code></li>\n\t<li><code>0 &lt;= income &lt;= 1000</code></li>\n\t<li><code>upper<sub>i</sub></code> 按递增顺序排列</li>\n\t<li><code>upper<sub>i</sub></code> 中的所有值 <strong>互不相同</strong></li>\n\t<li>最后一个税级的上限大于等于 <code>income</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2304.网格中的最小路径代价",
        "hardRate": "MEDIUM",
        "passRate": "64.27%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-path-cost-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-path-cost-in-a-grid/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数矩阵&nbsp;<code>grid</code> ，矩阵大小为 <code>m x n</code> ，由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 <strong>下一行</strong> 的任何其他单元格。如果你位于单元格 <code>(x, y)</code> ，且满足 <code>x &lt; m - 1</code> ，你可以移动到 <code>(x + 1, 0)</code>, <code>(x + 1, 1)</code>, ..., <code>(x + 1, n - 1)</code><strong> </strong>中的任何一个单元格。<strong>注意：</strong>&nbsp;在最后一行中的单元格不能触发移动。</p>\n\n<p>每次可能的移动都需要付出对应的代价，代价用一个下标从 <strong>0</strong> 开始的二维数组 <code>moveCost</code> 表示，该数组大小为 <code>(m * n) x n</code> ，其中 <code>moveCost[i][j]</code> 是从值为 <code>i</code> 的单元格移动到下一行第 <code>j</code> 列单元格的代价。从&nbsp;<code>grid</code> 最后一行的单元格移动的代价可以忽略。</p>\n\n<p><code>grid</code> 一条路径的代价是：所有路径经过的单元格的 <strong>值之和</strong> 加上 所有移动的 <strong>代价之和 </strong>。从 <strong>第一行</strong> 任意单元格出发，返回到达 <strong>最后一行</strong> 任意单元格的最小路径代价<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/28/griddrawio-2.png\" style=\"width: 301px; height: 281px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\n<strong>输出：</strong>17\n<strong>解释：</strong>最小代价的路径是 5 -&gt; 0 -&gt; 1 。\n- 路径途经单元格值之和 5 + 0 + 1 = 6 。\n- 从 5 移动到 0 的代价为 3 。\n- 从 0 移动到 1 的代价为 8 。\n路径总代价为 6 + 3 + 8 = 17 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n最小代价的路径是 2 -&gt; 3 。 \n- 路径途经单元格值之和 2 + 3 = 5 。 \n- 从 2 移动到 3 的代价为 1 。 \n路径总代价为 5 + 1 = 6 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>grid</code> 由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成</li>\n\t<li><code>moveCost.length == m * n</code></li>\n\t<li><code>moveCost[i].length == n</code></li>\n\t<li><code>1 &lt;= moveCost[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2305.公平分发饼干",
        "hardRate": "MEDIUM",
        "passRate": "72.69%",
        "problemsUrl": "https://leetcode.cn/problems/fair-distribution-of-cookies/",
        "solutionsUrl": "https://leetcode.cn/problems/fair-distribution-of-cookies/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>cookies</code> ，其中 <code>cookies[i]</code> 表示在第 <code>i</code> 个零食包中的饼干数量。另给你一个整数 <code>k</code> 表示等待分发零食包的孩子数量，<strong>所有</strong> 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。</p>\n\n<p>分发的 <strong>不公平程度</strong> 定义为单个孩子在分发过程中能够获得饼干的最大总数。</p>\n\n<p>返回所有分发的最小不公平程度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>cookies = [8,15,10,20,8], k = 2\n<strong>输出：</strong>31\n<strong>解释：</strong>一种最优方案是 [8,15,8] 和 [10,20] 。\n- 第 1 个孩子分到 [8,15,8] ，总计 8 + 15 + 8 = 31 块饼干。\n- 第 2 个孩子分到 [10,20] ，总计 10 + 20 = 30 块饼干。\n分发的不公平程度为 max(31,30) = 31 。\n可以证明不存在不公平程度小于 31 的分发方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>cookies = [6,1,3,2,2,4,1,2], k = 3\n<strong>输出：</strong>7\n<strong>解释：</strong>一种最优方案是 [6,1]、[3,2,2] 和 [4,1,2] 。\n- 第 1 个孩子分到 [6,1] ，总计 6 + 1 = 7 块饼干。 \n- 第 2 个孩子分到 [3,2,2] ，总计 3 + 2 + 2 = 7 块饼干。\n- 第 3 个孩子分到 [4,1,2] ，总计 4 + 1 + 2 = 7 块饼干。\n分发的不公平程度为 max(7,7,7) = 7 。\n可以证明不存在不公平程度小于 7 的分发方案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= cookies.length &lt;= 8</code></li>\n\t<li><code>1 &lt;= cookies[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= k &lt;= cookies.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2306.公司命名",
        "hardRate": "HARD",
        "passRate": "44.54%",
        "problemsUrl": "https://leetcode.cn/problems/naming-a-company/",
        "solutionsUrl": "https://leetcode.cn/problems/naming-a-company/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>ideas</code> 表示在公司命名过程中使用的名字列表。公司命名流程如下：</p>\n\n<ol>\n\t<li>从 <code>ideas</code> 中选择 2 个 <strong>不同</strong> 名字，称为 <code>idea<sub>A</sub></code> 和 <code>idea<sub>B</sub></code> 。</li>\n\t<li>交换 <code>idea<sub>A</sub></code> 和 <code>idea<sub>B</sub></code> 的首字母。</li>\n\t<li>如果得到的两个新名字 <strong>都</strong> 不在 <code>ideas</code> 中，那么 <code>idea<sub>A</sub> idea<sub>B</sub></code>（<strong>串联</strong> <code>idea<sub>A</sub></code> 和 <code>idea<sub>B</sub></code> ，中间用一个空格分隔）是一个有效的公司名字。</li>\n\t<li>否则，不是一个有效的名字。</li>\n</ol>\n\n<p>返回 <strong>不同</strong> 且有效的公司名字的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]\n<strong>输出：</strong>6\n<strong>解释：</strong>下面列出一些有效的选择方案：\n- (\"coffee\", \"donuts\")：对应的公司名字是 \"doffee conuts\" 。\n- (\"donuts\", \"coffee\")：对应的公司名字是 \"conuts doffee\" 。\n- (\"donuts\", \"time\")：对应的公司名字是 \"tonuts dime\" 。\n- (\"donuts\", \"toffee\")：对应的公司名字是 \"tonuts doffee\" 。\n- (\"time\", \"donuts\")：对应的公司名字是 \"dime tonuts\" 。\n- (\"toffee\", \"donuts\")：对应的公司名字是 \"doffee tonuts\" 。\n因此，总共有 6 个不同的公司名字。\n\n下面列出一些无效的选择方案：\n- (\"coffee\", \"time\")：在原数组中存在交换后形成的名字 \"toffee\" 。\n- (\"time\", \"toffee\")：在原数组中存在交换后形成的两个名字。\n- (\"coffee\", \"toffee\")：在原数组中存在交换后形成的两个名字。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>ideas = [\"lack\",\"back\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在有效的选择方案。因此，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= ideas.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= ideas[i].length &lt;= 10</code></li>\n\t<li><code>ideas[i]</code> 由小写英文字母组成</li>\n\t<li><code>ideas</code> 中的所有字符串 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2307.检查方程中的矛盾之处",
        "hardRate": "HARD",
        "passRate": "43.97%",
        "problemsUrl": "https://leetcode.cn/problems/check-for-contradictions-in-equations/",
        "solutionsUrl": "https://leetcode.cn/problems/check-for-contradictions-in-equations/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2308.按性别排列表格",
        "hardRate": "MEDIUM",
        "passRate": "77.50%",
        "problemsUrl": "https://leetcode.cn/problems/arrange-table-by-gender/",
        "solutionsUrl": "https://leetcode.cn/problems/arrange-table-by-gender/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2309.兼具大小写的最好英文字母",
        "hardRate": "EASY",
        "passRate": "71.82%",
        "problemsUrl": "https://leetcode.cn/problems/greatest-english-letter-in-upper-and-lower-case/",
        "solutionsUrl": "https://leetcode.cn/problems/greatest-english-letter-in-upper-and-lower-case/solution",
        "problemsDesc": "<p>给你一个由英文字母组成的字符串 <code>s</code> ，请你找出并返回 <code>s</code> 中的 <strong>最好</strong> 英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。</p>\n\n<p><strong>最好</strong> 英文字母的大写和小写形式必须 <strong>都</strong> 在 <code>s</code> 中出现。</p>\n\n<p>英文字母 <code>b</code> 比另一个英文字母&nbsp;<code>a</code>&nbsp;<strong>更好</strong> 的前提是：英文字母表中，<code>b</code> 在 <code>a</code> 之 <strong>后</strong> 出现。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"l<em><strong>Ee</strong></em>TcOd<em><strong>E</strong></em>\"\n<strong>输出：</strong>\"E\"\n<strong>解释：</strong>\n字母 'E' 是唯一一个大写和小写形式都出现的字母。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a<em><strong>rR</strong></em>AzFif\"\n<strong>输出：</strong>\"R\"\n<strong>解释：</strong>\n字母 'R' 是大写和小写形式都出现的最好英文字母。\n注意 'A' 和 'F' 的大写和小写形式也都出现了，但是 'R' 比 'F' 和 'A' 更好。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"AbCdEfGhIjK\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>\n不存在大写和小写形式都出现的字母。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 由小写和大写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2310.个位数字为 K 的整数之和",
        "hardRate": "MEDIUM",
        "passRate": "27.60%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-numbers-with-units-digit-k/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-numbers-with-units-digit-k/solution",
        "problemsDesc": "<p>给你两个整数 <code>num</code> 和 <code>k</code> ，考虑具有以下属性的正整数多重集：</p>\n\n<ul>\n\t<li>每个整数个位数字都是 <code>k</code> 。</li>\n\t<li>所有整数之和是 <code>num</code> 。</li>\n</ul>\n\n<p>返回该多重集的最小大小，如果不存在这样的多重集，返回<em> </em><code>-1</code> 。</p>\n\n<p>注意：</p>\n\n<ul>\n\t<li>多重集与集合类似，但多重集可以包含多个同一整数，空多重集的和为 <code>0</code> 。</li>\n\t<li><strong>个位数字</strong> 是数字最右边的数位。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 58, k = 9\n<strong>输出：</strong>2\n<strong>解释：</strong>\n多重集 [9,49] 满足题目条件，和为 58 且每个整数的个位数字是 9 。\n另一个满足条件的多重集是 [19,39] 。\n可以证明 2 是满足题目条件的多重集的最小长度。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 37, k = 2\n<strong>输出：</strong>-1\n<strong>解释：</strong>个位数字为 2 的整数无法相加得到 37 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 0, k = 7\n<strong>输出：</strong>0\n<strong>解释：</strong>空多重集的和为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 3000</code></li>\n\t<li><code>0 &lt;= k &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2311.小于等于 K 的最长二进制子序列",
        "hardRate": "MEDIUM",
        "passRate": "36.96%",
        "problemsUrl": "https://leetcode.cn/problems/longest-binary-subsequence-less-than-or-equal-to-k/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-binary-subsequence-less-than-or-equal-to-k/solution",
        "problemsDesc": "<p>给你一个二进制字符串&nbsp;<code>s</code>&nbsp;和一个正整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>请你返回 <code>s</code>&nbsp;的 <strong>最长</strong>&nbsp;子序列，且该子序列对应的 <strong>二进制</strong>&nbsp;数字小于等于 <code>k</code>&nbsp;。</p>\n\n<p>注意：</p>\n\n<ul>\n\t<li>子序列可以有 <strong>前导 0</strong>&nbsp;。</li>\n\t<li>空字符串视为&nbsp;<code>0</code>&nbsp;。</li>\n\t<li><strong>子序列</strong>&nbsp;是指从一个字符串中删除零个或者多个字符后，不改变顺序得到的剩余字符序列。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"1001010\", k = 5\n<b>输出：</b>5\n<b>解释：</b>s 中小于等于 5 的最长子序列是 \"00010\" ，对应的十进制数字是 2 。\n注意 \"00100\" 和 \"00101\" 也是可行的最长子序列，十进制分别对应 4 和 5 。\n最长子序列的长度为 5 ，所以返回 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"00101001\", k = 1\n<b>输出：</b>6\n<b>解释：</b>\"000001\" 是 s 中小于等于 1 的最长子序列，对应的十进制数字是 1 。\n最长子序列的长度为 6 ，所以返回 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code> 要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code> 。</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2312.卖木头块",
        "hardRate": "HARD",
        "passRate": "53.72%",
        "problemsUrl": "https://leetcode.cn/problems/selling-pieces-of-wood/",
        "solutionsUrl": "https://leetcode.cn/problems/selling-pieces-of-wood/solution",
        "problemsDesc": "<p>给你两个整数&nbsp;<code>m</code> 和&nbsp;<code>n</code>&nbsp;，分别表示一块矩形木块的高和宽。同时给你一个二维整数数组&nbsp;<code>prices</code>&nbsp;，其中&nbsp;<code>prices[i] = [h<sub>i</sub>, w<sub>i</sub>, price<sub>i</sub>]</code>&nbsp;表示你可以以&nbsp;<code>price<sub>i</sub></code>&nbsp;元的价格卖一块高为&nbsp;<code>h<sub>i</sub></code>&nbsp;宽为&nbsp;<code>w<sub>i</sub></code>&nbsp;的矩形木块。</p>\n\n<p>每一次操作中，你必须按下述方式之一执行切割操作，以得到两块更小的矩形木块：</p>\n\n<ul>\n\t<li>沿垂直方向按高度 <strong>完全</strong> 切割木块，或</li>\n\t<li>沿水平方向按宽度 <strong>完全</strong> 切割木块</li>\n</ul>\n\n<p>在将一块木块切成若干小木块后，你可以根据 <code>prices</code>&nbsp;卖木块。你可以卖多块同样尺寸的木块。你不需要将所有小木块都卖出去。你 <strong>不能</strong>&nbsp;旋转切好后木块的高和宽。</p>\n\n<p>请你返回切割一块大小为<em>&nbsp;</em><code>m x n</code><em> </em>的木块后，能得到的&nbsp;<strong>最多</strong>&nbsp;钱数。</p>\n\n<p>注意你可以切割木块任意次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/27/ex1.png\" style=\"width: 239px; height: 150px;\" /></p>\n\n<pre>\n<b>输入：</b>m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]]\n<b>输出：</b>19\n<b>解释：</b>上图展示了一个可行的方案。包括：\n- 2 块 2 x 2 的小木块，售出 2 * 7 = 14 元。\n- 1 块 2 x 1 的小木块，售出 1 * 3 = 3 元。\n- 1 块 1 x 4 的小木块，售出 1 * 2 = 2 元。\n总共售出 14 + 3 + 2 = 19 元。\n19 元是最多能得到的钱数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/27/ex2new.png\" style=\"width: 250px; height: 175px;\" /></p>\n\n<pre>\n<b>输入：</b>m = 4, n = 6, prices = [[3,2,10],[1,4,2],[4,1,3]]\n<b>输出：</b>32\n<b>解释：</b>上图展示了一个可行的方案。包括：\n- 3 块 3 x 2 的小木块，售出 3 * 10 = 30 元。\n- 1 块 1 x 4 的小木块，售出 1 * 2 = 2 元。\n总共售出 30 + 2 = 32 元。\n32 元是最多能得到的钱数。\n注意我们不能旋转 1 x 4 的木块来得到 4 x 1 的木块。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>1 &lt;= prices.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>prices[i].length == 3</code></li>\n\t<li><code>1 &lt;= h<sub>i</sub> &lt;= m</code></li>\n\t<li><code>1 &lt;= w<sub>i</sub> &lt;= n</code></li>\n\t<li><code>1 &lt;= price<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n\t<li>所有&nbsp;<code>(h<sub>i</sub>, w<sub>i</sub>)</code> <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2313.二叉树中得到结果所需的最少翻转次数",
        "hardRate": "HARD",
        "passRate": "67.71%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-flips-in-binary-tree-to-get-result/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-flips-in-binary-tree-to-get-result/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2314.每个城市最高气温的第一天",
        "hardRate": "MEDIUM",
        "passRate": "71.41%",
        "problemsUrl": "https://leetcode.cn/problems/the-first-day-of-the-maximum-recorded-degree-in-each-city/",
        "solutionsUrl": "https://leetcode.cn/problems/the-first-day-of-the-maximum-recorded-degree-in-each-city/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2315.统计星号",
        "hardRate": "EASY",
        "passRate": "85.81%",
        "problemsUrl": "https://leetcode.cn/problems/count-asterisks/",
        "solutionsUrl": "https://leetcode.cn/problems/count-asterisks/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，每&nbsp;<strong>两个</strong>&nbsp;连续竖线&nbsp;<code>'|'</code>&nbsp;为 <strong>一对</strong>&nbsp;。换言之，第一个和第二个&nbsp;<code>'|'</code>&nbsp;为一对，第三个和第四个&nbsp;<code>'|'</code>&nbsp;为一对，以此类推。</p>\n\n<p>请你返回 <strong>不在</strong> 竖线对之间，<code>s</code>&nbsp;中&nbsp;<code>'*'</code>&nbsp;的数目。</p>\n\n<p><strong>注意</strong>，每个竖线&nbsp;<code>'|'</code>&nbsp;都会 <strong>恰好</strong>&nbsp;属于一个对。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"l|*e*et|c**o|*de|\"\n<b>输出：</b>2\n<b>解释：</b>不在竖线对之间的字符加粗加斜体后，得到字符串：\"<strong><em>l</em></strong>|*e*et|<strong><em>c**o</em></strong>|*de|\" 。\n第一和第二条竖线 '|' 之间的字符不计入答案。\n同时，第三条和第四条竖线 '|' 之间的字符也不计入答案。\n不在竖线对之间总共有 2 个星号，所以我们返回 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"iamprogrammer\"\n<b>输出：</b>0\n<b>解释：</b>在这个例子中，s 中没有星号。所以返回 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"yo|uar|e**|b|e***au|tifu|l\"\n<b>输出：</b>5\n<b>解释：</b>需要考虑的字符加粗加斜体后：\"<strong><em>yo</em></strong>|uar|<strong><em>e**</em></strong>|b|<strong><em>e***au</em></strong>|tifu|<strong><em>l</em></strong>\" 。不在竖线对之间总共有 5 个星号。所以我们返回 5 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母，竖线&nbsp;<code>'|'</code>&nbsp;和星号&nbsp;<code>'*'</code>&nbsp;。</li>\n\t<li><code>s</code>&nbsp;包含 <strong>偶数</strong>&nbsp;个竖线&nbsp;<code>'|'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2316.统计无向图中无法互相到达点对数",
        "hardRate": "MEDIUM",
        "passRate": "39.08%",
        "problemsUrl": "https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，表示一张<strong>&nbsp;无向图</strong>&nbsp;中有 <code>n</code>&nbsp;个节点，编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条&nbsp;<strong>无向</strong>&nbsp;边。</p>\n\n<p>请你返回 <strong>无法互相到达</strong>&nbsp;的不同 <strong>点对数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/05/tc-3.png\" style=\"width: 267px; height: 169px;\"></p>\n\n<pre><b>输入：</b>n = 3, edges = [[0,1],[0,2],[1,2]]\n<b>输出：</b>0\n<b>解释：</b>所有点都能互相到达，意味着没有点对无法互相到达，所以我们返回 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/05/tc-2.png\" style=\"width: 295px; height: 269px;\"></p>\n\n<pre><b>输入：</b>n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]\n<b>输出：</b>14\n<b>解释：</b>总共有 14 个点对互相无法到达：\n[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]]\n所以我们返回 14 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>不会有重复边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2317.操作后的最大异或和",
        "hardRate": "MEDIUM",
        "passRate": "85.16%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-xor-after-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-xor-after-operations/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。一次操作中，选择 <strong>任意</strong>&nbsp;非负整数&nbsp;<code>x</code>&nbsp;和一个下标&nbsp;<code>i</code>&nbsp;，<strong>更新</strong>&nbsp;<code>nums[i]</code>&nbsp;为&nbsp;<code>nums[i] AND (nums[i] XOR x)</code>&nbsp;。</p>\n\n<p>注意，<code>AND</code>&nbsp;是逐位与运算，<code>XOR</code>&nbsp;是逐位异或运算。</p>\n\n<p>请你执行 <strong>任意次</strong>&nbsp;更新操作，并返回&nbsp;<code>nums</code>&nbsp;中所有元素&nbsp;<strong>最大</strong>&nbsp;逐位异或和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,2,4,6]\n<b>输出：</b>7\n<b>解释：</b>选择 x = 4 和 i = 3 进行操作，num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2 。\n现在，nums = [3, 2, 4, 2] 且所有元素逐位异或得到 3 XOR 2 XOR 4 XOR 2 = 7 。\n可知 7 是能得到的最大逐位异或和。\n注意，其他操作可能也能得到逐位异或和 7 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,9,2]\n<b>输出：</b>11\n<b>解释：</b>执行 0 次操作。\n所有元素的逐位异或和为 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11 。\n可知 11 是能得到的最大逐位异或和。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2318.不同骰子序列的数目",
        "hardRate": "HARD",
        "passRate": "57.18%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-distinct-roll-sequences/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-distinct-roll-sequences/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;。你需要掷一个 6 面的骰子&nbsp;<code>n</code>&nbsp;次。请你在满足以下要求的前提下，求出 <strong>不同</strong>&nbsp;骰子序列的数目：</p>\n\n<ol>\n\t<li>序列中任意 <strong>相邻</strong>&nbsp;数字的 <strong>最大公约数</strong>&nbsp;为 <code>1</code>&nbsp;。</li>\n\t<li>序列中 <strong>相等</strong>&nbsp;的值之间，至少有 <code>2</code>&nbsp;个其他值的数字。正式地，如果第&nbsp;<code>i</code>&nbsp;次掷骰子的值 <strong>等于</strong>&nbsp;第&nbsp;<code>j</code>&nbsp;次的值，那么&nbsp;<code>abs(i - j) &gt; 2</code>&nbsp;。</li>\n</ol>\n\n<p>请你返回不同序列的 <strong>总数目</strong>&nbsp;。由于答案可能很大，请你将答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>如果两个序列中至少有一个元素不同，那么它们被视为不同的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4\n<b>输出：</b>184\n<b>解释：</b>一些可行的序列为 (1, 2, 3, 4) ，(6, 1, 2, 3) ，(1, 2, 3, 1) 等等。\n一些不可行的序列为 (1, 2, 1, 3) ，(1, 2, 3, 6) 。\n(1, 2, 1, 3) 是不可行的，因为第一个和第三个骰子值相等且 abs(1 - 3) = 2 （下标从 1 开始表示）。\n(1, 2, 3, 6) i是不可行的，因为 3 和 6 的最大公约数是 3 。\n总共有 184 个不同的可行序列，所以我们返回 184 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 2\n<b>输出：</b>22\n<b>解释：</b>一些可行的序列为 (1, 2) ，(2, 1) ，(3, 2) 。\n一些不可行的序列为 (3, 6) ，(2, 4) ，因为最大公约数不为 1 。\n总共有 22 个不同的可行序列，所以我们返回 22 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2319.判断矩阵是否是一个 X 矩阵",
        "hardRate": "EASY",
        "passRate": "76.23%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-matrix-is-x-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-matrix-is-x-matrix/solution",
        "problemsDesc": "<p>如果一个正方形矩阵满足下述 <strong>全部</strong> 条件，则称之为一个 <strong>X 矩阵</strong> ：</p>\n\n<ol>\n\t<li>矩阵对角线上的所有元素都 <strong>不是 0</strong></li>\n\t<li>矩阵中所有其他元素都是 <strong>0</strong></li>\n</ol>\n\n<p>给你一个大小为 <code>n x n</code> 的二维整数数组 <code>grid</code> ，表示一个正方形矩阵。如果<em> </em><code>grid</code><em> </em>是一个 <strong>X 矩阵 </strong>，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/03/ex1.jpg\" style=\"width: 311px; height: 320px;\">\n<pre><strong>输入：</strong>grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]\n<strong>输出：</strong>true\n<strong>解释：</strong>矩阵如上图所示。\nX 矩阵应该满足：绿色元素（对角线上）都不是 0 ，红色元素都是 0 。\n因此，grid 是一个 X 矩阵。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/03/ex2.jpg\" style=\"width: 238px; height: 246px;\">\n<pre><strong>输入：</strong>grid = [[5,7,0],[0,3,1],[0,5,0]]\n<strong>输出：</strong>false\n<strong>解释：</strong>矩阵如上图所示。\nX 矩阵应该满足：绿色元素（对角线上）都不是 0 ，红色元素都是 0 。\n因此，grid 不是一个 X 矩阵。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>3 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2320.统计放置房子的方式数",
        "hardRate": "MEDIUM",
        "passRate": "40.45%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-ways-to-place-houses/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-ways-to-place-houses/solution",
        "problemsDesc": "<p>一条街道上共有 <code>n * 2</code> 个 <strong>地块</strong> ，街道的两侧各有 <code>n</code> 个地块。每一边的地块都按从 <code>1</code> 到 <code>n</code> 编号。每个地块上都可以放置一所房子。</p>\n\n<p>现要求街道同一侧不能存在两所房子相邻的情况，请你计算并返回放置房屋的方式数目。由于答案可能很大，需要对 <code>10<sup>9</sup> + 7</code> 取余后再返回。</p>\n\n<p>注意，如果一所房子放置在这条街某一侧上的第 <code>i</code> 个地块，不影响在另一侧的第 <code>i</code> 个地块放置房子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>\n可能的放置方式：\n1. 所有地块都不放置房子。\n2. 一所房子放在街道的某一侧。\n3. 一所房子放在街道的另一侧。\n4. 放置两所房子，街道两侧各放置一所。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/12/arrangements.png\" style=\"width: 500px; height: 500px;\">\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>9\n<strong>解释：</strong>如上图所示，共有 9 种可能的放置方式。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2321.拼接数组的最大分数",
        "hardRate": "HARD",
        "passRate": "51.35%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-of-spliced-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-of-spliced-array/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，长度都是 <code>n</code> 。</p>\n\n<p>你可以选择两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>0 &lt;= left &lt;= right &lt; n</code> ，接着 <strong>交换</strong> 两个子数组 <code>nums1[left...right]</code> 和 <code>nums2[left...right]</code> 。</p>\n\n<ul>\n\t<li>例如，设 <code>nums1 = [1,2,3,4,5]</code> 和 <code>nums2 = [11,12,13,14,15]</code> ，整数选择 <code>left = 1</code> 和 <code>right = 2</code>，那么 <code>nums1</code> 会变为 <code>[1,<strong><em>12</em>,<em>13</em></strong>,4,5]</code> 而 <code>nums2</code> 会变为 <code>[11,<em><strong>2,3</strong></em>,14,15]</code> 。</li>\n</ul>\n\n<p>你可以选择执行上述操作 <strong>一次</strong> 或不执行任何操作。</p>\n\n<p>数组的 <strong>分数</strong> 取 <code>sum(nums1)</code> 和 <code>sum(nums2)</code> 中的最大值，其中 <code>sum(arr)</code> 是数组 <code>arr</code> 中所有元素之和。</p>\n\n<p>返回 <strong>可能的最大分数</strong> 。</p>\n\n<p><strong>子数组 </strong>是数组中连续的一个元素序列。<code>arr[left...right]</code> 表示子数组包含 <code>nums</code> 中下标 <code>left</code> 和 <code>right</code> 之间的元素<strong>（含</strong> 下标 <code>left</code> 和 <code>right</code> 对应元素<strong>）</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [60,60,60], nums2 = [10,90,10]\n<strong>输出：</strong>210\n<strong>解释：</strong>选择 left = 1 和 right = 1 ，得到 nums1 = [60,<em><strong>90</strong></em>,60] 和 nums2 = [10,<em><strong>60</strong></em>,10] 。\n分数为 max(sum(nums1), sum(nums2)) = max(210, 80) = 210 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [20,40,20,70,30], nums2 = [50,20,50,40,20]\n<strong>输出：</strong>220\n<strong>解释：</strong>选择 left = 3 和 right = 4 ，得到 nums1 = [20,40,20,<em><strong>40,20</strong></em>] 和 nums2 = [50,20,50,<em><strong>70,30</strong></em>] 。\n分数为 max(sum(nums1), sum(nums2)) = max(140, 220) = 220 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [7,11,13], nums2 = [1,1,1]\n<strong>输出：</strong>31\n<strong>解释：</strong>选择不交换任何子数组。\n分数为 max(sum(nums1), sum(nums2)) = max(31, 3) = 31 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2322.从树中删除边的最小分数",
        "hardRate": "HARD",
        "passRate": "58.93%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/solution",
        "problemsDesc": "<p>存在一棵无向连通树，树中有编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个节点， 以及 <code>n - 1</code> 条边。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，长度为 <code>n</code> ，其中 <code>nums[i]</code> 表示第 <code>i</code> 个节点的值。另给你一个二维整数数组 <code>edges</code> ，长度为 <code>n - 1</code> ，其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示树中存在一条位于节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间的边。</p>\n\n<p>删除树中两条 <strong>不同</strong> 的边以形成三个连通组件。对于一种删除边方案，定义如下步骤以计算其分数：</p>\n\n<ol>\n\t<li>分别获取三个组件 <strong>每个</strong> 组件中所有节点值的异或值。</li>\n\t<li><strong>最大</strong> 异或值和 <strong>最小</strong> 异或值的 <strong>差值</strong> 就是这一种删除边方案的分数。</li>\n</ol>\n\n<ul>\n\t<li>例如，三个组件的节点值分别是：<code>[4,5,7]</code>、<code>[1,9]</code> 和 <code>[3,3,3]</code> 。三个异或值分别是 <code>4 ^ 5 ^ 7 = <em><strong>6</strong></em></code>、<code>1 ^ 9 = <em><strong>8</strong></em></code> 和 <code>3 ^ 3 ^ 3 = <em><strong>3</strong></em></code> 。最大异或值是 <code>8</code> ，最小异或值是 <code>3</code> ，分数是 <code>8 - 3 = 5</code> 。</li>\n</ul>\n\n<p>返回在给定树上执行任意删除边方案可能的 <strong>最小</strong> 分数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/03/ex1drawio.png\" style=\"width: 193px; height: 190px;\">\n<pre><strong>输入：</strong>nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]]\n<strong>输出：</strong>9\n<strong>解释：</strong>上图展示了一种删除边方案。\n- 第 1 个组件的节点是 [1,3,4] ，值是 [5,4,11] 。异或值是 5 ^ 4 ^ 11 = 10 。\n- 第 2 个组件的节点是 [0] ，值是 [1] 。异或值是 1 = 1 。\n- 第 3 个组件的节点是 [2] ，值是 [5] 。异或值是 5 = 5 。\n分数是最大异或值和最小异或值的差值，10 - 1 = 9 。\n可以证明不存在分数比 9 小的删除边方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/03/ex2drawio.png\" style=\"width: 287px; height: 150px;\">\n<pre><strong>输入：</strong>nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]]\n<strong>输出：</strong>0\n<strong>解释：</strong>上图展示了一种删除边方案。\n- 第 1 个组件的节点是 [3,4] ，值是 [4,4] 。异或值是 4 ^ 4 = 0 。\n- 第 2 个组件的节点是 [1,0] ，值是 [5,5] 。异或值是 5 ^ 5 = 0 。\n- 第 3 个组件的节点是 [2,5] ，值是 [2,2] 。异或值是 2 ^ 2 = 0 。\n分数是最大异或值和最小异或值的差值，0 - 0 = 0 。\n无法获得比 0 更小的分数 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>edges</code> 表示一棵有效的树</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2323.完成所有工作的最短时间 II",
        "hardRate": "MEDIUM",
        "passRate": "70.78%",
        "problemsUrl": "https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2324.产品销售分析 IV",
        "hardRate": "MEDIUM",
        "passRate": "70.98%",
        "problemsUrl": "https://leetcode.cn/problems/product-sales-analysis-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/product-sales-analysis-iv/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2325.解密消息",
        "hardRate": "EASY",
        "passRate": "85.69%",
        "problemsUrl": "https://leetcode.cn/problems/decode-the-message/",
        "solutionsUrl": "https://leetcode.cn/problems/decode-the-message/solution",
        "problemsDesc": "<p>给你字符串 <code>key</code> 和 <code>message</code> ，分别表示一个加密密钥和一段加密消息。解密 <code>message</code> 的步骤如下：</p>\n\n<ol>\n\t<li>使用 <code>key</code> 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 <strong>顺序</strong> 。</li>\n\t<li>将替换表与普通英文字母表对齐，形成对照表。</li>\n\t<li>按照对照表 <strong>替换</strong> <code>message</code> 中的每个字母。</li>\n\t<li>空格 <code>' '</code> 保持不变。</li>\n</ol>\n\n<ul>\n\t<li>例如，<code>key = \"<em><strong>hap</strong></em>p<em><strong>y</strong></em> <em><strong>bo</strong></em>y\"</code>（实际的加密密钥会包含字母表中每个字母 <strong>至少一次</strong>），据此，可以得到部分对照表（<code>'h' -&gt; 'a'</code>、<code>'a' -&gt; 'b'</code>、<code>'p' -&gt; 'c'</code>、<code>'y' -&gt; 'd'</code>、<code>'b' -&gt; 'e'</code>、<code>'o' -&gt; 'f'</code>）。</li>\n</ul>\n\n<p>返回解密后的消息。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/08/ex1new4.jpg\" style=\"width: 752px; height: 150px;\" /></p>\n\n<pre>\n<strong>输入：</strong>key = \"the quick brown fox jumps over the lazy dog\", message = \"vkbs bs t suepuv\"\n<strong>输出：</strong>\"this is a secret\"\n<strong>解释：</strong>对照表如上图所示。\n提取 \"<em><strong>the</strong></em> <em><strong>quick</strong></em> <em><strong>brown</strong></em> <em><strong>f</strong></em>o<em><strong>x</strong></em> <em><strong>j</strong></em>u<em><strong>mps</strong></em> o<em><strong>v</strong></em>er the <em><strong>lazy</strong></em> <em><strong>d</strong></em>o<em><strong>g</strong></em>\" 中每个字母的首次出现可以得到替换表。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/08/ex2new.jpg\" style=\"width: 754px; height: 150px;\" /></p>\n\n<pre>\n<strong>输入：</strong>key = \"eljuxhpwnyrdgtqkviszcfmabo\", message = \"zwx hnfx lqantp mnoeius ycgk vcnjrdb\"\n<strong>输出：</strong>\"the five boxing wizards jump quickly\"\n<strong>解释：</strong>对照表如上图所示。\n提取 \"<em><strong>eljuxhpwnyrdgtqkviszcfmabo</strong></em>\" 中每个字母的首次出现可以得到替换表。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>26 &lt;= key.length &lt;= 2000</code></li>\n\t<li><code>key</code> 由小写英文字母及 <code>' '</code> 组成</li>\n\t<li><code>key</code> 包含英文字母表中每个字符（<code>'a'</code> 到 <code>'z'</code>）<strong>至少一次</strong></li>\n\t<li><code>1 &lt;= message.length &lt;= 2000</code></li>\n\t<li><code>message</code> 由小写英文字母和 <code>' '</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2326.螺旋矩阵 IV",
        "hardRate": "MEDIUM",
        "passRate": "66.77%",
        "problemsUrl": "https://leetcode.cn/problems/spiral-matrix-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/spiral-matrix-iv/solution",
        "problemsDesc": "<p>给你两个整数：<code>m</code> 和 <code>n</code> ，表示矩阵的维数。</p>\n\n<p>另给你一个整数链表的头节点 <code>head</code> 。</p>\n\n<p>请你生成一个大小为 <code>m x n</code> 的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵 <strong>左上角</strong> 开始、<strong>顺时针 </strong>按 <strong>螺旋</strong> 顺序填充。如果还存在剩余的空格，则用 <code>-1</code> 填充。</p>\n\n<p>返回生成的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/09/ex1new.jpg\" style=\"width: 240px; height: 150px;\">\n<pre><strong>输入：</strong>m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]\n<strong>输出：</strong>[[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]\n<strong>解释：</strong>上图展示了链表中的整数在矩阵中是如何排布的。\n注意，矩阵中剩下的空格用 -1 填充。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/11/ex2.jpg\" style=\"width: 221px; height: 60px;\">\n<pre><strong>输入：</strong>m = 1, n = 4, head = [0,1,2]\n<strong>输出：</strong>[[0,1,2,-1]]\n<strong>解释：</strong>上图展示了链表中的整数在矩阵中是如何从左到右排布的。 \n注意，矩阵中剩下的空格用 -1 填充。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li>链表中节点数目在范围 <code>[1, m * n]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2327.知道秘密的人数",
        "hardRate": "MEDIUM",
        "passRate": "45.78%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-people-aware-of-a-secret/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-people-aware-of-a-secret/solution",
        "problemsDesc": "<p>在第 <code>1</code>&nbsp;天，有一个人发现了一个秘密。</p>\n\n<p>给你一个整数&nbsp;<code>delay</code>&nbsp;，表示每个人会在发现秘密后的 <code>delay</code>&nbsp;天之后，<strong>每天</strong>&nbsp;给一个新的人&nbsp;<strong>分享</strong>&nbsp;秘密。同时给你一个整数&nbsp;<code>forget</code>&nbsp;，表示每个人在发现秘密&nbsp;<code>forget</code>&nbsp;天之后会&nbsp;<strong>忘记</strong>&nbsp;这个秘密。一个人&nbsp;<strong>不能</strong>&nbsp;在忘记秘密那一天及之后的日子里分享秘密。</p>\n\n<p>给你一个整数&nbsp;<code>n</code>&nbsp;，请你返回在第 <code>n</code>&nbsp;天结束时，知道秘密的人数。由于答案可能会很大，请你将结果对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 6, delay = 2, forget = 4\n<b>输出：</b>5\n<strong>解释：</strong>\n第 1 天：假设第一个人叫 A 。（一个人知道秘密）\n第 2 天：A 是唯一一个知道秘密的人。（一个人知道秘密）\n第 3 天：A 把秘密分享给 B 。（两个人知道秘密）\n第 4 天：A 把秘密分享给一个新的人 C 。（三个人知道秘密）\n第 5 天：A 忘记了秘密，B 把秘密分享给一个新的人 D 。（三个人知道秘密）\n第 6 天：B 把秘密分享给 E，C 把秘密分享给 F 。（五个人知道秘密）\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 4, delay = 1, forget = 3\n<b>输出：</b>6\n<strong>解释：</strong>\n第 1 天：第一个知道秘密的人为 A 。（一个人知道秘密）\n第 2 天：A 把秘密分享给 B 。（两个人知道秘密）\n第 3 天：A 和 B 把秘密分享给 2 个新的人 C 和 D 。（四个人知道秘密）\n第 4 天：A 忘记了秘密，B、C、D 分别分享给 3 个新的人。（六个人知道秘密）\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= delay &lt; forget &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2328.网格图中递增路径的数目",
        "hardRate": "HARD",
        "passRate": "50.94%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的整数网格图&nbsp;<code>grid</code>&nbsp;，你可以从一个格子移动到&nbsp;<code>4</code>&nbsp;个方向相邻的任意一个格子。</p>\n\n<p>请你返回在网格图中从 <strong>任意</strong>&nbsp;格子出发，达到 <strong>任意</strong>&nbsp;格子，且路径中的数字是 <strong>严格递增</strong>&nbsp;的路径数目。由于答案可能会很大，请将结果对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>如果两条路径中访问过的格子不是完全相同的，那么它们视为两条不同的路径。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/10/griddrawio-4.png\" style=\"width: 181px; height: 121px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,1],[3,4]]\n<b>输出：</b>8\n<b>解释：</b>严格递增路径包括：\n- 长度为 1 的路径：[1]，[1]，[3]，[4] 。\n- 长度为 2 的路径：[1 -&gt; 3]，[1 -&gt; 4]，[3 -&gt; 4] 。\n- 长度为 3 的路径：[1 -&gt; 3 -&gt; 4] 。\n路径数目为 4 + 3 + 1 = 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>grid = [[1],[2]]\n<b>输出：</b>3\n<b>解释：</b>严格递增路径包括：\n- 长度为 1 的路径：[1]，[2] 。\n- 长度为 2 的路径：[1 -&gt; 2] 。\n路径数目为 2 + 1 = 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2329.产品销售分析Ⅴ",
        "hardRate": "EASY",
        "passRate": "72.38%",
        "problemsUrl": "https://leetcode.cn/problems/product-sales-analysis-v/",
        "solutionsUrl": "https://leetcode.cn/problems/product-sales-analysis-v/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2330.有效的回文 IV",
        "hardRate": "MEDIUM",
        "passRate": "81.55%",
        "problemsUrl": "https://leetcode.cn/problems/valid-palindrome-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-palindrome-iv/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2331.计算布尔二叉树的值",
        "hardRate": "EASY",
        "passRate": "84.01%",
        "problemsUrl": "https://leetcode.cn/problems/evaluate-boolean-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/evaluate-boolean-binary-tree/solution",
        "problemsDesc": "<p>给你一棵 <strong>完整二叉树</strong>&nbsp;的根，这棵树有以下特征：</p>\n\n<ul>\n\t<li><strong>叶子节点</strong>&nbsp;要么值为&nbsp;<code>0</code>&nbsp;要么值为&nbsp;<code>1</code>&nbsp;，其中&nbsp;<code>0</code> 表示&nbsp;<code>False</code>&nbsp;，<code>1</code> 表示&nbsp;<code>True</code>&nbsp;。</li>\n\t<li><strong>非叶子节点 </strong>要么值为 <code>2</code>&nbsp;要么值为 <code>3</code>&nbsp;，其中&nbsp;<code>2</code>&nbsp;表示逻辑或&nbsp;<code>OR</code> ，<code>3</code>&nbsp;表示逻辑与&nbsp;<code>AND</code>&nbsp;。</li>\n</ul>\n\n<p><strong>计算</strong>&nbsp;一个节点的值方式如下：</p>\n\n<ul>\n\t<li>如果节点是个叶子节点，那么节点的 <strong>值</strong>&nbsp;为它本身，即&nbsp;<code>True</code>&nbsp;或者&nbsp;<code>False</code>&nbsp;。</li>\n\t<li>否则，<strong>计算</strong>&nbsp;两个孩子的节点值，然后将该节点的运算符对两个孩子值进行 <strong>运算</strong>&nbsp;。</li>\n</ul>\n\n<p>返回根节点<em>&nbsp;</em><code>root</code>&nbsp;的布尔运算值。</p>\n\n<p><strong>完整二叉树</strong>&nbsp;是每个节点有 <code>0</code>&nbsp;个或者 <code>2</code>&nbsp;个孩子的二叉树。</p>\n\n<p><strong>叶子节点</strong>&nbsp;是没有孩子的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/16/example1drawio1.png\" style=\"width: 700px; height: 252px;\"></p>\n\n<pre><b>输入：</b>root = [2,1,3,null,null,0,1]\n<b>输出：</b>true\n<b>解释：</b>上图展示了计算过程。\nAND 与运算节点的值为 False AND True = False 。\nOR 运算节点的值为 True OR False = True 。\n根节点的值为 True ，所以我们返回 true 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>root = [0]\n<b>输出：</b>false\n<b>解释：</b>根节点是叶子节点，且值为 false，所以我们返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在&nbsp;<code>[1, 1000]</code>&nbsp;之间。</li>\n\t<li><code>0 &lt;= Node.val &lt;= 3</code></li>\n\t<li>每个节点的孩子数为&nbsp;<code>0</code> 或&nbsp;<code>2</code>&nbsp;。</li>\n\t<li>叶子节点的值为&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code>&nbsp;。</li>\n\t<li>非叶子节点的值为&nbsp;<code>2</code>&nbsp;或&nbsp;<code>3</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2332.坐上公交的最晚时间",
        "hardRate": "MEDIUM",
        "passRate": "24.37%",
        "problemsUrl": "https://leetcode.cn/problems/the-latest-time-to-catch-a-bus/",
        "solutionsUrl": "https://leetcode.cn/problems/the-latest-time-to-catch-a-bus/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>buses</code>&nbsp;，其中&nbsp;<code>buses[i]</code>&nbsp;表示第 <code>i</code>&nbsp;辆公交车的出发时间。同时给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>m</code>&nbsp;的整数数组&nbsp;<code>passengers</code>&nbsp;，其中&nbsp;<code>passengers[j]</code>&nbsp;表示第&nbsp;<code>j</code>&nbsp;位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。</p>\n\n<p>给你一个整数&nbsp;<code>capacity</code>&nbsp;，表示每辆公交车&nbsp;<strong>最多</strong>&nbsp;能容纳的乘客数目。</p>\n\n<p>每位乘客都会搭乘下一辆有座位的公交车。如果你在 <code>y</code>&nbsp;时刻到达，公交在&nbsp;<code>x</code>&nbsp;时刻出发，满足&nbsp;<code>y &lt;= x</code>&nbsp;&nbsp;且公交没有满，那么你可以搭乘这一辆公交。<strong>最早</strong>&nbsp;到达的乘客优先上车。</p>\n\n<p>返回你可以搭乘公交车的最晚到达公交站时间。你 <strong>不能</strong>&nbsp;跟别的乘客同时刻到达。</p>\n\n<p><strong>注意：</strong>数组&nbsp;<code>buses</code> 和&nbsp;<code>passengers</code>&nbsp;不一定是有序的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>buses = [10,20], passengers = [2,17,18,19], capacity = 2\n<b>输出：</b>16\n<strong>解释：</strong>\n第 1 辆公交车载着第 1 位乘客。\n第 2 辆公交车载着你和第 2 位乘客。\n注意你不能跟其他乘客同一时间到达，所以你必须在第二位乘客之前到达。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2\n<b>输出：</b>20\n<b>解释：</b>\n第 1 辆公交车载着第 4 位乘客。\n第 2 辆公交车载着第 6 位和第 2 位乘客。\n第 3 辆公交车载着第 1 位乘客和你。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == buses.length</code></li>\n\t<li><code>m == passengers.length</code></li>\n\t<li><code>1 &lt;= n, m, capacity &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= buses[i], passengers[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>buses</code>&nbsp;中的元素 <strong>互不相同&nbsp;</strong>。</li>\n\t<li><code>passengers</code>&nbsp;中的元素 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2333.最小差值平方和",
        "hardRate": "MEDIUM",
        "passRate": "26.70%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-sum-of-squared-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-sum-of-squared-difference/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，长度为&nbsp;<code>n</code>&nbsp;。</p>\n\n<p>数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;的 <strong>差值平方和</strong>&nbsp;定义为所有满足&nbsp;<code>0 &lt;= i &lt; n</code>&nbsp;的&nbsp;<code>(nums1[i] - nums2[i])<sup>2</sup></code>&nbsp;之和。</p>\n\n<p>同时给你两个正整数&nbsp;<code>k1</code> 和&nbsp;<code>k2</code>&nbsp;。你可以将&nbsp;<code>nums1</code>&nbsp;中的任意元素&nbsp;<code>+1</code> 或者&nbsp;<code>-1</code>&nbsp;至多&nbsp;<code>k1</code>&nbsp;次。类似的，你可以将&nbsp;<code>nums2</code>&nbsp;中的任意元素&nbsp;<code>+1</code> 或者&nbsp;<code>-1</code>&nbsp;至多&nbsp;<code>k2</code>&nbsp;次。</p>\n\n<p>请你返回修改数组<em>&nbsp;</em><code>nums1</code><em>&nbsp;</em>至多<em>&nbsp;</em><code>k1</code>&nbsp;次且修改数组<em>&nbsp;</em><code>nums2</code>&nbsp;至多 <code>k2</code><em>&nbsp;</em>次后的最小&nbsp;<strong>差值平方和</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong>你可以将数组中的元素变成&nbsp;<strong>负</strong>&nbsp;整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0\n<b>输出：</b>579\n<b>解释：</b>nums1 和 nums2 中的元素不能修改，因为 k1 = 0 和 k2 = 0 。\n差值平方和为：(1 - 2)<sup>2 </sup>+ (2 - 10)<sup>2 </sup>+ (3 - 20)<sup>2 </sup>+ (4 - 19)<sup>2</sup>&nbsp;= 579 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1\n<b>输出：</b>43\n<b>解释：</b>一种得到最小差值平方和的方式为：\n- 将 nums1[0] 增加一次。\n- 将 nums2[2] 增加一次。\n最小差值平方和为：\n(2 - 5)<sup>2 </sup>+ (4 - 8)<sup>2 </sup>+ (10 - 7)<sup>2 </sup>+ (12 - 9)<sup>2</sup>&nbsp;= 43 。\n注意，也有其他方式可以得到最小差值平方和，但没有得到比 43 更小答案的方案。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= k1, k2 &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2334.元素值大于变化阈值的子数组",
        "hardRate": "HARD",
        "passRate": "47.37%",
        "problemsUrl": "https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/",
        "solutionsUrl": "https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>threshold</code>&nbsp;。</p>\n\n<p>找到长度为 <code>k</code>&nbsp;的&nbsp;<code>nums</code>&nbsp;子数组，满足数组中&nbsp;<strong>每个</strong>&nbsp;元素都 <strong>大于</strong>&nbsp;<code>threshold / k</code>&nbsp;。</p>\n\n<p>请你返回满足要求的 <strong>任意</strong>&nbsp;子数组的 <strong>大小</strong>&nbsp;。如果没有这样的子数组，返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p><strong>子数组</strong> 是数组中一段连续非空的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,4,3,1], threshold = 6\n<b>输出：</b>3\n<b>解释：</b>子数组 [3,4,3] 大小为 3 ，每个元素都大于 6 / 3 = 2 。\n注意这是唯一合法的子数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [6,5,6,5,8], threshold = 7\n<b>输出：</b>1\n<b>解释：</b>子数组 [8] 大小为 1 ，且 8 &gt; 7 / 1 = 7 。所以返回 1 。\n注意子数组 [6,5] 大小为 2 ，每个元素都大于 7 / 2 = 3.5 。\n类似的，子数组 [6,5,6] ，[6,5,6,5] ，[6,5,6,5,8] 都是符合条件的子数组。\n所以返回 2, 3, 4 和 5 都可以。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], threshold &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2335.装满杯子需要的最短总时长",
        "hardRate": "EASY",
        "passRate": "64.53%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-amount-of-time-to-fill-cups/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-amount-of-time-to-fill-cups/solution",
        "problemsDesc": "<p>现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 <code>2</code> 杯 <strong>不同</strong> 类型的水或者 <code>1</code> 杯任意类型的水。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>3</code> 的整数数组 <code>amount</code> ，其中 <code>amount[0]</code>、<code>amount[1]</code> 和 <code>amount[2]</code> 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 <strong>最少</strong> 秒数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>amount = [1,4,2]\n<strong>输出：</strong>4\n<strong>解释：</strong>下面给出一种方案：\n第 1 秒：装满一杯冷水和一杯温水。\n第 2 秒：装满一杯温水和一杯热水。\n第 3 秒：装满一杯温水和一杯热水。\n第 4 秒：装满一杯温水。\n可以证明最少需要 4 秒才能装满所有杯子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>amount = [5,4,4]\n<strong>输出：</strong>7\n<strong>解释：</strong>下面给出一种方案：\n第 1 秒：装满一杯冷水和一杯热水。\n第 2 秒：装满一杯冷水和一杯温水。\n第 3 秒：装满一杯冷水和一杯温水。\n第 4 秒：装满一杯温水和一杯热水。\n第 5 秒：装满一杯冷水和一杯热水。\n第 6 秒：装满一杯冷水和一杯温水。\n第 7 秒：装满一杯热水。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>amount = [5,0,0]\n<strong>输出：</strong>5\n<strong>解释：</strong>每秒装满一杯冷水。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>amount.length == 3</code></li>\n\t<li><code>0 &lt;= amount[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2336.无限集中的最小数字",
        "hardRate": "MEDIUM",
        "passRate": "69.83%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-number-in-infinite-set/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-number-in-infinite-set/solution",
        "problemsDesc": "<p>现有一个包含所有正整数的集合 <code>[1, 2, 3, 4, 5, ...]</code> 。</p>\n\n<p>实现 <code>SmallestInfiniteSet</code> 类：</p>\n\n<ul>\n\t<li><code>SmallestInfiniteSet()</code> 初始化 <strong>SmallestInfiniteSet</strong> 对象以包含 <strong>所有</strong> 正整数。</li>\n\t<li><code>int popSmallest()</code> <strong>移除</strong> 并返回该无限集中的最小整数。</li>\n\t<li><code>void addBack(int num)</code> 如果正整数 <code>num</code> <strong>不</strong> 存在于无限集中，则将一个 <code>num</code> <strong>添加</strong> 到该无限集中。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入</strong>\n[\"SmallestInfiniteSet\", \"addBack\", \"popSmallest\", \"popSmallest\", \"popSmallest\", \"addBack\", \"popSmallest\", \"popSmallest\", \"popSmallest\"]\n[[], [2], [], [], [], [1], [], [], []]\n<strong>输出</strong>\n[null, null, 1, 2, 3, null, 1, 4, 5]\n\n<strong>解释</strong>\nSmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();\nsmallestInfiniteSet.addBack(2);    // 2 已经在集合中，所以不做任何变更。\nsmallestInfiniteSet.popSmallest(); // 返回 1 ，因为 1 是最小的整数，并将其从集合中移除。\nsmallestInfiniteSet.popSmallest(); // 返回 2 ，并将其从集合中移除。\nsmallestInfiniteSet.popSmallest(); // 返回 3 ，并将其从集合中移除。\nsmallestInfiniteSet.addBack(1);    // 将 1 添加到该集合中。\nsmallestInfiniteSet.popSmallest(); // 返回 1 ，因为 1 在上一步中被添加到集合中，\n                                   // 且 1 是最小的整数，并将其从集合中移除。\nsmallestInfiniteSet.popSmallest(); // 返回 4 ，并将其从集合中移除。\nsmallestInfiniteSet.popSmallest(); // 返回 5 ，并将其从集合中移除。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 1000</code></li>\n\t<li>最多调用 <code>popSmallest</code> 和 <code>addBack</code> 方法 <strong>共计</strong> <code>1000</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2337.移动片段得到字符串",
        "hardRate": "MEDIUM",
        "passRate": "39.29%",
        "problemsUrl": "https://leetcode.cn/problems/move-pieces-to-obtain-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/move-pieces-to-obtain-a-string/solution",
        "problemsDesc": "<p>给你两个字符串 <code>start</code> 和 <code>target</code> ，长度均为 <code>n</code> 。每个字符串 <strong>仅</strong> 由字符 <code>'L'</code>、<code>'R'</code> 和 <code>'_'</code> 组成，其中：</p>\n\n<ul>\n\t<li>字符 <code>'L'</code> 和 <code>'R'</code> 表示片段，其中片段 <code>'L'</code> 只有在其左侧直接存在一个 <strong>空位</strong> 时才能向 <strong>左</strong> 移动，而片段 <code>'R'</code> 只有在其右侧直接存在一个 <strong>空位</strong> 时才能向 <strong>右</strong> 移动。</li>\n\t<li>字符 <code>'_'</code> 表示可以被 <strong>任意</strong> <code>'L'</code> 或 <code>'R'</code> 片段占据的空位。</li>\n</ul>\n\n<p>如果在移动字符串 <code>start</code> 中的片段任意次之后可以得到字符串 <code>target</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>start = \"_L__R__R_\", target = \"L______RR\"\n<strong>输出：</strong>true\n<strong>解释：</strong>可以从字符串 start 获得 target ，需要进行下面的移动：\n- 将第一个片段向左移动一步，字符串现在变为 \"<strong>L</strong>___R__R_\" 。\n- 将最后一个片段向右移动一步，字符串现在变为 \"L___R___<strong>R</strong>\" 。\n- 将第二个片段向右移动散步，字符串现在变为 \"L______<strong>R</strong>R\" 。\n可以从字符串 start 得到 target ，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>start = \"R_L_\", target = \"__LR\"\n<strong>输出：</strong>false\n<strong>解释：</strong>字符串 start 中的 'R' 片段可以向右移动一步得到 \"_<strong>R</strong>L_\" 。\n但是，在这一步之后，不存在可以移动的片段，所以无法从字符串 start 得到 target 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>start = \"_R\", target = \"R_\"\n<strong>输出：</strong>false\n<strong>解释：</strong>字符串 start 中的片段只能向右移动，所以无法从字符串 start 得到 target 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == start.length == target.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>start</code> 和 <code>target</code> 由字符 <code>'L'</code>、<code>'R'</code> 和 <code>'_'</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2338.统计理想数组的数目",
        "hardRate": "HARD",
        "passRate": "30.71%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-ideal-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-ideal-arrays/solution",
        "problemsDesc": "<p>给你两个整数 <code>n</code> 和 <code>maxValue</code> ，用于描述一个 <strong>理想数组</strong> 。</p>\n\n<p>对于下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>arr</code> ，如果满足以下条件，则认为该数组是一个 <strong>理想数组</strong> ：</p>\n\n<ul>\n\t<li>每个 <code>arr[i]</code> 都是从 <code>1</code> 到 <code>maxValue</code> 范围内的一个值，其中 <code>0 &lt;= i &lt; n</code> 。</li>\n\t<li>每个 <code>arr[i]</code> 都可以被 <code>arr[i - 1]</code> 整除，其中 <code>0 &lt; i &lt; n</code> 。</li>\n</ul>\n\n<p>返回长度为 <code>n</code> 的 <strong>不同</strong> 理想数组的数目。由于答案可能很大，返回对 <code>10<sup>9</sup> + 7</code> 取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, maxValue = 5\n<strong>输出：</strong>10\n<strong>解释：</strong>存在以下理想数组：\n- 以 1 开头的数组（5 个）：[1,1]、[1,2]、[1,3]、[1,4]、[1,5]\n- 以 2 开头的数组（2 个）：[2,2]、[2,4]\n- 以 3 开头的数组（1 个）：[3,3]\n- 以 4 开头的数组（1 个）：[4,4]\n- 以 5 开头的数组（1 个）：[5,5]\n共计 5 + 2 + 1 + 1 + 1 = 10 个不同理想数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, maxValue = 3\n<strong>输出：</strong>11\n<strong>解释：</strong>存在以下理想数组：\n- 以 1 开头的数组（9 个）：\n   - 不含其他不同值（1 个）：[1,1,1,1,1] \n   - 含一个不同值 2（4 个）：[1,1,1,1,2], [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2]\n   - 含一个不同值 3（4 个）：[1,1,1,1,3], [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3]\n- 以 2 开头的数组（1 个）：[2,2,2,2,2]\n- 以 3 开头的数组（1 个）：[3,3,3,3,3]\n共计 9 + 1 + 1 = 11 个不同理想数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= maxValue &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2339.联赛的所有比赛",
        "hardRate": "EASY",
        "passRate": "75.60%",
        "problemsUrl": "https://leetcode.cn/problems/all-the-matches-of-the-league/",
        "solutionsUrl": "https://leetcode.cn/problems/all-the-matches-of-the-league/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2340.生成有效数组的最少交换次数",
        "hardRate": "MEDIUM",
        "passRate": "76.60%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-to-make-a-valid-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-to-make-a-valid-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2341.数组能形成多少数对",
        "hardRate": "EASY",
        "passRate": "81.16%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-pairs-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-pairs-in-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。在一步操作中，你可以执行以下步骤：</p>\n\n<ul>\n\t<li>从 <code>nums</code> 选出 <strong>两个</strong> <strong>相等的</strong> 整数</li>\n\t<li>从 <code>nums</code> 中移除这两个整数，形成一个 <strong>数对</strong></li>\n</ul>\n\n<p>请你在 <code>nums</code> 上多次执行此操作直到无法继续执行。</p>\n\n<p>返回一个下标从 <strong>0</strong> 开始、长度为 <code>2</code> 的整数数组 <code>answer</code> 作为答案，其中<em> </em><code>answer[0]</code><em> </em>是形成的数对数目，<code>answer[1]</code> 是对 <code>nums</code> 尽可能执行上述操作后剩下的整数数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,2,1,3,2,2]\n<strong>输出：</strong>[3,1]\n<strong>解释：</strong>\nnums[0] 和 nums[3] 形成一个数对，并从 nums 中移除，nums = [3,2,3,2,2] 。\nnums[0] 和 nums[2] 形成一个数对，并从 nums 中移除，nums = [2,2,2] 。\nnums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [2] 。\n无法形成更多数对。总共形成 3 个数对，nums 中剩下 1 个数字。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1]\n<strong>输出：</strong>[1,0]\n<strong>解释：</strong>nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [] 。\n无法形成更多数对。总共形成 1 个数对，nums 中剩下 0 个数字。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0]\n<strong>输出：</strong>[0,1]\n<strong>解释：</strong>无法形成数对，nums 中剩下 1 个数字。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2342.数位和相等数对的最大和",
        "hardRate": "MEDIUM",
        "passRate": "53.59%",
        "problemsUrl": "https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组中的元素都是 <strong>正</strong> 整数。请你选出两个下标 <code>i</code> 和 <code>j</code>（<code>i != j</code>），且 <code>nums[i]</code> 的数位和 与&nbsp; <code>nums[j]</code> 的数位和相等。</p>\n\n<p>请你找出所有满足条件的下标 <code>i</code> 和 <code>j</code> ，找出并返回<em> </em><code>nums[i] + nums[j]</code><em> </em>可以得到的 <strong>最大值</strong> <em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [18,43,36,13,7]\n<strong>输出：</strong>54\n<strong>解释：</strong>满足条件的数对 (i, j) 为：\n- (0, 2) ，两个数字的数位和都是 9 ，相加得到 18 + 36 = 54 。\n- (1, 4) ，两个数字的数位和都是 7 ，相加得到 43 + 7 = 50 。\n所以可以获得的最大和是 54 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,12,19,14]\n<strong>输出：</strong>-1\n<strong>解释：</strong>不存在满足条件的数对，返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2343.裁剪数字后查询第 K 小的数字",
        "hardRate": "MEDIUM",
        "passRate": "41.33%",
        "problemsUrl": "https://leetcode.cn/problems/query-kth-smallest-trimmed-number/",
        "solutionsUrl": "https://leetcode.cn/problems/query-kth-smallest-trimmed-number/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串数组&nbsp;<code>nums</code>&nbsp;，其中每个字符串 <strong>长度相等</strong>&nbsp;且只包含数字。</p>\n\n<p>再给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [k<sub>i</sub>, trim<sub>i</sub>]</code>&nbsp;。对于每个&nbsp;<code>queries[i]</code>&nbsp;，你需要：</p>\n\n<ul>\n\t<li>将&nbsp;<code>nums</code>&nbsp;中每个数字 <strong>裁剪</strong>&nbsp;到剩下 <strong>最右边</strong>&nbsp;<code>trim<sub>i</sub></code>&nbsp;个数位。</li>\n\t<li>在裁剪过后的数字中，找到 <code>nums</code>&nbsp;中第&nbsp;<code>k<sub>i</sub></code>&nbsp;小数字对应的 <strong>下标</strong>&nbsp;。如果两个裁剪后数字一样大，那么下标 <strong>更小</strong>&nbsp;的数字视为更小的数字。</li>\n\t<li>将 <code>nums</code>&nbsp;中每个数字恢复到原本字符串。</li>\n</ul>\n\n<p>请你返回一个长度与 <code><span style=\"\">queries</span></code>&nbsp;相等的数组<em>&nbsp;</em><code>answer</code>，其中<em>&nbsp;</em><code>answer[i]</code>是第<em>&nbsp;</em><code>i</code><em>&nbsp;</em>次查询的结果。</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>裁剪到剩下最右边 <code>x</code>&nbsp;个数位的意思是不断删除最左边的数位，直到剩下 <code>x</code>&nbsp;个数位。</li>\n\t<li><code>nums</code>&nbsp;中的字符串可能会有前导 0 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [\"102\",\"473\",\"251\",\"814\"], queries = [[1,1],[2,3],[4,2],[1,2]]\n<b>输出：</b>[2,2,1,0]\n<strong>解释：</strong>\n1. 裁剪到只剩 1 个数位后，nums = [\"2\",\"3\",\"1\",\"4\"] 。最小的数字是 1 ，下标为 2 。\n2. 裁剪到剩 3 个数位后，nums 没有变化。第 2 小的数字是 251 ，下标为 2 。\n3. 裁剪到剩 2 个数位后，nums = [\"02\",\"73\",\"51\",\"14\"] 。第 4 小的数字是 73 ，下标为 1 。\n4. 裁剪到剩 2 个数位后，最小数字是 2 ，下标为 0 。\n   注意，裁剪后数字 \"02\" 值为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [\"24\",\"37\",\"96\",\"04\"], queries = [[2,1],[2,2]]\n<b>输出：</b>[3,0]\n<strong>解释：</strong>\n1. 裁剪到剩 1 个数位，nums = [\"4\",\"7\",\"6\",\"4\"] 。第 2 小的数字是 4 ，下标为 3 。\n   有两个 4 ，下标为 0 的 4 视为小于下标为 3 的 4 。\n2. 裁剪到剩 2 个数位，nums 不变。第二小的数字是 24 ，下标为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 100</code></li>\n\t<li><code>nums[i]</code> 只包含数字。</li>\n\t<li>所有&nbsp;<code>nums[i].length</code>&nbsp;的长度 <b>相同</b>&nbsp;。</li>\n\t<li><code>1 &lt;= queries.length &lt;= 100</code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 &lt;= k<sub>i</sub> &lt;= nums.length</code></li>\n\t<li><code>1 &lt;= trim<sub>i</sub> &lt;= nums[0].length</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能使用 <strong>基数排序算法</strong> 解决此问题吗？这种解法的复杂度又是多少？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2344.使数组可以被整除的最少删除次数",
        "hardRate": "HARD",
        "passRate": "53.27%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-array-divisible/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-array-divisible/solution",
        "problemsDesc": "<p>给你两个正整数数组&nbsp;<code>nums</code> 和&nbsp;<code>numsDivide</code>&nbsp;。你可以从&nbsp;<code>nums</code>&nbsp;中删除任意数目的元素。</p>\n\n<p>请你返回使 <code>nums</code>&nbsp;中 <strong>最小</strong>&nbsp;元素可以整除 <code>numsDivide</code>&nbsp;中所有元素的 <strong>最少</strong>&nbsp;删除次数。如果无法得到这样的元素，返回 <code>-1</code>&nbsp;。</p>\n\n<p>如果&nbsp;<code>y % x == 0</code>&nbsp;，那么我们说整数&nbsp;<code>x</code>&nbsp;整除&nbsp;<code>y</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15]\n<b>输出：</b>2\n<b>解释：</b>\n[2,3,2,4,3] 中最小元素是 2 ，它无法整除 numsDivide 中所有元素。\n我们从 nums 中删除 2 个大小为 2 的元素，得到 nums = [3,4,3] 。\n[3,4,3] 中最小元素为 3 ，它可以整除 numsDivide 中所有元素。\n可以证明 2 是最少删除次数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [4,3,6], numsDivide = [8,2,6,10]\n<b>输出：</b>-1\n<b>解释：</b>\n我们想 nums 中的最小元素可以整除 numsDivide 中的所有元素。\n没有任何办法可以达到这一目的。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, numsDivide.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], numsDivide[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2345.寻找可见山的数量",
        "hardRate": "MEDIUM",
        "passRate": "48.16%",
        "problemsUrl": "https://leetcode.cn/problems/finding-the-number-of-visible-mountains/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-the-number-of-visible-mountains/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2346.以百分比计算排名",
        "hardRate": "MEDIUM",
        "passRate": "37.49%",
        "problemsUrl": "https://leetcode.cn/problems/compute-the-rank-as-a-percentage/",
        "solutionsUrl": "https://leetcode.cn/problems/compute-the-rank-as-a-percentage/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2347.最好的扑克手牌",
        "hardRate": "EASY",
        "passRate": "59.35%",
        "problemsUrl": "https://leetcode.cn/problems/best-poker-hand/",
        "solutionsUrl": "https://leetcode.cn/problems/best-poker-hand/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>ranks</code>&nbsp;和一个字符数组&nbsp;<code>suit</code>&nbsp;。你有&nbsp;<code>5</code>&nbsp;张扑克牌，第&nbsp;<code>i</code>&nbsp;张牌大小为&nbsp;<code>ranks[i]</code>&nbsp;，花色为&nbsp;<code>suits[i]</code>&nbsp;。</p>\n\n<p>下述是从好到坏你可能持有的 <strong>手牌类型&nbsp;</strong>：</p>\n\n<ol>\n\t<li><code>\"Flush\"</code>：同花，五张相同花色的扑克牌。</li>\n\t<li><code>\"Three of a Kind\"</code>：三条，有 3 张大小相同的扑克牌。</li>\n\t<li><code>\"Pair\"</code>：对子，两张大小一样的扑克牌。</li>\n\t<li><code>\"High Card\"</code>：高牌，五张大小互不相同的扑克牌。</li>\n</ol>\n\n<p>请你返回一个字符串，表示给定的 5 张牌中，你能组成的 <strong>最好手牌类型</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong>返回的字符串&nbsp;<strong>大小写</strong>&nbsp;需与题目描述相同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>ranks = [13,2,3,1,9], suits = [\"a\",\"a\",\"a\",\"a\",\"a\"]\n<b>输出：</b>\"Flush\"\n<b>解释：</b>5 张扑克牌的花色相同，所以返回 \"Flush\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>ranks = [4,4,2,4,4], suits = [\"d\",\"a\",\"a\",\"b\",\"c\"]\n<b>输出：</b>\"Three of a Kind\"\n<b>解释：</b>第一、二和四张牌组成三张相同大小的扑克牌，所以得到 \"Three of a Kind\" 。\n注意我们也可以得到 \"Pair\" ，但是 \"Three of a Kind\" 是更好的手牌类型。\n有其他的 3 张牌也可以组成 \"Three of a Kind\" 手牌类型。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>ranks = [10,10,2,12,9], suits = [\"a\",\"b\",\"c\",\"a\",\"d\"]\n<b>输出：</b>\"Pair\"\n<b>解释：</b>第一和第二张牌大小相同，所以得到 \"Pair\" 。\n我们无法得到 \"Flush\" 或者 \"Three of a Kind\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>ranks.length == suits.length == 5</code></li>\n\t<li><code>1 &lt;= ranks[i] &lt;= 13</code></li>\n\t<li><code>'a' &lt;= suits[i] &lt;= 'd'</code></li>\n\t<li>任意两张扑克牌不会同时有相同的大小和花色。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2348.全 0 子数组的数目",
        "hardRate": "MEDIUM",
        "passRate": "56.33%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-zero-filled-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-zero-filled-subarrays/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;，返回全部为&nbsp;<code>0</code>&nbsp;的&nbsp;<strong>子数组</strong>&nbsp;数目。</p>\n\n<p><strong>子数组</strong>&nbsp;是一个数组中一段连续非空元素组成的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,0,0,2,0,0,4]\n<b>输出：</b>6\n<b>解释：</b>\n子数组 [0] 出现了 4 次。\n子数组 [0,0] 出现了 2 次。\n不存在长度大于 2 的全 0 子数组，所以我们返回 6 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [0,0,0,2,0,0]\n<b>输出：</b>9\n<strong>解释：\n</strong>子数组 [0] 出现了 5 次。\n子数组 [0,0] 出现了 3 次。\n子数组 [0,0,0] 出现了 1 次。\n不存在长度大于 3 的全 0 子数组，所以我们返回 9 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [2,10,2019]\n<b>输出：</b>0\n<b>解释：</b>没有全 0 子数组，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2349.设计数字容器系统",
        "hardRate": "MEDIUM",
        "passRate": "37.30%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-number-container-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-number-container-system/solution",
        "problemsDesc": "<p>设计一个数字容器系统，可以实现以下功能：</p>\n\n<ul>\n\t<li>在系统中给定下标处&nbsp;<strong>插入</strong>&nbsp;或者 <strong>替换</strong>&nbsp;一个数字。</li>\n\t<li><strong>返回</strong>&nbsp;系统中给定数字的最小下标。</li>\n</ul>\n\n<p>请你实现一个&nbsp;<code>NumberContainers</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>NumberContainers()</code>&nbsp;初始化数字容器系统。</li>\n\t<li><code>void change(int index, int number)</code> 在下标&nbsp;<code>index</code>&nbsp;处填入&nbsp;<code>number</code>&nbsp;。如果该下标&nbsp;<code>index</code>&nbsp;处已经有数字了，那么用 <code>number</code>&nbsp;替换该数字。</li>\n\t<li><code>int find(int number)</code>&nbsp;返回给定数字&nbsp;<code>number</code>&nbsp;在系统中的最小下标。如果系统中没有&nbsp;<code>number</code>&nbsp;，那么返回&nbsp;<code>-1</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"NumberContainers\", \"find\", \"change\", \"change\", \"change\", \"change\", \"find\", \"change\", \"find\"]\n[[], [10], [2, 10], [1, 10], [3, 10], [5, 10], [10], [1, 20], [10]]\n<strong>输出：</strong>\n[null, -1, null, null, null, null, 1, null, 2]\n\n<strong>解释：</strong>\nNumberContainers nc = new NumberContainers();\nnc.find(10); // 没有数字 10 ，所以返回 -1 。\nnc.change(2, 10); // 容器中下标为 2 处填入数字 10 。\nnc.change(1, 10); // 容器中下标为 1 处填入数字 10 。\nnc.change(3, 10); // 容器中下标为 3 处填入数字 10 。\nnc.change(5, 10); // 容器中下标为 5 处填入数字 10 。\nnc.find(10); // 数字 10 所在的下标为 1 ，2 ，3 和 5 。因为最小下标为 1 ，所以返回 1 。\nnc.change(1, 20); // 容器中下标为 1 处填入数字 20 。注意，下标 1 处之前为 10 ，现在被替换为 20 。\nnc.find(10); // 数字 10 所在下标为 2 ，3 和 5 。最小下标为 2 ，所以返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= index, number &lt;= 10<sup>9</sup></code></li>\n\t<li>调用&nbsp;<code>change</code> 和&nbsp;<code>find</code>&nbsp;的&nbsp;<strong>总次数</strong>&nbsp;不超过&nbsp;<code>10<sup>5</sup></code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2350.不可能得到的最短骰子序列",
        "hardRate": "HARD",
        "passRate": "64.80%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-impossible-sequence-of-rolls/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-impossible-sequence-of-rolls/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>rolls</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。你扔一个&nbsp;<code>k</code>&nbsp;面的骰子 <code>n</code>&nbsp;次，骰子的每个面分别是&nbsp;<code>1</code>&nbsp;到&nbsp;<code>k</code>&nbsp;，其中第&nbsp;<code>i</code>&nbsp;次扔得到的数字是&nbsp;<code>rolls[i]</code>&nbsp;。</p>\n\n<p>请你返回 <strong>无法</strong>&nbsp;从 <code>rolls</code>&nbsp;中得到的 <strong>最短</strong>&nbsp;骰子子序列的长度。</p>\n\n<p>扔一个 <code>k</code>&nbsp;面的骰子 <code>len</code>&nbsp;次得到的是一个长度为 <code>len</code>&nbsp;的 <strong>骰子子序列</strong>&nbsp;。</p>\n\n<p><strong>注意</strong>&nbsp;，子序列只需要保持在原数组中的顺序，不需要连续。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>rolls = [4,2,1,2,3,3,2,4,1], k = 4\n<b>输出：</b>3\n<b>解释：</b>所有长度为 1 的骰子子序列 [1] ，[2] ，[3] ，[4] 都可以从原数组中得到。\n所有长度为 2 的骰子子序列 [1, 1] ，[1, 2] ，... ，[4, 4] 都可以从原数组中得到。\n子序列 [1, 4, 2] 无法从原数组中得到，所以我们返回 3 。\n还有别的子序列也无法从原数组中得到。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>rolls = [1,1,2,2], k = 2\n<b>输出：</b>2\n<b>解释：</b>所有长度为 1 的子序列 [1] ，[2] 都可以从原数组中得到。\n子序列 [2, 1] 无法从原数组中得到，所以我们返回 2 。\n还有别的子序列也无法从原数组中得到，但 [2, 1] 是最短的子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>rolls = [1,1,3,2,2,2,3,3], k = 4\n<b>输出：</b>1\n<b>解释：</b>子序列 [4] 无法从原数组中得到，所以我们返回 1 。\n还有别的子序列也无法从原数组中得到，但 [4] 是最短的子序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == rolls.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= rolls[i] &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2351.第一个出现两次的字母",
        "hardRate": "EASY",
        "passRate": "84.80%",
        "problemsUrl": "https://leetcode.cn/problems/first-letter-to-appear-twice/",
        "solutionsUrl": "https://leetcode.cn/problems/first-letter-to-appear-twice/solution",
        "problemsDesc": "<p>给你一个由小写英文字母组成的字符串 <code>s</code> ，请你找出并返回第一个出现 <strong>两次</strong> 的字母。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>如果 <code>a</code> 的 <strong>第二次</strong> 出现比 <code>b</code> 的 <strong>第二次</strong> 出现在字符串中的位置更靠前，则认为字母 <code>a</code> 在字母 <code>b</code> 之前出现两次。</li>\n\t<li><code>s</code> 包含至少一个出现两次的字母。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abccbaacz\"\n<strong>输出：</strong>\"c\"\n<strong>解释：</strong>\n字母 'a' 在下标 0 、5 和 6 处出现。\n字母 'b' 在下标 1 和 4 处出现。\n字母 'c' 在下标 2 、3 和 7 处出现。\n字母 'z' 在下标 8 处出现。\n字母 'c' 是第一个出现两次的字母，因为在所有字母中，'c' 第二次出现的下标是最小的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abcdd\"\n<strong>输出：</strong>\"d\"\n<strong>解释：</strong>\n只有字母 'd' 出现两次，所以返回 'd' 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n\t<li><code>s</code> 包含至少一个重复字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2352.相等行列对",
        "hardRate": "MEDIUM",
        "passRate": "74.03%",
        "problemsUrl": "https://leetcode.cn/problems/equal-row-and-column-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/equal-row-and-column-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> ，返回满足 <code>R<sub>i</sub></code><em> </em>行和<em> </em><code>C<sub>j</sub></code><em> </em>列相等的行列对<em> </em><code>(R<sub>i</sub>, C<sub>j</sub>)</code><em> </em>的数目<em>。</em></p>\n\n<p>如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/01/ex1.jpg\" style=\"width: 150px; height: 153px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[3,2,1],[1,7,6],[2,7,7]]\n<strong>输出：</strong>1\n<strong>解释：</strong>存在一对相等行列对：\n- (第 2 行，第 1 列)：[2,7,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/01/ex2.jpg\" style=\"width: 200px; height: 209px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]\n<strong>输出：</strong>3\n<strong>解释：</strong>存在三对相等行列对：\n- (第 0 行，第 0 列)：[3,1,2,2]\n- (第 2 行, 第 2 列)：[2,4,2,2]\n- (第 3 行, 第 2 列)：[2,4,2,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2353.设计食物评分系统",
        "hardRate": "MEDIUM",
        "passRate": "30.69%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-food-rating-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-food-rating-system/solution",
        "problemsDesc": "<p>设计一个支持下述操作的食物评分系统：</p>\n\n<ul>\n\t<li><strong>修改</strong> 系统中列出的某种食物的评分。</li>\n\t<li>返回系统中某一类烹饪方式下评分最高的食物。</li>\n</ul>\n\n<p>实现 <code>FoodRatings</code> 类：</p>\n\n<ul>\n\t<li><code>FoodRatings(String[] foods, String[] cuisines, int[] ratings)</code> 初始化系统。食物由 <code>foods</code>、<code>cuisines</code> 和 <code>ratings</code> 描述，长度均为 <code>n</code> 。\n\n\t<ul>\n\t\t<li><code>foods[i]</code> 是第 <code>i</code> 种食物的名字。</li>\n\t\t<li><code>cuisines[i]</code> 是第 <code>i</code> 种食物的烹饪方式。</li>\n\t\t<li><code>ratings[i]</code> 是第 <code>i</code> 种食物的最初评分。</li>\n\t</ul>\n\t</li>\n\t<li><code>void changeRating(String food, int newRating)</code> 修改名字为 <code>food</code> 的食物的评分。</li>\n\t<li><code>String highestRated(String cuisine)</code> 返回指定烹饪方式 <code>cuisine</code> 下评分最高的食物的名字。如果存在并列，返回 <strong>字典序较小</strong> 的名字。</li>\n</ul>\n\n<p>注意，字符串 <code>x</code> 的字典序比字符串 <code>y</code> 更小的前提是：<code>x</code> 在字典中出现的位置在 <code>y</code> 之前，也就是说，要么 <code>x</code> 是 <code>y</code> 的前缀，或者在满足&nbsp;<code>x[i] != y[i]</code> 的第一个位置 <code>i</code> 处，<code>x[i]</code> 在字母表中出现的位置在 <code>y[i]</code> 之前。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入</strong>\n[\"FoodRatings\", \"highestRated\", \"highestRated\", \"changeRating\", \"highestRated\", \"changeRating\", \"highestRated\"]\n[[[\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]], [\"korean\"], [\"japanese\"], [\"sushi\", 16], [\"japanese\"], [\"ramen\", 16], [\"japanese\"]]\n<strong>输出</strong>\n[null, \"kimchi\", \"ramen\", null, \"sushi\", null, \"ramen\"]\n\n<strong>解释</strong>\nFoodRatings foodRatings = new FoodRatings([\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]);\nfoodRatings.highestRated(\"korean\"); // 返回 \"kimchi\"\n                                    // \"kimchi\" 是分数最高的韩式料理，评分为 9 。\nfoodRatings.highestRated(\"japanese\"); // 返回 \"ramen\"\n                                      // \"ramen\" 是分数最高的日式料理，评分为 14 。\nfoodRatings.changeRating(\"sushi\", 16); // \"sushi\" 现在评分变更为 16 。\nfoodRatings.highestRated(\"japanese\"); // 返回 \"sushi\"\n                                      // \"sushi\" 是分数最高的日式料理，评分为 16 。\nfoodRatings.changeRating(\"ramen\", 16); // \"ramen\" 现在评分变更为 16 。\nfoodRatings.highestRated(\"japanese\"); // 返回 \"ramen\"\n                                      // \"sushi\" 和 \"ramen\" 的评分都是 16 。\n                                      // 但是，\"ramen\" 的字典序比 \"sushi\" 更小。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>n == foods.length == cuisines.length == ratings.length</code></li>\n\t<li><code>1 &lt;= foods[i].length, cuisines[i].length &lt;= 10</code></li>\n\t<li><code>foods[i]</code>、<code>cuisines[i]</code> 由小写英文字母组成</li>\n\t<li><code>1 &lt;= ratings[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>foods</code> 中的所有字符串 <strong>互不相同</strong></li>\n\t<li>在对&nbsp;<code>changeRating</code> 的所有调用中，<code>food</code> 是系统中食物的名字。</li>\n\t<li>在对&nbsp;<code>highestRated</code> 的所有调用中，<code>cuisine</code> 是系统中 <strong>至少一种</strong> 食物的烹饪方式。</li>\n\t<li>最多调用 <code>changeRating</code> 和 <code>highestRated</code> <strong>总计</strong> <code>2 * 10<sup>4</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2354.优质数对的数目",
        "hardRate": "HARD",
        "passRate": "44.57%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-excellent-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-excellent-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的正整数数组 <code>nums</code> 和一个正整数 <code>k</code> 。</p>\n\n<p>如果满足下述条件，则数对 <code>(num1, num2)</code> 是 <strong>优质数对</strong> ：</p>\n\n<ul>\n\t<li><code>num1</code> 和 <code>num2</code> <strong>都</strong> 在数组 <code>nums</code> 中存在。</li>\n\t<li><code>num1 OR num2</code> 和 <code>num1 AND num2</code> 的二进制表示中值为 <strong>1</strong> 的位数之和大于等于 <code>k</code> ，其中 <code>OR</code> 是按位 <strong>或</strong> 操作，而 <code>AND</code> 是按位 <strong>与</strong> 操作。</li>\n</ul>\n\n<p>返回 <strong>不同</strong> 优质数对的数目。</p>\n\n<p>如果&nbsp;<code>a != c</code> 或者 <code>b != d</code> ，则认为 <code>(a, b)</code> 和 <code>(c, d)</code> 是不同的两个数对。例如，<code>(1, 2)</code> 和 <code>(2, 1)</code> 不同。</p>\n\n<p><strong>注意：</strong>如果 <code>num1</code> 在数组中至少出现 <strong>一次</strong> ，则满足 <code>num1 == num2</code> 的数对 <code>(num1, num2)</code> 也可以是优质数对。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,1], k = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>有如下几个优质数对：\n- (3, 3)：(3 AND 3) 和 (3 OR 3) 的二进制表示都等于 (11) 。值为 1 的位数和等于 2 + 2 = 4 ，大于等于 k = 3 。\n- (2, 3) 和 (3, 2)： (2 AND 3) 的二进制表示等于 (10) ，(2 OR 3) 的二进制表示等于 (11) 。值为 1 的位数和等于 1 + 2 = 3 。\n- (1, 3) 和 (3, 1)： (1 AND 3) 的二进制表示等于 (01) ，(1 OR 3) 的二进制表示等于 (11) 。值为 1 的位数和等于 1 + 2 = 3 。\n所以优质数对的数目是 5 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,1,1], k = 10\n<strong>输出：</strong>0\n<strong>解释：</strong>该数组中不存在优质数对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 60</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2355.你能拿走的最大图书数量",
        "hardRate": "HARD",
        "passRate": "58.92%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-books-you-can-take/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-books-you-can-take/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2356.每位教师所教授的科目种类的数量",
        "hardRate": "EASY",
        "passRate": "80.94%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-unique-subjects-taught-by-each-teacher/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-unique-subjects-taught-by-each-teacher/solution",
        "problemsDesc": "<p>表: <code>Teacher</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| teacher_id  | int  |\n| subject_id  | int  |\n| dept_id     | int  |\n+-------------+------+\n(subject_id, dept_id) 是该表的主键。\n该表中的每一行都表示带有 teacher_id 的教师在系 dept_id 中教授科目 subject_id。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一个 SQL 来查询每位老师在大学里教授的科目种类的数量。</p>\n\n<p data-group=\"1-1\">以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式示例如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nTeacher 表:\n+------------+------------+---------+\n| teacher_id | subject_id | dept_id |\n+------------+------------+---------+\n| 1          | 2          | 3       |\n| 1          | 2          | 4       |\n| 1          | 3          | 3       |\n| 2          | 1          | 1       |\n| 2          | 2          | 1       |\n| 2          | 3          | 1       |\n| 2          | 4          | 1       |\n+------------+------------+---------+\n<strong>输出:</strong>  \n+------------+-----+\n| teacher_id | cnt |\n+------------+-----+\n| 1          | 2   |\n| 2          | 4   |\n+------------+-----+\n<strong>解释:</strong> \n教师 1:\n  - 他在 3、4 系教科目 2。\n  - 他在 3 系教科目 3。\n教师 2:\n  - 他在 1 系教科目 1。\n  - 他在 1 系教科目 2。\n  - 他在 1 系教科目 3。\n  - 他在 1 系教科目 4。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2357.使数组中所有元素都等于零",
        "hardRate": "EASY",
        "passRate": "75.87%",
        "problemsUrl": "https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/",
        "solutionsUrl": "https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/solution",
        "problemsDesc": "<p>给你一个非负整数数组 <code>nums</code> 。在一步操作中，你必须：</p>\n\n<ul>\n\t<li>选出一个正整数 <code>x</code> ，<code>x</code> 需要小于或等于 <code>nums</code> 中 <strong>最小</strong> 的 <strong>非零</strong> 元素。</li>\n\t<li><code>nums</code> 中的每个正整数都减去 <code>x</code>。</li>\n</ul>\n\n<p>返回使 <code>nums</code> 中所有元素都等于<em> </em><code>0</code> 需要的 <strong>最少</strong> 操作数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,0,3,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n第一步操作：选出 x = 1 ，之后 nums = [0,4,0,2,4] 。\n第二步操作：选出 x = 2 ，之后 nums = [0,2,0,0,2] 。\n第三步操作：选出 x = 2 ，之后 nums = [0,0,0,0,0] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 中的每个元素都已经是 0 ，所以不需要执行任何操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2358.分组的最大数量",
        "hardRate": "MEDIUM",
        "passRate": "64.27%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>grades</code> ，表示大学中一些学生的成绩。你打算将 <strong>所有</strong> 学生分为一些 <strong>有序</strong> 的非空分组，其中分组间的顺序满足以下全部条件：</p>\n\n<ul>\n\t<li>第 <code>i</code> 个分组中的学生总成绩 <strong>小于</strong> 第 <code>(i + 1)</code> 个分组中的学生总成绩，对所有组均成立（除了最后一组）。</li>\n\t<li>第 <code>i</code> 个分组中的学生总数 <strong>小于</strong> 第 <code>(i + 1)</code> 个分组中的学生总数，对所有组均成立（除了最后一组）。</li>\n</ul>\n\n<p>返回可以形成的 <strong>最大</strong> 组数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>grades = [10,6,12,7,3,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>下面是形成 3 个分组的一种可行方法：\n- 第 1 个分组的学生成绩为 grades = [12] ，总成绩：12 ，学生数：1\n- 第 2 个分组的学生成绩为 grades = [6,7] ，总成绩：6 + 7 = 13 ，学生数：2\n- 第 3 个分组的学生成绩为 grades = [10,3,5] ，总成绩：10 + 3 + 5 = 18 ，学生数：3 \n可以证明无法形成超过 3 个分组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>grades = [8,8]\n<strong>输出：</strong>1\n<strong>解释：</strong>只能形成 1 个分组，因为如果要形成 2 个分组的话，会导致每个分组中的学生数目相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= grades.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grades[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2359.找到离给定两个节点最近的节点",
        "hardRate": "MEDIUM",
        "passRate": "30.25%",
        "problemsUrl": "https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的 <strong>有向图</strong>&nbsp;，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，每个节点 <strong>至多</strong>&nbsp;有一条出边。</p>\n\n<p>有向图用大小为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>edges</code>&nbsp;表示，表示节点&nbsp;<code>i</code>&nbsp;有一条有向边指向&nbsp;<code>edges[i]</code>&nbsp;。如果节点&nbsp;<code>i</code>&nbsp;没有出边，那么&nbsp;<code>edges[i] == -1</code>&nbsp;。</p>\n\n<p>同时给你两个节点&nbsp;<code>node1</code> 和&nbsp;<code>node2</code>&nbsp;。</p>\n\n<p>请你返回一个从 <code>node1</code>&nbsp;和 <code>node2</code>&nbsp;都能到达节点的编号，使节点 <code>node1</code>&nbsp;和节点 <code>node2</code>&nbsp;到这个节点的距离 <b>较大值最小化</b>。如果有多个答案，请返回 <strong>最小</strong>&nbsp;的节点编号。如果答案不存在，返回 <code>-1</code>&nbsp;。</p>\n\n<p>注意&nbsp;<code>edges</code>&nbsp;可能包含环。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-2.png\" style=\"width: 321px; height: 161px;\"></p>\n\n<pre><b>输入：</b>edges = [2,2,3,-1], node1 = 0, node2 = 1\n<b>输出：</b>2\n<b>解释：</b>从节点 0 到节点 2 的距离为 1 ，从节点 1 到节点 2 的距离为 1 。\n两个距离的较大值为 1 。我们无法得到一个比 1 更小的较大值，所以我们返回节点 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-4.png\" style=\"width: 195px; height: 161px;\"></p>\n\n<pre><b>输入：</b>edges = [1,2,-1], node1 = 0, node2 = 2\n<b>输出：</b>2\n<b>解释：</b>节点 0 到节点 2 的距离为 2 ，节点 2 到它自己的距离为 0 。\n两个距离的较大值为 2 。我们无法得到一个比 2 更小的较大值，所以我们返回节点 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-1 &lt;= edges[i] &lt; n</code></li>\n\t<li><code>edges[i] != i</code></li>\n\t<li><code>0 &lt;= node1, node2 &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2360.图中的最长环",
        "hardRate": "HARD",
        "passRate": "37.99%",
        "problemsUrl": "https://leetcode.cn/problems/longest-cycle-in-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-cycle-in-a-graph/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的 <b>有向图</b>&nbsp;，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，其中每个节点&nbsp;<strong>至多</strong>&nbsp;有一条出边。</p>\n\n<p>图用一个大小为 <code>n</code>&nbsp;下标从<strong>&nbsp;0</strong>&nbsp;开始的数组&nbsp;<code>edges</code>&nbsp;表示，节点 <code>i</code>&nbsp;到节点&nbsp;<code>edges[i]</code>&nbsp;之间有一条有向边。如果节点&nbsp;<code>i</code>&nbsp;没有出边，那么&nbsp;<code>edges[i] == -1</code>&nbsp;。</p>\n\n<p>请你返回图中的 <strong>最长</strong>&nbsp;环，如果没有任何环，请返回 <code>-1</code>&nbsp;。</p>\n\n<p>一个环指的是起点和终点是 <strong>同一个</strong>&nbsp;节点的路径。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/08/graph4drawio-5.png\" style=\"width: 335px; height: 191px;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [3,3,4,2,3]\n<b>输出去：</b>3\n<b>解释：</b>图中的最长环是：2 -&gt; 4 -&gt; 3 -&gt; 2 。\n这个环的长度为 3 ，所以返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-1.png\" style=\"width: 171px; height: 161px;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [2,-1,3,1]\n<b>输出：</b>-1\n<b>解释：</b>图中没有任何环。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-1 &lt;= edges[i] &lt; n</code></li>\n\t<li><code>edges[i] != i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2361.乘坐火车路线的最少费用",
        "hardRate": "HARD",
        "passRate": "77.78%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-costs-using-the-train-line/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-costs-using-the-train-line/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2362.生成发票",
        "hardRate": "HARD",
        "passRate": "72.93%",
        "problemsUrl": "https://leetcode.cn/problems/generate-the-invoice/",
        "solutionsUrl": "https://leetcode.cn/problems/generate-the-invoice/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2363.合并相似的物品",
        "hardRate": "EASY",
        "passRate": "78.20%",
        "problemsUrl": "https://leetcode.cn/problems/merge-similar-items/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-similar-items/solution",
        "problemsDesc": "<p>给你两个二维整数数组&nbsp;<code>items1</code> 和&nbsp;<code>items2</code>&nbsp;，表示两个物品集合。每个数组&nbsp;<code>items</code>&nbsp;有以下特质：</p>\n\n<ul>\n\t<li><code>items[i] = [value<sub>i</sub>, weight<sub>i</sub>]</code> 其中&nbsp;<code>value<sub>i</sub></code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;件物品的&nbsp;<strong>价值</strong>&nbsp;，<code>weight<sub>i</sub></code>&nbsp;表示第 <code>i</code>&nbsp;件物品的 <strong>重量</strong>&nbsp;。</li>\n\t<li><code>items</code>&nbsp;中每件物品的价值都是 <strong>唯一的</strong>&nbsp;。</li>\n</ul>\n\n<p>请你返回一个二维数组&nbsp;<code>ret</code>，其中&nbsp;<code>ret[i] = [value<sub>i</sub>, weight<sub>i</sub>]</code>，&nbsp;<code>weight<sub>i</sub></code>&nbsp;是所有价值为&nbsp;<code>value<sub>i</sub></code><sub>&nbsp;</sub>物品的&nbsp;<strong>重量之和</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong><code>ret</code>&nbsp;应该按价值 <strong>升序</strong>&nbsp;排序后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]\n<b>输出：</b>[[1,6],[3,9],[4,5]]\n<b>解释：</b>\nvalue = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 5 ，总重量为 1 + 5 = 6 。\nvalue = 3 的物品再 items1 中 weight = 8 ，在 items2 中 weight = 1 ，总重量为 8 + 1 = 9 。\nvalue = 4 的物品在 items1 中 weight = 5 ，总重量为 5 。\n所以，我们返回 [[1,6],[3,9],[4,5]] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]\n<b>输出：</b>[[1,4],[2,4],[3,4]]\n<b>解释：</b>\nvalue = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 3 ，总重量为 1 + 3 = 4 。\nvalue = 2 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 1 ，总重量为 3 + 1 = 4 。\nvalue = 3 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。\n所以，我们返回 [[1,4],[2,4],[3,4]] 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]\n<b>输出：</b>[[1,7],[2,4],[7,1]]\n<strong>解释：\n</strong>value = 1 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 4 ，总重量为 3 + 4 = 7 。\nvalue = 2 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。\nvalue = 7 的物品在 items2 中 weight = 1 ，总重量为 1 。\n所以，我们返回 [[1,7],[2,4],[7,1]] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= items1.length, items2.length &lt;= 1000</code></li>\n\t<li><code>items1[i].length == items2[i].length == 2</code></li>\n\t<li><code>1 &lt;= value<sub>i</sub>, weight<sub>i</sub> &lt;= 1000</code></li>\n\t<li><code>items1</code>&nbsp;中每个 <code>value<sub>i</sub></code>&nbsp;都是 <b>唯一的</b>&nbsp;。</li>\n\t<li><code>items2</code>&nbsp;中每个 <code>value<sub>i</sub></code>&nbsp;都是 <b>唯一的</b>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2364.统计坏数对的数目",
        "hardRate": "MEDIUM",
        "passRate": "42.22%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-bad-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-bad-pairs/solution",
        "problemsDesc": "<p>给你一个下标从<strong>&nbsp;0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。如果 <code>i &lt; j</code>&nbsp;且&nbsp;<code>j - i != nums[j] - nums[i]</code>&nbsp;，那么我们称&nbsp;<code>(i, j)</code>&nbsp;是一个 <strong>坏</strong><strong>数对</strong>&nbsp;。</p>\n\n<p>请你返回 <code>nums</code>&nbsp;中 <strong>坏数对</strong>&nbsp;的总数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [4,1,3,3]\n<b>输出：</b>5\n<b>解释：</b>数对 (0, 1) 是坏数对，因为 1 - 0 != 1 - 4 。\n数对 (0, 2) 是坏数对，因为 2 - 0 != 3 - 4, 2 != -1 。\n数对 (0, 3) 是坏数对，因为 3 - 0 != 3 - 4, 3 != -1 。\n数对 (1, 2) 是坏数对，因为 2 - 1 != 3 - 1, 1 != 2 。\n数对 (2, 3) 是坏数对，因为 3 - 2 != 3 - 3, 1 != 0 。\n总共有 5 个坏数对，所以我们返回 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>0\n<strong>解释：</strong>没有坏数对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2365.任务调度器 II",
        "hardRate": "MEDIUM",
        "passRate": "48.02%",
        "problemsUrl": "https://leetcode.cn/problems/task-scheduler-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/task-scheduler-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的正整数数组&nbsp;<code>tasks</code>&nbsp;，表示需要 <strong>按顺序</strong>&nbsp;完成的任务，其中&nbsp;<code>tasks[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;件任务的 <strong>类型</strong>&nbsp;。</p>\n\n<p>同时给你一个正整数&nbsp;<code>space</code>&nbsp;，表示一个任务完成&nbsp;<strong>后</strong>&nbsp;，另一个&nbsp;<strong>相同</strong>&nbsp;类型任务完成前需要间隔的&nbsp;<strong>最少</strong>&nbsp;天数。</p>\n\n<p>在所有任务完成前的每一天，你都必须进行以下两种操作中的一种：</p>\n\n<ul>\n\t<li>完成&nbsp;<code>tasks</code>&nbsp;中的下一个任务</li>\n\t<li>休息一天</li>\n</ul>\n\n<p>请你返回完成所有任务所需的 <strong>最少</strong>&nbsp;天数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tasks = [1,2,1,2,3,1], space = 3\n<b>输出：</b>9\n<strong>解释：</strong>\n9 天完成所有任务的一种方法是：\n第 1 天：完成任务 0 。\n第 2 天：完成任务 1 。\n第 3 天：休息。\n第 4 天：休息。\n第 5 天：完成任务 2 。\n第 6 天：完成任务 3 。\n第 7 天：休息。\n第 8 天：完成任务 4 。\n第 9 天：完成任务 5 。\n可以证明无法少于 9 天完成所有任务。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tasks = [5,8,8,5], space = 2\n<b>输出：</b>6\n<strong>解释：</strong>\n6 天完成所有任务的一种方法是：\n第 1 天：完成任务 0 。\n第 2 天：完成任务 1 。\n第 3 天：休息。\n第 4 天：休息。\n第 5 天：完成任务 2 。\n第 6 天：完成任务 3 。\n可以证明无法少于 6 天完成所有任务。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= tasks[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= space &lt;= tasks.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2366.将数组排序的最少替换次数",
        "hardRate": "HARD",
        "passRate": "42.70%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-replacements-to-sort-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-replacements-to-sort-the-array/solution",
        "problemsDesc": "<p>给你一个下表从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。每次操作中，你可以将数组中任何一个元素替换为&nbsp;<strong>任意两个</strong>&nbsp;和为该元素的数字。</p>\n\n<ul>\n\t<li>比方说，<code>nums = [5,6,7]</code>&nbsp;。一次操作中，我们可以将&nbsp;<code>nums[1]</code> 替换成&nbsp;<code>2</code> 和&nbsp;<code>4</code>&nbsp;，将&nbsp;<code>nums</code>&nbsp;转变成&nbsp;<code>[5,2,4,7]</code>&nbsp;。</li>\n</ul>\n\n<p>请你执行上述操作，将数组变成元素按 <strong>非递减</strong> 顺序排列的数组，并返回所需的最少操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,9,3]\n<b>输出：</b>2\n<b>解释：</b>以下是将数组变成非递减顺序的步骤：\n- [3,9,3] ，将9 变成 3 和 6 ，得到数组 [3,3,6,3] \n- [3,3,6,3] ，将 6 变成 3 和 3 ，得到数组 [3,3,3,3,3] \n总共需要 2 步将数组变成非递减有序，所以我们返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>0\n<b>解释：</b>数组已经是非递减顺序，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2367.算术三元组的数目",
        "hardRate": "EASY",
        "passRate": "83.38%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-arithmetic-triplets/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-arithmetic-triplets/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、<strong>严格递增</strong> 的整数数组 <code>nums</code> 和一个正整数 <code>diff</code> 。如果满足下述全部条件，则三元组 <code>(i, j, k)</code> 就是一个 <strong>算术三元组</strong> ：</p>\n\n<ul>\n\t<li><code>i &lt; j &lt; k</code> ，</li>\n\t<li><code>nums[j] - nums[i] == diff</code> 且</li>\n\t<li><code>nums[k] - nums[j] == diff</code></li>\n</ul>\n\n<p>返回不同 <strong>算术三元组</strong> 的数目<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,4,6,7,10], diff = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>\n(1, 2, 4) 是算术三元组：7 - 4 == 3 且 4 - 1 == 3 。\n(2, 4, 5) 是算术三元组：10 - 7 == 3 且 7 - 4 == 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,5,6,7,8,9], diff = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n(0, 2, 4) 是算术三元组：8 - 6 == 2 且 6 - 4 == 2 。\n(1, 3, 5) 是算术三元组：9 - 7 == 2 且 7 - 5 == 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 200</code></li>\n\t<li><code>1 &lt;= diff &lt;= 50</code></li>\n\t<li><code>nums</code> <strong>严格</strong> 递增</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2368.受限条件下可到达节点的数目",
        "hardRate": "MEDIUM",
        "passRate": "46.11%",
        "problemsUrl": "https://leetcode.cn/problems/reachable-nodes-with-restrictions/",
        "solutionsUrl": "https://leetcode.cn/problems/reachable-nodes-with-restrictions/solution",
        "problemsDesc": "<p>现有一棵由 <code>n</code> 个节点组成的无向树，节点编号从 <code>0</code> 到 <code>n - 1</code> ，共有 <code>n - 1</code> 条边。</p>\n\n<p>给你一个二维整数数组 <code>edges</code> ，长度为 <code>n - 1</code> ，其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示树中节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间存在一条边。另给你一个整数数组 <code>restricted</code> 表示 <strong>受限</strong> 节点。</p>\n\n<p>在不访问受限节点的前提下，返回你可以从节点<em> </em><code>0</code><em> </em>到达的 <strong>最多</strong> 节点数目<em>。</em></p>\n\n<p>注意，节点 <code>0</code> <strong>不</strong> 会标记为受限节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/15/ex1drawio.png\" style=\"width: 402px; height: 322px;\">\n<pre><strong>输入：</strong>n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>上图所示正是这棵树。\n在不访问受限节点的前提下，只有节点 [0,1,2,3] 可以从节点 0 到达。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/15/ex2drawio.png\" style=\"width: 412px; height: 312px;\">\n<pre><strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>上图所示正是这棵树。\n在不访问受限节点的前提下，只有节点 [0,5,6] 可以从节点 0 到达。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>edges</code> 表示一棵有效的树</li>\n\t<li><code>1 &lt;= restricted.length &lt; n</code></li>\n\t<li><code>1 &lt;= restricted[i] &lt; n</code></li>\n\t<li><code>restricted</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2369.检查数组是否存在有效划分",
        "hardRate": "MEDIUM",
        "passRate": "38.39%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，你必须将数组划分为一个或多个 <strong>连续</strong> 子数组。</p>\n\n<p>如果获得的这些子数组中每个都能满足下述条件<strong> 之一</strong> ，则可以称其为数组的一种 <strong>有效</strong> 划分：</p>\n\n<ol>\n\t<li>子数组 <strong>恰</strong> 由 <code>2</code> 个相等元素组成，例如，子数组 <code>[2,2]</code> 。</li>\n\t<li>子数组 <strong>恰</strong> 由 <code>3</code> 个相等元素组成，例如，子数组 <code>[4,4,4]</code> 。</li>\n\t<li>子数组 <strong>恰</strong> 由 <code>3</code> 个连续递增元素组成，并且相邻元素之间的差值为 <code>1</code> 。例如，子数组 <code>[3,4,5]</code> ，但是子数组 <code>[1,3,5]</code> 不符合要求。</li>\n</ol>\n\n<p>如果数组 <strong>至少</strong> 存在一种有效划分，返回 <code>true</code><em> </em>，否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,4,4,5,6]\n<strong>输出：</strong>true\n<strong>解释：</strong>数组可以划分成子数组 [4,4] 和 [4,5,6] 。\n这是一种有效划分，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>该数组不存在有效划分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2370.最长理想子序列",
        "hardRate": "MEDIUM",
        "passRate": "43.07%",
        "problemsUrl": "https://leetcode.cn/problems/longest-ideal-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-ideal-subsequence/solution",
        "problemsDesc": "<p>给你一个由小写字母组成的字符串 <code>s</code> ，和一个整数 <code>k</code> 。如果满足下述条件，则可以将字符串 <code>t</code> 视作是 <strong>理想字符串</strong> ：</p>\n\n<ul>\n\t<li><code>t</code> 是字符串 <code>s</code> 的一个子序列。</li>\n\t<li><code>t</code> 中每两个 <strong>相邻</strong> 字母在字母表中位次的绝对差值小于或等于 <code>k</code> 。</li>\n</ul>\n\n<p>返回 <strong>最长</strong> 理想字符串的长度。</p>\n\n<p>字符串的子序列同样是一个字符串，并且子序列还满足：可以经由其他字符串删除某些字符（也可以不删除）但不改变剩余字符的顺序得到。</p>\n\n<p><strong>注意：</strong>字母表顺序不会循环。例如，<code>'a'</code> 和 <code>'z'</code> 在字母表中位次的绝对差值是 <code>25</code> ，而不是 <code>1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"acfgbd\", k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>最长理想字符串是 \"acbd\" 。该字符串长度为 4 ，所以返回 4 。\n注意 \"acfgbd\" 不是理想字符串，因为 'c' 和 'f' 的字母表位次差值为 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", k = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>最长理想字符串是 \"abcd\" ，该字符串长度为 4 ，所以返回 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 25</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2371.最小化网格中的最大值",
        "hardRate": "HARD",
        "passRate": "74.28%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-maximum-value-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-maximum-value-in-a-grid/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2372.计算每个销售人员的影响力",
        "hardRate": "MEDIUM",
        "passRate": "77.79%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-the-influence-of-each-salesperson/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-the-influence-of-each-salesperson/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2373.矩阵中的局部最大值",
        "hardRate": "EASY",
        "passRate": "85.21%",
        "problemsUrl": "https://leetcode.cn/problems/largest-local-values-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-local-values-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> 。</p>\n\n<p>生成一个大小为&nbsp;<code>(n - 2) x (n - 2)</code> 的整数矩阵&nbsp; <code>maxLocal</code> ，并满足：</p>\n\n<ul>\n\t<li><code>maxLocal[i][j]</code> 等于 <code>grid</code> 中以 <code>i + 1</code> 行和 <code>j + 1</code> 列为中心的 <code>3 x 3</code> 矩阵中的 <strong>最大值</strong> 。</li>\n</ul>\n\n<p>换句话说，我们希望找出 <code>grid</code> 中每个&nbsp;<code>3 x 3</code> 矩阵中的最大值。</p>\n\n<p>返回生成的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/21/ex1.png\" style=\"width: 371px; height: 210px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]\n<strong>输出：</strong>[[9,9],[8,6]]\n<strong>解释：</strong>原矩阵和生成的矩阵如上图所示。\n注意，生成的矩阵中，每个值都对应 grid 中一个相接的 3 x 3 矩阵的最大值。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/02/ex2new2.png\" style=\"width: 436px; height: 240px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]\n<strong>输出：</strong>[[2,2,2],[2,2,2],[2,2,2]]\n<strong>解释：</strong>注意，2 包含在 grid 中每个 3 x 3 的矩阵中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>3 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2374.边积分最高的节点",
        "hardRate": "MEDIUM",
        "passRate": "42.32%",
        "problemsUrl": "https://leetcode.cn/problems/node-with-highest-edge-score/",
        "solutionsUrl": "https://leetcode.cn/problems/node-with-highest-edge-score/solution",
        "problemsDesc": "<p>给你一个有向图，图中有 <code>n</code> 个节点，节点编号从 <code>0</code> 到 <code>n - 1</code> ，其中每个节点都 <strong>恰有一条</strong> 出边。</p>\n\n<p>图由一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>edges</code> 表示，其中 <code>edges[i]</code> 表示存在一条从节点 <code>i</code> 到节点 <code>edges[i]</code> 的 <strong>有向</strong> 边。</p>\n\n<p>节点 <code>i</code> 的 <strong>边积分</strong> 定义为：所有存在一条指向节点 <code>i</code> 的边的节点的 <strong>编号</strong> 总和。</p>\n\n<p>返回 <strong>边积分</strong> 最高的节点。如果多个节点的 <strong>边积分</strong> 相同，返回编号 <strong>最小</strong> 的那个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/06/20/image-20220620195403-1.png\" style=\"width: 450px; height: 260px;\">\n<pre><strong>输入：</strong>edges = [1,0,0,0,0,7,7,5]\n<strong>输出：</strong>7\n<strong>解释：</strong>\n- 节点 1、2、3 和 4 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 + 3 + 4 = 10 。\n- 节点 0 有一条指向节点 1 的边，节点 1 的边积分等于 0 。\n- 节点 7 有一条指向节点 5 的边，节点 5 的边积分等于 7 。\n- 节点 5 和 6 都有指向节点 7 的边，节点 7 的边积分等于 5 + 6 = 11 。\n节点 7 的边积分最高，所以返回 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/06/20/image-20220620200212-3.png\" style=\"width: 150px; height: 155px;\">\n<pre><strong>输入：</strong>edges = [2,0,0,2]\n<strong>输出：</strong>0\n<strong>解释：\n</strong>- 节点 1 和 2 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 = 3 。\n- 节点 0 和 3 都有指向节点 2 的边，节点 2 的边积分等于 0 + 3 = 3 。\n节点 0 和 2 的边积分都是 3 。由于节点 0 的编号更小，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= edges[i] &lt; n</code></li>\n\t<li><code>edges[i] != i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2375.根据模式串构造最小数字",
        "hardRate": "MEDIUM",
        "passRate": "69.96%",
        "problemsUrl": "https://leetcode.cn/problems/construct-smallest-number-from-di-string/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-smallest-number-from-di-string/solution",
        "problemsDesc": "<p>给你下标从 <strong>0</strong> 开始、长度为 <code>n</code>&nbsp;的字符串&nbsp;<code>pattern</code>&nbsp;，它包含两种字符，<code>'I'</code>&nbsp;表示 <strong>上升</strong>&nbsp;，<code>'D'</code>&nbsp;表示 <strong>下降</strong>&nbsp;。</p>\n\n<p>你需要构造一个下标从 <strong>0</strong>&nbsp;开始长度为&nbsp;<code>n + 1</code>&nbsp;的字符串，且它要满足以下条件：</p>\n\n<ul>\n\t<li><code>num</code>&nbsp;包含数字&nbsp;<code>'1'</code>&nbsp;到&nbsp;<code>'9'</code>&nbsp;，其中每个数字&nbsp;<strong>至多</strong>&nbsp;使用一次。</li>\n\t<li>如果&nbsp;<code>pattern[i] == 'I'</code>&nbsp;，那么&nbsp;<code>num[i] &lt; num[i + 1]</code>&nbsp;。</li>\n\t<li>如果&nbsp;<code>pattern[i] == 'D'</code>&nbsp;，那么&nbsp;<code>num[i] &gt; num[i + 1]</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回满足上述条件字典序 <strong>最小</strong>&nbsp;的字符串<em>&nbsp;</em><code>num</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>pattern = \"IIIDIDDD\"\n<b>输出：</b>\"123549876\"\n<strong>解释：\n</strong>下标 0 ，1 ，2 和 4 处，我们需要使 num[i] &lt; num[i+1] 。\n下标 3 ，5 ，6 和 7 处，我们需要使 num[i] &gt; num[i+1] 。\n一些可能的 num 的值为 \"245639871\" ，\"135749862\" 和 \"123849765\" 。\n\"123549876\" 是满足条件最小的数字。\n注意，\"123414321\" 不是可行解因为数字 '1' 使用次数超过 1 次。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>pattern = \"DDD\"\n<b>输出：</b>\"4321\"\n<strong>解释：</strong>\n一些可能的 num 的值为 \"9876\" ，\"7321\" 和 \"8742\" 。\n\"4321\" 是满足条件最小的数字。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pattern.length &lt;= 8</code></li>\n\t<li><code>pattern</code>&nbsp;只包含字符&nbsp;<code>'I'</code> 和&nbsp;<code>'D'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2376.统计特殊整数",
        "hardRate": "HARD",
        "passRate": "51.62%",
        "problemsUrl": "https://leetcode.cn/problems/count-special-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/count-special-integers/solution",
        "problemsDesc": "<p>如果一个正整数每一个数位都是 <strong>互不相同</strong>&nbsp;的，我们称它是 <strong>特殊整数</strong> 。</p>\n\n<p>给你一个 <strong>正</strong>&nbsp;整数&nbsp;<code>n</code>&nbsp;，请你返回区间<em>&nbsp;</em><code>[1, n]</code>&nbsp;之间特殊整数的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 20\n<b>输出：</b>19\n<b>解释：</b>1 到 20 之间所有整数除了 11 以外都是特殊整数。所以总共有 19 个特殊整数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5\n<b>输出：</b>5\n<b>解释：</b>1 到 5 所有整数都是特殊整数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 135\n<b>输出：</b>110\n<b>解释：</b>从 1 到 135 总共有 110 个整数是特殊整数。\n不特殊的部分数字为：22 ，114 和 131 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2377.整理奥运表",
        "hardRate": "EASY",
        "passRate": "80.02%",
        "problemsUrl": "https://leetcode.cn/problems/sort-the-olympic-table/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-the-olympic-table/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2378.选择边来最大化树的得分",
        "hardRate": "MEDIUM",
        "passRate": "68.37%",
        "problemsUrl": "https://leetcode.cn/problems/choose-edges-to-maximize-score-in-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/choose-edges-to-maximize-score-in-a-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2379.得到 K 个黑块的最少涂色次数",
        "hardRate": "EASY",
        "passRate": "61.75%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>blocks</code>&nbsp;，<code>blocks[i]</code>&nbsp;要么是&nbsp;<code>'W'</code>&nbsp;要么是&nbsp;<code>'B'</code>&nbsp;，表示第&nbsp;<code>i</code>&nbsp;块的颜色。字符&nbsp;<code>'W'</code> 和&nbsp;<code>'B'</code>&nbsp;分别表示白色和黑色。</p>\n\n<p>给你一个整数&nbsp;<code>k</code>&nbsp;，表示想要&nbsp;<strong>连续</strong>&nbsp;黑色块的数目。</p>\n\n<p>每一次操作中，你可以选择一个白色块将它 <strong>涂成</strong>&nbsp;黑色块。</p>\n\n<p>请你返回至少出现 <strong>一次</strong>&nbsp;连续 <code>k</code>&nbsp;个黑色块的 <strong>最少</strong>&nbsp;操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>blocks = \"WBBWWBBWBW\", k = 7\n<b>输出：</b>3\n<strong>解释：</strong>\n一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。\n得到 blocks = \"BBBBBBBWBW\" 。\n可以证明无法用少于 3 次操作得到 7 个连续的黑块。\n所以我们返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>blocks = \"WBWBBBW\", k = 2\n<b>输出：</b>0\n<strong>解释：</strong>\n不需要任何操作，因为已经有 2 个连续的黑块。\n所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>n == blocks.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>blocks[i]</code>&nbsp;要么是&nbsp;<code>'W'</code>&nbsp;，要么是&nbsp;<code>'B'</code> 。</li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2380.二进制字符串重新安排顺序需要的时间",
        "hardRate": "MEDIUM",
        "passRate": "56.15%",
        "problemsUrl": "https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string/solution",
        "problemsDesc": "<p>给你一个二进制字符串&nbsp;<code>s</code>&nbsp;。在一秒之中，<strong>所有</strong>&nbsp;子字符串&nbsp;<code>\"01\"</code> <strong>同时</strong>&nbsp;被替换成&nbsp;<code>\"10\"</code>&nbsp;。这个过程持续进行到没有&nbsp;<code>\"01\"</code>&nbsp;存在。</p>\n\n<p>请你返回完成这个过程所需要的秒数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"0110101\"\n<b>输出：</b>4\n<b>解释：</b>\n一秒后，s 变成 \"1011010\" 。\n再过 1 秒后，s 变成 \"1101100\" 。\n第三秒过后，s 变成 \"1110100\" 。\n第四秒后，s 变成 \"1111000\" 。\n此时没有 \"01\" 存在，整个过程花费 4 秒。\n所以我们返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"11100\"\n<b>输出：</b>0\n<strong>解释：</strong>\ns 中没有 \"01\" 存在，整个过程花费 0 秒。\n所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你能以 O(n) 的时间复杂度解决这个问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2381.字母移位 II",
        "hardRate": "MEDIUM",
        "passRate": "36.86%",
        "problemsUrl": "https://leetcode.cn/problems/shifting-letters-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/shifting-letters-ii/solution",
        "problemsDesc": "<p>给你一个小写英文字母组成的字符串&nbsp;<code>s</code>&nbsp;和一个二维整数数组&nbsp;<code>shifts</code>&nbsp;，其中&nbsp;<code>shifts[i] = [start<sub>i</sub>, end<sub>i</sub>, direction<sub>i</sub>]</code>&nbsp;。对于每个&nbsp;<code>i</code>&nbsp;，将&nbsp;<code>s</code>&nbsp;中从下标&nbsp;<code>start<sub>i</sub></code>&nbsp;到下标&nbsp;<code>end<sub>i</sub></code>&nbsp;（两者都包含）所有字符都进行移位运算，如果&nbsp;<code>direction<sub>i</sub> = 1</code>&nbsp;将字符向后移位，如果&nbsp;<code>direction<sub>i</sub> = 0</code>&nbsp;将字符向前移位。</p>\n\n<p>将一个字符 <strong>向后</strong>&nbsp;移位的意思是将这个字符用字母表中 <strong>下一个</strong>&nbsp;字母替换（字母表视为环绕的，所以&nbsp;<code>'z'</code>&nbsp;变成&nbsp;<code>'a'</code>）。类似的，将一个字符 <strong>向前</strong>&nbsp;移位的意思是将这个字符用字母表中 <strong>前一个</strong>&nbsp;字母替换（字母表是环绕的，所以&nbsp;<code>'a'</code>&nbsp;变成&nbsp;<code>'z'</code>&nbsp;）。</p>\n\n<p>请你返回对 <code>s</code>&nbsp;进行所有移位操作以后得到的最终字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]\n<b>输出：</b>\"ace\"\n<b>解释：</b>首先，将下标从 0 到 1 的字母向前移位，得到 s = \"zac\" 。\n然后，将下标从 1 到 2 的字母向后移位，得到 s = \"zbd\" 。\n最后，将下标从 0 到 2 的字符向后移位，得到 s = \"ace\" 。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><b>输入：</b>s = \"dztz\", shifts = [[0,0,0],[1,1,1]]\n<b>输出：</b>\"catz\"\n<b>解释：</b>首先，将下标从 0 到 0 的字母向前移位，得到 s = \"cztz\" 。\n最后，将下标从 1 到 1 的字符向后移位，得到 s = \"catz\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, shifts.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>shifts[i].length == 3</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt; s.length</code></li>\n\t<li><code>0 &lt;= direction<sub>i</sub> &lt;= 1</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2382.删除操作后的最大子段和",
        "hardRate": "HARD",
        "passRate": "56.36%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-segment-sum-after-removals/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-segment-sum-after-removals/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code> 和&nbsp;<code>removeQueries</code>&nbsp;，两者长度都为&nbsp;<code>n</code>&nbsp;。对于第&nbsp;<code>i</code>&nbsp;个查询，<code>nums</code>&nbsp;中位于下标&nbsp;<code>removeQueries[i]</code>&nbsp;处的元素被删除，将 <code>nums</code>&nbsp;分割成更小的子段。</p>\n\n<p>一个 <strong>子段</strong>&nbsp;是 <code>nums</code>&nbsp;中连续 <strong>正</strong>&nbsp;整数形成的序列。<strong>子段和</strong>&nbsp;是子段中所有元素的和。</p>\n\n<p>请你返回一个长度为 <code>n</code>&nbsp;的整数数组<em>&nbsp;</em><code>answer</code>&nbsp;，其中<em>&nbsp;</em><code>answer[i]</code>是第&nbsp;<code>i</code>&nbsp;次删除操作以后的&nbsp;<strong>最大</strong>&nbsp;子段和。</p>\n\n<p><strong>注意：</strong>一个下标至多只会被删除一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]\n<b>输出：</b>[14,7,2,2,0]\n<b>解释：</b>用 0 表示被删除的元素，答案如下所示：\n查询 1 ：删除第 0 个元素，nums 变成 [0,2,5,6,1] ，最大子段和为子段 [2,5,6,1] 的和 14 。\n查询 2 ：删除第 3 个元素，nums 变成 [0,2,5,0,1] ，最大子段和为子段 [2,5] 的和 7 。\n查询 3 ：删除第 2 个元素，nums 变成 [0,2,0,0,1] ，最大子段和为子段 [2] 的和 2 。\n查询 4 ：删除第 4 个元素，nums 变成 [0,2,0,0,0] ，最大子段和为子段 [2] 的和 2 。\n查询 5 ：删除第 1 个元素，nums 变成 [0,0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。\n所以，我们返回 [14,7,2,2,0] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,2,11,1], removeQueries = [3,2,1,0]\n<b>输出：</b>[16,5,3,0]\n<b>解释：</b>用 0 表示被删除的元素，答案如下所示：\n查询 1 ：删除第 3 个元素，nums 变成 [3,2,11,0] ，最大子段和为子段 [3,2,11] 的和 16 。\n查询 2 ：删除第 2 个元素，nums 变成 [3,2,0,0] ，最大子段和为子段 [3,2] 的和 5 。\n查询 3 ：删除第 1 个元素，nums 变成 [3,0,0,0] ，最大子段和为子段 [3] 的和 3 。\n查询 5 ：删除第 0 个元素，nums 变成 [0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。\n所以，我们返回 [16,5,3,0] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length == removeQueries.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= removeQueries[i] &lt; n</code></li>\n\t<li><code>removeQueries</code>&nbsp;中所有数字 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2383.赢得比赛需要的最少训练时长",
        "hardRate": "EASY",
        "passRate": "47.19%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/solution",
        "problemsDesc": "<p>你正在参加一场比赛，给你两个 <strong>正</strong> 整数 <code>initialEnergy</code> 和 <code>initialExperience</code> 分别表示你的初始精力和初始经验。</p>\n\n<p>另给你两个下标从 <strong>0</strong> 开始的整数数组 <code>energy</code> 和 <code>experience</code>，长度均为 <code>n</code> 。</p>\n\n<p>你将会 <strong>依次</strong> 对上 <code>n</code> 个对手。第 <code>i</code> 个对手的精力和经验分别用 <code>energy[i]</code> 和 <code>experience[i]</code> 表示。当你对上对手时，需要在经验和精力上都 <strong>严格</strong> 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。</p>\n\n<p>击败第 <code>i</code> 个对手会使你的经验 <strong>增加</strong> <code>experience[i]</code>，但会将你的精力 <strong>减少</strong>&nbsp; <code>energy[i]</code> 。</p>\n\n<p>在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 <strong>或者</strong> 将精力增加 1 。</p>\n\n<p>返回击败全部 <code>n</code> 个对手需要训练的 <strong>最少</strong> 小时数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]\n<strong>输出：</strong>8\n<strong>解释：</strong>在 6 小时训练后，你可以将精力提高到 11 ，并且再训练 2 个小时将经验提高到 5 。\n按以下顺序与对手比赛：\n- 你的精力与经验都超过第 0 个对手，所以获胜。\n  精力变为：11 - 1 = 10 ，经验变为：5 + 2 = 7 。\n- 你的精力与经验都超过第 1 个对手，所以获胜。\n  精力变为：10 - 4 = 6 ，经验变为：7 + 6 = 13 。\n- 你的精力与经验都超过第 2 个对手，所以获胜。\n  精力变为：6 - 3 = 3 ，经验变为：13 + 3 = 16 。\n- 你的精力与经验都超过第 3 个对手，所以获胜。\n  精力变为：3 - 2 = 1 ，经验变为：16 + 1 = 17 。\n在比赛前进行了 8 小时训练，所以返回 8 。\n可以证明不存在更小的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]\n<strong>输出：</strong>0\n<strong>解释：</strong>你不需要额外的精力和经验就可以赢得比赛，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == energy.length == experience.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= initialEnergy, initialExperience, energy[i], experience[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2384.最大回文数字",
        "hardRate": "MEDIUM",
        "passRate": "31.06%",
        "problemsUrl": "https://leetcode.cn/problems/largest-palindromic-number/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-palindromic-number/solution",
        "problemsDesc": "<p>给你一个仅由数字（<code>0 - 9</code>）组成的字符串 <code>num</code> 。</p>\n\n<p>请你找出能够使用 <code>num</code> 中数字形成的 <strong>最大回文</strong> 整数，并以字符串形式返回。该整数不含 <strong>前导零</strong> 。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>你 <strong>无需</strong> 使用 <code>num</code> 中的所有数字，但你必须使用 <strong>至少</strong> 一个数字。</li>\n\t<li>数字可以重新排序。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"444947137\"\n<strong>输出：</strong>\"7449447\"\n<strong>解释：</strong>\n从 \"<em><strong>44494</strong></em><em><strong>7</strong></em>13<em><strong>7</strong></em>\" 中选用数字 \"4449477\"，可以形成回文整数 \"7449447\" 。\n可以证明 \"7449447\" 是能够形成的最大回文整数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"00009\"\n<strong>输出：</strong>\"9\"\n<strong>解释：</strong>\n可以证明 \"9\" 能够形成的最大回文整数。\n注意返回的整数不应含前导零。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>num</code> 由数字（<code>0 - 9</code>）组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2385.感染二叉树需要的总时间",
        "hardRate": "MEDIUM",
        "passRate": "46.18%",
        "problemsUrl": "https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/",
        "solutionsUrl": "https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，二叉树中节点的值 <strong>互不相同</strong> 。另给你一个整数 <code>start</code> 。在第 <code>0</code> 分钟，<strong>感染</strong> 将会从值为 <code>start</code> 的节点开始爆发。</p>\n\n<p>每分钟，如果节点满足以下全部条件，就会被感染：</p>\n\n<ul>\n\t<li>节点此前还没有感染。</li>\n\t<li>节点与一个已感染节点相邻。</li>\n</ul>\n\n<p>返回感染整棵树需要的分钟数<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/25/image-20220625231744-1.png\" style=\"width: 400px; height: 306px;\">\n<pre><strong>输入：</strong>root = [1,5,3,null,4,10,6,9,2], start = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>节点按以下过程被感染：\n- 第 0 分钟：节点 3\n- 第 1 分钟：节点 1、10、6\n- 第 2 分钟：节点5\n- 第 3 分钟：节点 4\n- 第 4 分钟：节点 9 和 2\n感染整棵树需要 4 分钟，所以返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/25/image-20220625231812-2.png\" style=\"width: 75px; height: 66px;\">\n<pre><strong>输入：</strong>root = [1], start = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>第 0 分钟，树中唯一一个节点处于感染状态，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>每个节点的值 <strong>互不相同</strong></li>\n\t<li>树中必定存在值为 <code>start</code> 的节点</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2386.找出数组的第 K 大和",
        "hardRate": "HARD",
        "passRate": "42.30%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-k-sum-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-k-sum-of-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。你可以选择数组的任一 <strong>子序列</strong> 并且对其全部元素求和。</p>\n\n<p>数组的 <strong>第 k 大和</strong> 定义为：可以获得的第 <code>k</code> 个 <strong>最大</strong> 子序列和（子序列和允许出现重复）</p>\n\n<p>返回数组的 <strong>第 k 大和</strong> 。</p>\n\n<p>子序列是一个可以由其他数组删除某些或不删除元素排生而来的数组，且派生过程不改变剩余元素的顺序。</p>\n\n<p><strong>注意：</strong>空子序列的和视作 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,-2], k = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>所有可能获得的子序列和列出如下，按递减顺序排列：\n- 6、4、4、2、<strong><em>2</em></strong>、0、0、-2\n数组的第 5 大和是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,-2,3,4,-10,12], k = 16\n<strong>输出：</strong>10\n<strong>解释：</strong>数组的第 16 大和是 10 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= min(2000, 2<sup>n</sup>)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2387.行排序矩阵的中位数",
        "hardRate": "MEDIUM",
        "passRate": "76.22%",
        "problemsUrl": "https://leetcode.cn/problems/median-of-a-row-wise-sorted-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/median-of-a-row-wise-sorted-matrix/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2388.将表中的空值更改为前一个值",
        "hardRate": "MEDIUM",
        "passRate": "67.79%",
        "problemsUrl": "https://leetcode.cn/problems/change-null-values-in-a-table-to-the-previous-value/",
        "solutionsUrl": "https://leetcode.cn/problems/change-null-values-in-a-table-to-the-previous-value/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2389.和有限的最长子序列",
        "hardRate": "EASY",
        "passRate": "70.95%",
        "problemsUrl": "https://leetcode.cn/problems/longest-subsequence-with-limited-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-subsequence-with-limited-sum/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组 <code>nums</code> ，和一个长度为 <code>m</code> 的整数数组 <code>queries</code> 。</p>\n\n<p>返回一个长度为 <code>m</code> 的数组<em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer[i]</code><em> </em>是 <code>nums</code> 中<span style=\"\"> </span>元素之和小于等于 <code>queries[i]</code> 的 <strong>子序列</strong> 的 <strong>最大</strong> 长度<span style=\"\">&nbsp;</span><span style=\"\"> </span>。</p>\n\n<p><strong>子序列</strong> 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,5,2,1], queries = [3,10,21]\n<strong>输出：</strong>[2,3,4]\n<strong>解释：</strong>queries 对应的 answer 如下：\n- 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。\n- 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。\n- 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,4,5], queries = [1]\n<strong>输出：</strong>[0]\n<strong>解释：</strong>空子序列是唯一一个满足元素和小于或等于 1 的子序列，所以 answer[0] = 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == queries.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i], queries[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2390.从字符串中移除星号",
        "hardRate": "MEDIUM",
        "passRate": "69.22%",
        "problemsUrl": "https://leetcode.cn/problems/removing-stars-from-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/removing-stars-from-a-string/solution",
        "problemsDesc": "<p>给你一个包含若干星号 <code>*</code> 的字符串 <code>s</code> 。</p>\n\n<p>在一步操作中，你可以：</p>\n\n<ul>\n\t<li>选中 <code>s</code> 中的一个星号。</li>\n\t<li>移除星号 <strong>左侧</strong> 最近的那个 <strong>非星号</strong> 字符，并移除该星号自身。</li>\n</ul>\n\n<p>返回移除 <strong>所有</strong> 星号之后的字符串<strong>。</strong></p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>生成的输入保证总是可以执行题面中描述的操作。</li>\n\t<li>可以证明结果字符串是唯一的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leet**cod*e\"\n<strong>输出：</strong>\"lecoe\"\n<strong>解释：</strong>从左到右执行移除操作：\n- 距离第 1 个星号最近的字符是 \"lee<em><strong>t</strong></em>**cod*e\" 中的 't' ，s 变为 \"lee*cod*e\" 。\n- 距离第 2 个星号最近的字符是 \"le<em><strong>e</strong></em>*cod*e\" 中的 'e' ，s 变为 \"lecod*e\" 。\n- 距离第 3 个星号最近的字符是 \"leco<em><strong>d</strong></em>*e\" 中的 'd' ，s 变为 \"lecoe\" 。\n不存在其他星号，返回 \"lecoe\" 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"erase*****\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>整个字符串都会被移除，所以返回空字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母和星号 <code>*</code> 组成</li>\n\t<li><code>s</code> 可以执行上述操作</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2391.收集垃圾的最少总时间",
        "hardRate": "MEDIUM",
        "passRate": "85.69%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-amount-of-time-to-collect-garbage/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-amount-of-time-to-collect-garbage/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串数组&nbsp;<code>garbage</code>&nbsp;，其中&nbsp;<code>garbage[i]</code>&nbsp;表示第 <code>i</code>&nbsp;个房子的垃圾集合。<code>garbage[i]</code>&nbsp;只包含字符&nbsp;<code>'M'</code>&nbsp;，<code>'P'</code> 和&nbsp;<code>'G'</code>&nbsp;，但可能包含多个相同字符，每个字符分别表示一单位的金属、纸和玻璃。垃圾车收拾 <strong>一</strong>&nbsp;单位的任何一种垃圾都需要花费&nbsp;<code>1</code>&nbsp;分钟。</p>\n\n<p>同时给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>travel</code>&nbsp;，其中&nbsp;<code>travel[i]</code>&nbsp;是垃圾车从房子 <code>i</code>&nbsp;行驶到房子 <code>i + 1</code>&nbsp;需要的分钟数。</p>\n\n<p>城市里总共有三辆垃圾车，分别收拾三种垃圾。每辆垃圾车都从房子 <code>0</code>&nbsp;出发，<strong>按顺序</strong>&nbsp;到达每一栋房子。但它们 <strong>不是必须</strong>&nbsp;到达所有的房子。</p>\n\n<p>任何时刻只有 <strong>一辆</strong>&nbsp;垃圾车处在使用状态。当一辆垃圾车在行驶或者收拾垃圾的时候，另外两辆车 <strong>不能</strong>&nbsp;做任何事情。</p>\n\n<p>请你返回收拾完所有垃圾需要花费的 <strong>最少</strong>&nbsp;总分钟数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>garbage = [\"G\",\"P\",\"GP\",\"GG\"], travel = [2,4,3]\n<b>输出：</b>21\n<strong>解释：</strong>\n收拾纸的垃圾车：\n1. 从房子 0 行驶到房子 1\n2. 收拾房子 1 的纸垃圾\n3. 从房子 1 行驶到房子 2\n4. 收拾房子 2 的纸垃圾\n收拾纸的垃圾车总共花费 8 分钟收拾完所有的纸垃圾。\n收拾玻璃的垃圾车：\n1. 收拾房子 0 的玻璃垃圾\n2. 从房子 0 行驶到房子 1\n3. 从房子 1 行驶到房子 2\n4. 收拾房子 2 的玻璃垃圾\n5. 从房子 2 行驶到房子 3\n6. 收拾房子 3 的玻璃垃圾\n收拾玻璃的垃圾车总共花费 13 分钟收拾完所有的玻璃垃圾。\n由于没有金属垃圾，收拾金属的垃圾车不需要花费任何时间。\n所以总共花费 8 + 13 = 21 分钟收拾完所有垃圾。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>garbage = [\"MMM\",\"PGM\",\"GP\"], travel = [3,10]\n<b>输出：</b>37\n<strong>解释：</strong>\n收拾金属的垃圾车花费 7 分钟收拾完所有的金属垃圾。\n收拾纸的垃圾车花费 15 分钟收拾完所有的纸垃圾。\n收拾玻璃的垃圾车花费 15 分钟收拾完所有的玻璃垃圾。\n总共花费 7 + 15 + 15 = 37 分钟收拾完所有的垃圾。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= garbage.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>garbage[i]</code> 只包含字母&nbsp;<code>'M'</code>&nbsp;，<code>'P'</code>&nbsp;和&nbsp;<code>'G'</code>&nbsp;。</li>\n\t<li><code>1 &lt;= garbage[i].length &lt;= 10</code></li>\n\t<li><code>travel.length == garbage.length - 1</code></li>\n\t<li><code>1 &lt;= travel[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2392.给定条件下构造矩阵",
        "hardRate": "HARD",
        "passRate": "55.74%",
        "problemsUrl": "https://leetcode.cn/problems/build-a-matrix-with-conditions/",
        "solutionsUrl": "https://leetcode.cn/problems/build-a-matrix-with-conditions/solution",
        "problemsDesc": "<p>给你一个 <strong>正</strong>&nbsp;整数&nbsp;<code>k</code>&nbsp;，同时给你：</p>\n\n<ul>\n\t<li>一个大小为 <code>n</code>&nbsp;的二维整数数组&nbsp;<code>rowConditions</code>&nbsp;，其中&nbsp;<code>rowConditions[i] = [above<sub>i</sub>, below<sub>i</sub>]</code>&nbsp;和</li>\n\t<li>一个大小为 <code>m</code>&nbsp;的二维整数数组&nbsp;<code>colConditions</code>&nbsp;，其中&nbsp;<code>colConditions[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;。</li>\n</ul>\n\n<p>两个数组里的整数都是&nbsp;<code>1</code>&nbsp;到&nbsp;<code>k</code>&nbsp;之间的数字。</p>\n\n<p>你需要构造一个&nbsp;<code>k x k</code>&nbsp;的矩阵，<code>1</code>&nbsp;到&nbsp;<code>k</code>&nbsp;每个数字需要&nbsp;<strong>恰好出现一次</strong>&nbsp;。剩余的数字都是<b>&nbsp;</b><code>0</code>&nbsp;。</p>\n\n<p>矩阵还需要满足以下条件：</p>\n\n<ul>\n\t<li>对于所有 <code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;之间的下标&nbsp;<code>i</code>&nbsp;，数字&nbsp;<code>above<sub>i</sub></code>&nbsp;所在的 <strong>行</strong>&nbsp;必须在数字&nbsp;<code>below<sub>i</sub></code>&nbsp;所在行的上面。</li>\n\t<li>对于所有 <code>0</code>&nbsp;到 <code>m - 1</code>&nbsp;之间的下标&nbsp;<code>i</code>&nbsp;，数字&nbsp;<code>left<sub>i</sub></code>&nbsp;所在的 <b>列</b>&nbsp;必须在数字&nbsp;<code>right<sub>i</sub></code>&nbsp;所在列的左边。</li>\n</ul>\n\n<p>返回满足上述要求的 <strong>任意</strong>&nbsp;矩阵。如果不存在答案，返回一个空的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/06/gridosdrawio.png\" style=\"width: 211px; height: 211px;\"></p>\n\n<pre><b>输入：</b>k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]\n<b>输出：</b>[[3,0,0],[0,0,1],[0,2,0]]\n<b>解释：</b>上图为一个符合所有条件的矩阵。\n行要求如下：\n- 数字 1 在第 <strong>1</strong> 行，数字 2 在第 <strong>2</strong>&nbsp;行，1 在 2 的上面。\n- 数字 3 在第 <strong>0</strong>&nbsp;行，数字 2 在第 <strong>2</strong>&nbsp;行，3 在 2 的上面。\n列要求如下：\n- 数字 2 在第 <strong>1</strong>&nbsp;列，数字 1 在第 <strong>2</strong>&nbsp;列，2 在 1 的左边。\n- 数字 3 在第 <strong>0</strong>&nbsp;列，数字 2 在第 <strong>1</strong>&nbsp;列，3 在 2 的左边。\n注意，可能有多种正确的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]\n<b>输出：</b>[]\n<b>解释：</b>由前两个条件可以得到 3 在 1 的下面，但第三个条件是 3 在 1 的上面。\n没有符合条件的矩阵存在，所以我们返回空矩阵。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= 400</code></li>\n\t<li><code>1 &lt;= rowConditions.length, colConditions.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>rowConditions[i].length == colConditions[i].length == 2</code></li>\n\t<li><code>1 &lt;= above<sub>i</sub>, below<sub>i</sub>, left<sub>i</sub>, right<sub>i</sub> &lt;= k</code></li>\n\t<li><code>above<sub>i</sub> != below<sub>i</sub></code></li>\n\t<li><code>left<sub>i</sub> != right<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2393.严格递增的子数组个数",
        "hardRate": "MEDIUM",
        "passRate": "78.79%",
        "problemsUrl": "https://leetcode.cn/problems/count-strictly-increasing-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-strictly-increasing-subarrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2394.开除员工",
        "hardRate": "MEDIUM",
        "passRate": "53.07%",
        "problemsUrl": "https://leetcode.cn/problems/employees-with-deductions/",
        "solutionsUrl": "https://leetcode.cn/problems/employees-with-deductions/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2395.和相等的子数组",
        "hardRate": "EASY",
        "passRate": "76.32%",
        "problemsUrl": "https://leetcode.cn/problems/find-subarrays-with-equal-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/find-subarrays-with-equal-sum/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，判断是否存在&nbsp;<strong>两个</strong>&nbsp;长度为&nbsp;<code>2</code>&nbsp;的子数组且它们的&nbsp;<strong>和</strong>&nbsp;相等。注意，这两个子数组起始位置的下标必须&nbsp;<strong>不相同</strong>&nbsp;。</p>\n\n<p>如果这样的子数组存在，请返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code><em>&nbsp;</em>。</p>\n\n<p><strong>子数组</strong> 是一个数组中一段连续非空的元素组成的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [4,2,4]\n<b>输出：</b>true\n<b>解释：</b>元素为 [4,2] 和 [2,4] 的子数组有相同的和 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>false\n<b>解释：</b>没有长度为 2 的两个子数组和相等。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [0,0,0]\n<b>输出：</b>true\n<b>解释：</b>子数组 [nums[0],nums[1]] 和 [nums[1],nums[2]] 的和相等，都为 0 。\n注意即使子数组的元素相同，这两个子数组也视为不相同的子数组，因为它们在原数组中的起始位置不同。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2396.严格回文的数字",
        "hardRate": "MEDIUM",
        "passRate": "87.90%",
        "problemsUrl": "https://leetcode.cn/problems/strictly-palindromic-number/",
        "solutionsUrl": "https://leetcode.cn/problems/strictly-palindromic-number/solution",
        "problemsDesc": "<p>如果一个整数 <code>n</code>&nbsp;在 <code>b</code>&nbsp;进制下（<code>b</code>&nbsp;为 <code>2</code>&nbsp;到 <code>n - 2</code>&nbsp;之间的所有整数）对应的字符串&nbsp;<strong>全部</strong>&nbsp;都是 <strong>回文的</strong>&nbsp;，那么我们称这个数&nbsp;<code>n</code>&nbsp;是 <strong>严格回文</strong>&nbsp;的。</p>\n\n<p>给你一个整数&nbsp;<code>n</code>&nbsp;，如果 <code>n</code>&nbsp;是 <strong>严格回文</strong>&nbsp;的，请返回&nbsp;<code>true</code> ，否则返回<em>&nbsp;</em><code>false</code>&nbsp;。</p>\n\n<p>如果一个字符串从前往后读和从后往前读完全相同，那么这个字符串是 <strong>回文的</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 9\n<b>输出：</b>false\n<b>解释：</b>在 2 进制下：9 = 1001 ，是回文的。\n在 3 进制下：9 = 100 ，不是回文的。\n所以，9 不是严格回文数字，我们返回 false 。\n注意在 4, 5, 6 和 7 进制下，n = 9 都不是回文的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 4\n<b>输出：</b>false\n<b>解释：</b>我们只考虑 2 进制：4 = 100 ，不是回文的。\n所以我们返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>4 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2397.被列覆盖的最多行数",
        "hardRate": "MEDIUM",
        "passRate": "54.79%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-rows-covered-by-columns/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-rows-covered-by-columns/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;二进制矩阵&nbsp;<code>mat</code>&nbsp;和一个整数&nbsp;<code>cols</code>&nbsp;，表示你需要选出的列数。</p>\n\n<p>如果一行中，所有的 <code>1</code> 都被你选中的列所覆盖，那么我们称这一行 <strong>被覆盖</strong>&nbsp;了。</p>\n\n<p>请你返回在选择 <code>cols</code>&nbsp;列的情况下，<strong>被覆盖</strong>&nbsp;的行数 <strong>最大</strong>&nbsp;为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/14/rowscovered.png\" style=\"width: 250px; height: 417px;\"></strong></p>\n\n<pre><b>输入：</b>mat = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], cols = 2\n<b>输出：</b>3\n<strong>解释：</strong>\n如上图所示，覆盖 3 行的一种可行办法是选择第 0 和第 2 列。\n可以看出，不存在大于 3 行被覆盖的方案，所以我们返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/14/rowscovered2.png\" style=\"width: 83px; height: 247px;\"></strong></p>\n\n<pre><b>输入：</b>mat = [[1],[0]], cols = 1\n<b>输出：</b>2\n<strong>解释：</strong>\n选择唯一的一列，两行都被覆盖了，原因是整个矩阵都被覆盖了。\n所以我们返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 12</code></li>\n\t<li><code>mat[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;要么是&nbsp;<code>1</code>&nbsp;。</li>\n\t<li><code>1 &lt;= cols &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2398.预算内的最多机器人数目",
        "hardRate": "HARD",
        "passRate": "34.45%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-robots-within-budget/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-robots-within-budget/solution",
        "problemsDesc": "<p>你有&nbsp;<code>n</code>&nbsp;个机器人，给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>chargeTimes</code> 和&nbsp;<code>runningCosts</code>&nbsp;，两者长度都为&nbsp;<code>n</code>&nbsp;。第&nbsp;<code>i</code>&nbsp;个机器人充电时间为&nbsp;<code>chargeTimes[i]</code>&nbsp;单位时间，花费&nbsp;<code>runningCosts[i]</code>&nbsp;单位时间运行。再给你一个整数&nbsp;<code>budget</code>&nbsp;。</p>\n\n<p>运行&nbsp;<code>k</code>&nbsp;个机器人 <strong>总开销</strong>&nbsp;是&nbsp;<code>max(chargeTimes) + k * sum(runningCosts)</code>&nbsp;，其中&nbsp;<code>max(chargeTimes)</code>&nbsp;是这&nbsp;<code>k</code>&nbsp;个机器人中最大充电时间，<code>sum(runningCosts)</code>&nbsp;是这 <code>k</code>&nbsp;个机器人的运行时间之和。</p>\n\n<p>请你返回在 <strong>不超过</strong>&nbsp;<code>budget</code>&nbsp;的前提下，你 <strong>最多</strong>&nbsp;可以 <strong>连续</strong>&nbsp;运行的机器人数目为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25\n<b>输出：</b>3\n<b>解释：</b>\n可以在 budget 以内运行所有单个机器人或者连续运行 2 个机器人。\n选择前 3 个机器人，可以得到答案最大值 3 。总开销是 max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 ，小于 25 。\n可以看出无法在 budget 以内连续运行超过 3 个机器人，所以我们返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19\n<b>输出：</b>0\n<b>解释：</b>即使运行任何一个单个机器人，还是会超出 budget，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>chargeTimes.length == runningCosts.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= chargeTimes[i], runningCosts[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= budget &lt;= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2399.检查相同字母间的距离",
        "hardRate": "EASY",
        "passRate": "75.26%",
        "problemsUrl": "https://leetcode.cn/problems/check-distances-between-same-letters/",
        "solutionsUrl": "https://leetcode.cn/problems/check-distances-between-same-letters/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，该字符串仅由小写英文字母组成，<code>s</code> 中的每个字母都 <strong>恰好</strong> 出现 <strong>两次</strong> 。另给你一个下标从 <strong>0</strong> 开始、长度为 <code>26</code> 的的整数数组 <code>distance</code> 。</p>\n\n<p>字母表中的每个字母按从 <code>0</code> 到 <code>25</code> 依次编号（即，<code>'a' -&gt; 0</code>, <code>'b' -&gt; 1</code>, <code>'c' -&gt; 2</code>, ... , <code>'z' -&gt; 25</code>）。</p>\n\n<p>在一个 <strong>匀整</strong> 字符串中，第 <code>i</code> 个字母的两次出现之间的字母数量是 <code>distance[i]</code> 。如果第 <code>i</code> 个字母没有在 <code>s</code> 中出现，那么 <code>distance[i]</code> 可以 <strong>忽略</strong> 。</p>\n\n<p>如果 <code>s</code> 是一个 <strong>匀整</strong> 字符串，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abaccb\", distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n- 'a' 在下标 0 和下标 2 处出现，所以满足 distance[0] = 1 。\n- 'b' 在下标 1 和下标 5 处出现，所以满足 distance[1] = 3 。\n- 'c' 在下标 3 和下标 4 处出现，所以满足 distance[2] = 0 。\n注意 distance[3] = 5 ，但是由于 'd' 没有在 s 中出现，可以忽略。\n因为 s 是一个匀整字符串，返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"aa\", distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>\n- 'a' 在下标 0 和 1 处出现，所以两次出现之间的字母数量为 0 。\n但是 distance[0] = 1 ，s 不是一个匀整字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 52</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n\t<li><code>s</code> 中的每个字母恰好出现两次</li>\n\t<li><code>distance.length == 26</code></li>\n\t<li><code>0 &lt;= distance[i] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2400.恰好移动 k 步到达某一位置的方法数目",
        "hardRate": "MEDIUM",
        "passRate": "32.67%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/solution",
        "problemsDesc": "<p>给你两个 <strong>正</strong> 整数 <code>startPos</code> 和 <code>endPos</code> 。最初，你站在 <strong>无限</strong> 数轴上位置 <code>startPos</code> 处。在一步移动中，你可以向左或者向右移动一个位置。</p>\n\n<p>给你一个正整数 <code>k</code> ，返回从 <code>startPos</code> 出发、<strong>恰好</strong> 移动 <code>k</code> 步并到达 <code>endPos</code> 的 <strong>不同</strong> 方法数目。由于答案可能会很大，返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>如果所执行移动的顺序不完全相同，则认为两种方法不同。</p>\n\n<p><strong>注意：</strong>数轴包含负整数<strong>。</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>startPos = 1, endPos = 2, k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>存在 3 种从 1 到 2 且恰好移动 3 步的方法：\n- 1 -&gt; 2 -&gt; 3 -&gt; 2.\n- 1 -&gt; 2 -&gt; 1 -&gt; 2.\n- 1 -&gt; 0 -&gt; 1 -&gt; 2.\n可以证明不存在其他方法，所以返回 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>startPos = 2, endPos = 5, k = 10\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在从 2 到 5 且恰好移动 10 步的方法。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= startPos, endPos, k &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    }
]