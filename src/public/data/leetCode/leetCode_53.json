[
    {
        "problemsName": " 2601.质数减法运算",
        "hardRate": "MEDIUM",
        "passRate": "38.59%",
        "problemsUrl": "https://leetcode.cn/problems/prime-subtraction-operation/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-subtraction-operation/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，数组长度为 <code>n</code> 。</p>\n\n<p>你可以执行无限次下述运算：</p>\n\n<ul>\n\t<li>选择一个之前未选过的下标 <code>i</code> ，并选择一个 <strong>严格小于</strong> <code>nums[i]</code> 的质数 <code>p</code> ，从 <code>nums[i]</code> 中减去 <code>p</code> 。</li>\n</ul>\n\n<p>如果你能通过上述运算使得 <code>nums</code> 成为严格递增数组，则返回 <code>true</code> ；否则返回 <code>false</code> 。</p>\n\n<p><strong>严格递增数组</strong> 中的每个元素都严格大于其前面的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,9,6,10]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n在第一次运算中：选择 i = 0 和 p = 3 ，然后从 nums[0] 减去 3 ，nums 变为 [1,9,6,10] 。\n在第二次运算中：选择 i = 1 和 p = 7 ，然后从 nums[1] 减去 7 ，nums 变为 [1,2,6,10] 。\n第二次运算后，nums 按严格递增顺序排序，因此答案为 true 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,8,11,12]\n<strong>输出：</strong>true\n<strong>解释：</strong>nums 从一开始就按严格递增顺序排序，因此不需要执行任何运算。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,8,3]\n<strong>输出：</strong>false\n<strong>解释：</strong>可以证明，执行运算无法使 nums 按严格递增顺序排序，因此答案是 false 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums.length == n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2602.使数组元素全部相等的最少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "33.52%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>同时给你一个长度为 <code>m</code>&nbsp;的整数数组&nbsp;<code>queries</code>&nbsp;。第 <code>i</code>&nbsp;个查询中，你需要将 <code>nums</code>&nbsp;中所有元素变成&nbsp;<code>queries[i]</code>&nbsp;。你可以执行以下操作&nbsp;<strong>任意</strong>&nbsp;次：</p>\n\n<ul>\n\t<li>将数组里一个元素&nbsp;<strong>增大</strong>&nbsp;或者&nbsp;<strong>减小</strong>&nbsp;<code>1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回一个长度为 <code>m</code>&nbsp;的数组<em>&nbsp;</em><code>answer</code>&nbsp;，其中<em>&nbsp;</em><code>answer[i]</code>是将&nbsp;<code>nums</code>&nbsp;中所有元素变成&nbsp;<code>queries[i]</code>&nbsp;的&nbsp;<strong>最少</strong>&nbsp;操作次数。</p>\n\n<p><strong>注意</strong>，每次查询后，数组变回最开始的值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,1,6,8], queries = [1,5]\n<b>输出：</b>[14,10]\n<b>解释：</b>第一个查询，我们可以执行以下操作：\n- 将 nums[0] 减小 2 次，nums = [1,1,6,8] 。\n- 将 nums[2] 减小 5 次，nums = [1,1,1,8] 。\n- 将 nums[3] 减小 7 次，nums = [1,1,1,1] 。\n第一个查询的总操作次数为 2 + 5 + 7 = 14 。\n第二个查询，我们可以执行以下操作：\n- 将 nums[0] 增大 2 次，nums = [5,1,6,8] 。\n- 将 nums[1] 增大 4 次，nums = [5,5,6,8] 。\n- 将 nums[2] 减小 1 次，nums = [5,5,5,8] 。\n- 将 nums[3] 减小 3 次，nums = [5,5,5,5] 。\n第二个查询的总操作次数为 2 + 4 + 1 + 3 = 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,9,6,3], queries = [10]\n<b>输出：</b>[20]\n<b>解释：</b>我们可以将数组中所有元素都增大到 10 ，总操作次数为 8 + 1 + 4 + 7 = 20 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == queries.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], queries[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2603.收集树中金币",
        "hardRate": "HARD",
        "passRate": "43.61%",
        "problemsUrl": "https://leetcode.cn/problems/collect-coins-in-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/collect-coins-in-a-tree/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的无向无根树，节点编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。给你整数&nbsp;<code>n</code>&nbsp;和一个长度为 <code>n - 1</code>&nbsp;的二维整数数组 <code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示树中节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边。再给你一个长度为 <code>n</code>&nbsp;的数组&nbsp;<code>coins</code>&nbsp;，其中&nbsp;<code>coins[i]</code> 可能为&nbsp;<code>0</code>&nbsp;也可能为&nbsp;<code>1</code>&nbsp;，<code>1</code>&nbsp;表示节点 <code>i</code>&nbsp;处有一个金币。</p>\n\n<p>一开始，你需要选择树中任意一个节点出发。你可以执行下述操作任意次：</p>\n\n<ul>\n\t<li>收集距离当前节点距离为 <code>2</code>&nbsp;以内的所有金币，或者</li>\n\t<li>移动到树中一个相邻节点。</li>\n</ul>\n\n<p>你需要收集树中所有的金币，并且回到出发节点，请你返回最少经过的边数。</p>\n\n<p>如果你多次经过一条边，每一次经过都会给答案加一。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/01/graph-2.png\" style=\"width: 522px; height: 522px;\"></p>\n\n<pre><b>输入：</b>coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]\n<b>输出：</b>2\n<b>解释：</b>从节点 2 出发，收集节点 0 处的金币，移动到节点 3 ，收集节点 5 处的金币，然后移动回节点 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/02/graph-4.png\" style=\"width: 522px; height: 522px;\"></p>\n\n<pre><b>输入：</b>coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]\n<b>输出：</b>2\n<b>解释：</b>从节点 0 出发，收集节点 4 和 3 处的金币，移动到节点 2 处，收集节点 7 处的金币，移动回节点 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == coins.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= coins[i] &lt;= 1</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>edges</code>&nbsp;表示一棵合法的树。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2604.吃掉所有谷子的最短时间",
        "hardRate": "HARD",
        "passRate": "35.20%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-eat-all-grains/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-eat-all-grains/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2605.从两个数字数组里生成最小数字",
        "hardRate": "EASY",
        "passRate": "62.48%",
        "problemsUrl": "https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/solution",
        "problemsDesc": "给你两个只包含 1 到 9 之间数字的数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，每个数组中的元素 <strong>互不相同</strong>&nbsp;，请你返回 <strong>最小</strong> 的数字，两个数组都 <strong>至少</strong> 包含这个数字的某个数位。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [4,1,3], nums2 = [5,7]\n<b>输出：</b>15\n<b>解释：</b>数字 15 的数位 1 在 nums1 中出现，数位 5 在 nums2 中出现。15 是我们能得到的最小数字。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [3,5,2,6], nums2 = [3,1,7]\n<b>输出：</b>3\n<b>解释：</b>数字 3 的数位 3 在两个数组中都出现了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 9</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 9</code></li>\n\t<li>每个数组中，元素 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2606.找到最大开销的子字符串",
        "hardRate": "MEDIUM",
        "passRate": "53.75%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-substring-with-maximum-cost/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-substring-with-maximum-cost/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，一个字符&nbsp;<strong>互不相同</strong>&nbsp;的字符串&nbsp;<code>chars</code>&nbsp;和一个长度与 <code>chars</code>&nbsp;相同的整数数组&nbsp;<code>vals</code>&nbsp;。</p>\n\n<p><strong>子字符串的开销</strong>&nbsp;是一个子字符串中所有字符对应价值之和。空字符串的开销是 <code>0</code>&nbsp;。</p>\n\n<p><strong>字符的价值</strong>&nbsp;定义如下：</p>\n\n<ul>\n\t<li>如果字符不在字符串&nbsp;<code>chars</code>&nbsp;中，那么它的价值是它在字母表中的位置（下标从 <strong>1</strong>&nbsp;开始）。\n\n\t<ul>\n\t\t<li>比方说，<code>'a'</code>&nbsp;的价值为&nbsp;<code>1</code>&nbsp;，<code>'b'</code>&nbsp;的价值为&nbsp;<code>2</code>&nbsp;，以此类推，<code>'z'</code>&nbsp;的价值为&nbsp;<code>26</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li>否则，如果这个字符在 <code>chars</code>&nbsp;中的位置为 <code>i</code>&nbsp;，那么它的价值就是&nbsp;<code>vals[i]</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回字符串 <code>s</code>&nbsp;的所有子字符串中的最大开销。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"adaa\", chars = \"d\", vals = [-1000]\n<b>输出：</b>2\n<b>解释：</b>字符 \"a\" 和 \"d\" 的价值分别为 1 和 -1000 。\n最大开销子字符串是 \"aa\" ，它的开销为 1 + 1 = 2 。\n2 是最大开销。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"abc\", chars = \"abc\", vals = [-1,-1,-1]\n<b>输出：</b>0\n<b>解释：</b>字符 \"a\" ，\"b\" 和 \"c\" 的价值分别为 -1 ，-1 和 -1 。\n最大开销子字符串是 \"\" ，它的开销为 0 。\n0 是最大开销。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>1 &lt;= chars.length &lt;= 26</code></li>\n\t<li><code>chars</code>&nbsp;只包含小写英文字母，且 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>vals.length == chars.length</code></li>\n\t<li><code>-1000 &lt;= vals[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2607.使子数组元素和相等",
        "hardRate": "MEDIUM",
        "passRate": "38.67%",
        "problemsUrl": "https://leetcode.cn/problems/make-k-subarray-sums-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/make-k-subarray-sums-equal/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>arr</code> 和一个整数 <code>k</code> 。数组 <code>arr</code> 是一个循环数组。换句话说，数组中的最后一个元素的下一个元素是数组中的第一个元素，数组中第一个元素的前一个元素是数组中的最后一个元素。</p>\n\n<p>你可以执行下述运算任意次：</p>\n\n<ul>\n\t<li>选中 <code>arr</code> 中任意一个元素，并使其值加上 <code>1</code> 或减去 <code>1</code> 。</li>\n</ul>\n\n<p>执行运算使每个长度为 <code>k</code> 的 <strong>子数组</strong> 的元素总和都相等，返回所需要的最少运算次数。</p>\n\n<p><strong>子数组</strong> 是数组的一个连续部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,4,1,3], k = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>在下标为 1 的元素那里执行一次运算，使其等于 3 。\n执行运算后，数组变为 [1,3,1,3] 。\n- 0 处起始的子数组为 [1, 3] ，元素总和为 4 \n- 1 处起始的子数组为 [3, 1] ，元素总和为 4 \n- 2 处起始的子数组为 [1, 3] ，元素总和为 4 \n- 3 处起始的子数组为 [3, 1] ，元素总和为 4 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,5,5,7], k = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>在下标为 0 的元素那里执行三次运算，使其等于 5 。在下标为 3 的元素那里执行两次运算，使其等于 5 。\n执行运算后，数组变为 [5,5,5,5] 。\n- 0 处起始的子数组为 [5, 5, 5] ，元素总和为 15\n- 1 处起始的子数组为 [5, 5, 5] ，元素总和为 15\n- 2 处起始的子数组为 [5, 5, 5] ，元素总和为 15\n- 3 处起始的子数组为 [5, 5, 5] ，元素总和为 15\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2608.图中的最短环",
        "hardRate": "HARD",
        "passRate": "40.60%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-cycle-in-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-cycle-in-a-graph/solution",
        "problemsDesc": "<p>现有一个含 <code>n</code> 个顶点的 <strong>双向</strong> 图，每个顶点按从 <code>0</code> 到 <code>n - 1</code> 标记。图中的边由二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示顶点 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 之间存在一条边。每对顶点最多通过一条边连接，并且不存在与自身相连的顶点。</p>\n\n<p>返回图中 <strong>最短</strong> 环的长度。如果不存在环，则返回 <code>-1</code> 。</p>\n\n<p><strong>环</strong> 是指以同一节点开始和结束，并且路径中的每条边仅使用一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/04/cropped.png\" style=\"width: 387px; height: 331px;\">\n<pre><strong>输入：</strong>n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]\n<strong>输出：</strong>3\n<strong>解释：</strong>长度最小的循环是：0 -&gt; 1 -&gt; 2 -&gt; 0 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/04/croppedagin.png\" style=\"width: 307px; height: 307px;\">\n<pre><strong>输入：</strong>n = 4, edges = [[0,1],[0,2]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>图中不存在循环\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= 1000</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li>不存在重复的边</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2609.最长平衡子字符串",
        "hardRate": "EASY",
        "passRate": "49.11%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-longest-balanced-substring-of-a-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-longest-balanced-substring-of-a-binary-string/solution",
        "problemsDesc": "<p>给你一个仅由 <code>0</code> 和 <code>1</code> 组成的二进制字符串 <code>s</code> 。<span style=\"\">&nbsp;</span><span style=\"\">&nbsp;</span></p>\n\n<p>如果子字符串中 <strong>所有的<span style=\"\"> </span></strong><code><span style=\"\">0</span></code><strong><span style=\"\"> </span>都在 </strong><code>1</code><strong> 之前</strong> 且其中 <code>0</code> 的数量等于 <code>1</code> 的数量，则认为 <code>s</code> 的这个子字符串是平衡子字符串。请注意，空子字符串也视作平衡子字符串。<span style=\"\">&nbsp;</span></p>\n\n<p>返回&nbsp;<span style=\"\"> </span><code>s</code> 中最长的平衡子字符串长度。</p>\n\n<p>子字符串是字符串中的一个连续字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"01000111\"\n<strong>输出：</strong>6\n<strong>解释：</strong>最长的平衡子字符串是 \"000111\" ，长度为 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"00111\"\n<strong>输出：</strong>4\n<strong>解释：</strong>最长的平衡子字符串是 \"0011\" ，长度为 <span style=\"\">&nbsp;</span>4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"111\"\n<strong>输出：</strong>0\n<strong>解释：</strong>除了空子字符串之外不存在其他平衡子字符串，所以答案为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 50</code></li>\n\t<li><code>'0' &lt;= s[i] &lt;= '1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2610.转换二维数组",
        "hardRate": "MEDIUM",
        "passRate": "85.19%",
        "problemsUrl": "https://leetcode.cn/problems/convert-an-array-into-a-2d-array-with-conditions/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-an-array-into-a-2d-array-with-conditions/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。请你创建一个满足以下条件的二维数组：</p>\n\n<ul>\n\t<li>二维数组应该 <strong>只</strong> 包含数组 <code>nums</code> 中的元素。</li>\n\t<li>二维数组中的每一行都包含 <strong>不同</strong> 的整数。</li>\n\t<li>二维数组的行数应尽可能 <strong>少</strong> 。</li>\n</ul>\n\n<p>返回结果数组。如果存在多种答案，则返回其中任何一种。</p>\n\n<p>请注意，二维数组的每一行上可以存在不同数量的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,4,1,2,3,1]\n<strong>输出：</strong>[[1,3,4,2],[1,3],[1]]\n<strong>解释：</strong>根据题目要求可以创建包含以下几行元素的二维数组：\n- 1,3,4,2\n- 1,3\n- 1\nnums 中的所有元素都有用到，并且每一行都由不同的整数组成，所以这是一个符合题目要求的答案。\n可以证明无法创建少于三行且符合题目要求的二维数组。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>[[4,3,2,1]]\n<strong>解释：</strong>nums 中的所有元素都不同，所以我们可以将其全部保存在二维数组中的第一行。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2611.老鼠和奶酪",
        "hardRate": "MEDIUM",
        "passRate": "58.64%",
        "problemsUrl": "https://leetcode.cn/problems/mice-and-cheese/",
        "solutionsUrl": "https://leetcode.cn/problems/mice-and-cheese/solution",
        "problemsDesc": "<p>有两只老鼠和&nbsp;<code>n</code>&nbsp;块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。</p>\n\n<p>下标为 <code>i</code>&nbsp;处的奶酪被吃掉的得分为：</p>\n\n<ul>\n\t<li>如果第一只老鼠吃掉，则得分为&nbsp;<code>reward1[i]</code>&nbsp;。</li>\n\t<li>如果第二只老鼠吃掉，则得分为&nbsp;<code>reward2[i]</code>&nbsp;。</li>\n</ul>\n\n<p>给你一个正整数数组&nbsp;<code>reward1</code>&nbsp;，一个正整数数组&nbsp;<code>reward2</code>&nbsp;，和一个非负整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>请你返回第一只老鼠恰好吃掉 <code>k</code>&nbsp;块奶酪的情况下，<strong>最大</strong>&nbsp;得分为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2\n<b>输出：</b>15\n<b>解释：</b>这个例子中，第一只老鼠吃掉第 2&nbsp;和 3 块奶酪（下标从 0 开始），第二只老鼠吃掉第 0 和 1 块奶酪。\n总得分为 4 + 4 + 3 + 4 = 15 。\n15 是最高得分。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>reward1 = [1,1], reward2 = [1,1], k = 2\n<b>输出：</b>2\n<b>解释：</b>这个例子中，第一只老鼠吃掉第 0 和 1 块奶酪（下标从 0 开始），第二只老鼠不吃任何奶酪。\n总得分为 1 + 1 = 2 。\n2 是最高得分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == reward1.length == reward2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= reward1[i],&nbsp;reward2[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2612.最少翻转操作数",
        "hardRate": "HARD",
        "passRate": "20.79%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-reverse-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-reverse-operations/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;和一个在范围 <code>[0, n - 1]</code>&nbsp;以内的整数&nbsp;<code>p</code>&nbsp;，它们表示一个长度为 <code>n</code> 且下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>arr</code>&nbsp;，数组中除了下标为&nbsp;<code>p</code>&nbsp;处是 <code>1</code>&nbsp;以外，其他所有数都是 <code>0</code>&nbsp;。</p>\n\n<p>同时给你一个整数数组&nbsp;<code>banned</code>&nbsp;，它包含数组中的一些位置。<code>banned</code>&nbsp;中第&nbsp;<strong>i</strong>&nbsp;个位置表示&nbsp;<code>arr[banned[i]] = 0</code>&nbsp;，题目保证&nbsp;<code>banned[i] != p</code>&nbsp;。</p>\n\n<p>你可以对 <code>arr</code>&nbsp;进行 <strong>若干次</strong>&nbsp;操作。一次操作中，你选择大小为 <code>k</code>&nbsp;的一个 <strong>子数组</strong>&nbsp;，并将它 <b>翻转</b>&nbsp;。在任何一次翻转操作后，你都需要确保 <code>arr</code>&nbsp;中唯一的 <code>1</code>&nbsp;不会到达任何 <code>banned</code>&nbsp;中的位置。换句话说，<code>arr[banned[i]]</code>&nbsp;始终&nbsp;<strong>保持</strong>&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>请你返回一个数组&nbsp;<code>ans</code>&nbsp;，对于<em>&nbsp;</em><code>[0, n - 1]</code>&nbsp;之间的任意下标&nbsp;<code>i</code>&nbsp;，<code>ans[i]</code>&nbsp;是将&nbsp;<code>1</code>&nbsp;放到位置&nbsp;<code>i</code>&nbsp;处的&nbsp;<strong>最少</strong>&nbsp;翻转操作次数，如果无法放到位置&nbsp;<code>i</code>&nbsp;处，此数为&nbsp;<code>-1</code>&nbsp;。</p>\n\n<ul>\n\t<li><strong>子数组</strong>&nbsp;指的是一个数组里一段连续 <strong>非空</strong>&nbsp;的元素序列。</li>\n\t<li>对于所有的 <code>i</code>&nbsp;，<code>ans[i]</code>&nbsp;相互之间独立计算。</li>\n\t<li>将一个数组中的元素 <strong>翻转</strong> 指的是将数组中的值变成 <strong>相反顺序</strong>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4, p = 0, banned = [1,2], k = 4\n<b>输出：</b>[0,-1,-1,1]\n<b>解释：</b><code>k = 4，所以只有一种可行的翻转操作，就是将整个数组翻转。一开始 </code>1<strong> </strong>在位置 0 处，所以将它翻转到位置 0 处需要的操作数为 0 。\n我们不能将 1 翻转到 banned 中的位置，所以位置 1 和 2 处的答案都是 -1 。\n通过一次翻转操作，可以将 1 放到位置 3 处，所以位置 3 的答案是 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, p = 0, banned = [2,4], k = 3\n<b>输出：</b>[0,-1,-1,-1,-1]\n<b>解释：</b>这个例子中 1 一开始在位置 0 处，所以此下标的答案为 0 。\n翻转的子数组长度为 k = 3 ，1 此时在位置 0 处，所以我们可以翻转子数组 [0, 2]，但翻转后的下标 2 在 banned 中，所以不能执行此操作。\n由于 1 没法离开位置 0 ，所以其他位置的答案都是 -1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4, p = 2, banned = [0,1,3], k = 1\n<b>输出：</b>[-1,-1,0,-1]\n<b>解释：</b>这个例子中，我们只能对长度为 1 的子数组执行翻转操作，所以 1 无法离开初始位置。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= p &lt;= n - 1</code></li>\n\t<li><code>0 &lt;= banned.length &lt;= n - 1</code></li>\n\t<li><code>0 &lt;= banned[i] &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= k &lt;= n&nbsp;</code></li>\n\t<li><code>banned[i] != p</code></li>\n\t<li><code>banned</code>&nbsp;中的值 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2613.美数对",
        "hardRate": "HARD",
        "passRate": "41.28%",
        "problemsUrl": "https://leetcode.cn/problems/beautiful-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/beautiful-pairs/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2614.对角线上的质数",
        "hardRate": "EASY",
        "passRate": "33.05%",
        "problemsUrl": "https://leetcode.cn/problems/prime-in-diagonal/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-in-diagonal/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>nums</code> 。</p>\n\n<p>返回位于 <code>nums</code> 至少一条 <strong>对角线</strong> 上的最大 <strong>质数</strong> 。如果任一对角线上均不存在质数，返回<em> 0 。</em></p>\n\n<p>注意：</p>\n\n<ul>\n\t<li>如果某个整数大于 <code>1</code> ，且不存在除 <code>1</code> 和自身之外的正整数因子，则认为该整数是一个质数。</li>\n\t<li>如果存在整数 <code>i</code> ，使得&nbsp;<code>nums[i][i] = val</code> 或者&nbsp;<code>nums[i][nums.length - i - 1]= val</code> ，则认为整数 <code>val</code> 位于 <code>nums</code> 的一条对角线上。</li>\n</ul>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/06/screenshot-2023-03-06-at-45648-pm.png\" style=\"width: 181px; height: 121px;\" /></p>\n\n<p>在上图中，一条对角线是 <strong>[1,5,9]</strong> ，而另一条对角线是<strong> [3,5,7]</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[1,2,3],[5,6,7],[9,10,11]]\n<strong>输出：</strong>11\n<strong>解释：</strong>数字 1、3、6、9 和 11 是所有 \"位于至少一条对角线上\" 的数字。由于 11 是最大的质数，故返回 11 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[1,2,3],[5,17,7],[9,11,10]]\n<strong>输出：</strong>17\n<strong>解释：</strong>数字 1、3、9、10 和 17 是所有满足\"位于至少一条对角线上\"的数字。由于 17 是最大的质数，故返回 17 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 300</code></li>\n\t<li><code>nums.length == nums<sub>i</sub>.length</code></li>\n\t<li><code>1 &lt;= nums<span style=\"\">[i][j]</span>&nbsp;&lt;= 4*10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2615.等值距离和",
        "hardRate": "MEDIUM",
        "passRate": "35.58%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-distances/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-distances/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。现有一个长度等于 <code>nums.length</code> 的数组 <code>arr</code> 。对于满足 <code>nums[j] == nums[i]</code> 且 <code>j != i</code> 的所有 <code>j</code> ，<code>arr[i]</code> 等于所有 <code>|i - j|</code> 之和。如果不存在这样的 <code>j</code> ，则令 <code>arr[i]</code> 等于 <code>0</code> 。</p>\n\n<p>返回数组<em> </em><code>arr</code><em> 。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,1,1,2]\n<strong>输出：</strong>[5,0,3,4,0]\n<strong>解释：</strong>\ni = 0 ，nums[0] == nums[2] 且 nums[0] == nums[3] 。因此，arr[0] = |0 - 2| + |0 - 3| = 5 。 \ni = 1 ，arr[1] = 0 因为不存在值等于 3 的其他下标。\ni = 2 ，nums[2] == nums[0] 且 nums[2] == nums[3] 。因此，arr[2] = |2 - 0| + |2 - 3| = 3 。\ni = 3 ，nums[3] == nums[0] 且 nums[3] == nums[2] 。因此，arr[3] = |3 - 0| + |3 - 2| = 4 。 \ni = 4 ，arr[4] = 0 因为不存在值等于 2 的其他下标。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,5,3]\n<strong>输出：</strong>[0,0,0]\n<strong>解释：</strong>因为 nums 中的元素互不相同，对于所有 i ，都有 arr[i] = 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2616.最小化数对的最大差值",
        "hardRate": "MEDIUM",
        "passRate": "39.02%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>p</code>&nbsp;。请你从&nbsp;<code>nums</code>&nbsp;中找到&nbsp;<code>p</code> 个下标对，每个下标对对应数值取差值，你需要使得这 <code>p</code> 个差值的&nbsp;<strong>最大值</strong>&nbsp;<strong>最小</strong>。同时，你需要确保每个下标在这&nbsp;<code>p</code>&nbsp;个下标对中最多出现一次。</p>\n\n<p>对于一个下标对&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code>&nbsp;，这一对的差值为&nbsp;<code>|nums[i] - nums[j]|</code>&nbsp;，其中&nbsp;<code>|x|</code>&nbsp;表示 <code>x</code>&nbsp;的 <strong>绝对值</strong>&nbsp;。</p>\n\n<p>请你返回 <code>p</code>&nbsp;个下标对对应数值 <strong>最大差值</strong>&nbsp;的 <strong>最小值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [10,1,2,7,1,3], p = 2\n<b>输出：</b>1\n<b>解释：</b>第一个下标对选择 1 和 4 ，第二个下标对选择 2 和 5 。\n最大差值为 max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1 。所以我们返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,2,1,2], p = 1\n<b>输出：</b>0\n<b>解释：</b>选择下标 1 和 3 构成下标对。差值为 |2 - 2| = 0 ，这是最大差值的最小值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= p &lt;= (nums.length)/2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2617.网格图中最少访问的格子数",
        "hardRate": "HARD",
        "passRate": "32.47%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;整数矩阵&nbsp;<code>grid</code>&nbsp;。你一开始的位置在&nbsp;<strong>左上角</strong>&nbsp;格子&nbsp;<code>(0, 0)</code>&nbsp;。</p>\n\n<p>当你在格子&nbsp;<code>(i, j)</code>&nbsp;的时候，你可以移动到以下格子之一：</p>\n\n<ul>\n\t<li>满足 <code>j &lt; k &lt;= grid[i][j] + j</code>&nbsp;的格子&nbsp;<code>(i, k)</code>&nbsp;（向右移动），或者</li>\n\t<li>满足 <code>i &lt; k &lt;= grid[i][j] + i</code>&nbsp;的格子&nbsp;<code>(k, j)</code>&nbsp;（向下移动）。</li>\n</ul>\n\n<p>请你返回到达 <strong>右下角</strong>&nbsp;格子&nbsp;<code>(m - 1, n - 1)</code>&nbsp;需要经过的最少移动格子数，如果无法到达右下角格子，请你返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/25/ex1.png\" style=\"width: 271px; height: 171px;\"></p>\n\n<pre><b>输入：</b>grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]\n<b>输出：</b>4\n<b>解释：</b>上图展示了到达右下角格子经过的 4 个格子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/25/ex2.png\" style=\"width: 271px; height: 171px;\"></p>\n\n<pre><b>输入：</b>grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]\n<b>输出：</b>3\n<strong>解释：</strong>上图展示了到达右下角格子经过的 3 个格子。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/26/ex3.png\" style=\"width: 181px; height: 81px;\"></p>\n\n<pre><b>输入：</b>grid = [[2,1,0],[1,0,0]]\n<b>输出：</b>-1\n<b>解释：</b>无法到达右下角格子。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt; m * n</code></li>\n\t<li><code>grid[m - 1][n - 1] == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2618.检查是否是类的对象实例",
        "hardRate": "MEDIUM",
        "passRate": "33.90%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-object-instance-of-class/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-object-instance-of-class/solution",
        "problemsDesc": "<p>请你编写一个函数，检查给定的值是否是给定类或超类的实例。</p>\n\n<p>可以传递给函数的数据类型没有限制。例如，值或类可能是&nbsp; <code>undefined</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; checkIfInstance(new Date(), Date)\n<b>输出：</b>true\n<strong>解释：</strong>根据定义，Date 构造函数返回的对象是 Date 的一个实例。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; { class Animal {}; class Dog extends Animal {}; return checkIfInstance(new Dog(), Animal); }\n<b>输出：</b>true\n<strong>解释：</strong>\nclass Animal {};\nclass Dog extends Animal {};\ncheckIfInstanceOf(new Dog(), Animal); // true\n\nDog 是 Animal 的子类。因此，Dog 对象同时是 Dog 和 Animal 的实例。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; checkIfInstance(Date, Date)\n<b>输出：</b>false\n<strong>解释：</strong>日期的构造函数在逻辑上不能是其自身的实例。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; checkIfInstance(5, Number)\n<b>输出：</b>true\n<strong>解释：</strong>5 是一个 Number。注意，\"instanceof\" 关键字将返回 false。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2619.数组原型对象的最后一个元素",
        "hardRate": "EASY",
        "passRate": "71.32%",
        "problemsUrl": "https://leetcode.cn/problems/array-prototype-last/",
        "solutionsUrl": "https://leetcode.cn/problems/array-prototype-last/solution",
        "problemsDesc": "<p>请你编写一段代码实现一个数组方法，使任何数组都可以调用 <code>array.last()</code> 方法，这个方法将返回数组最后一个元素。如果数组中没有元素，则返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>你可以假设数组是 <code>JSON.parse</code> 的输出结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [null, {}, 3]\n<b>输出：</b>3\n<b>解释</b>：调用 nums.last() 后返回最后一个元素： 3。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre>\n<b>输入：</b>nums = []\n<b>输出：</b>-1\n<strong>解释：</strong>因为此数组没有元素，所以应该返回 -1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2620.计数器",
        "hardRate": "EASY",
        "passRate": "81.01%",
        "problemsUrl": "https://leetcode.cn/problems/counter/",
        "solutionsUrl": "https://leetcode.cn/problems/counter/solution",
        "problemsDesc": "<p>请你编写并返回一个&nbsp;<strong>计数器&nbsp;</strong>函数，它接收一个整型参数 n 。这个&nbsp;<strong>计数器&nbsp;</strong>函数最初返回 n，每次调用它时返回前一个值加 1 的值 ( <code>n</code> ,&nbsp; <code>n + 1</code> ,&nbsp; <code>n + 2</code> ，等等)。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\nn = 10 \n[\"call\",\"call\",\"call\"]\n<b>输出：</b>[10,11,12]\n<strong>解释：\n</strong>counter() = 10 // 第一次调用 counter()，返回 n。\ncounter() = 11 // 返回上次调用的值加 1。\ncounter() = 12 // 返回上次调用的值加 1。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\nn = -2\n[\"call\",\"call\",\"call\",\"call\",\"call\"]\n<b>输出：</b>[-2,-1,0,1,2]\n<b>解释：</b>counter() 最初返回 -2。然后在每个后续调用后增加 1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-1000<sup>&nbsp;</sup>&lt;= n &lt;= 1000</code></li>\n\t<li><code>最多对 counter() 进行 1000 次调用</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2621.睡眠函数",
        "hardRate": "EASY",
        "passRate": "84.40%",
        "problemsUrl": "https://leetcode.cn/problems/sleep/",
        "solutionsUrl": "https://leetcode.cn/problems/sleep/solution",
        "problemsDesc": "<p>请你编写一个异步函数，它接收一个正整数参数 <code>millis</code>&nbsp;，并休眠这么多毫秒。要求此函数可以解析任何值。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>millis = 100\n<b>输出：</b>100\n<b>解释：</b>\n在 100ms 后此异步函数执行完时返回一个 Promise 对象\nlet t = Date.now();\nsleep(100).then(() =&gt; {\n  console.log(Date.now() - t); // 100\n});\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre>\n<b>输入：</b>millis = 200\n<b>输出：</b>200\n<b>解释：</b>在 200ms 后函数执行完时返回一个 Promise 对象\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 &lt;= millis &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2622.有时间限制的缓存",
        "hardRate": "MEDIUM",
        "passRate": "54.80%",
        "problemsUrl": "https://leetcode.cn/problems/cache-with-time-limit/",
        "solutionsUrl": "https://leetcode.cn/problems/cache-with-time-limit/solution",
        "problemsDesc": "<p>编写一个类，它允许获取和设置键-值对，并且每个键都有一个&nbsp;<strong>过期时间</strong>&nbsp;。</p>\n\n<p>该类有三个公共方法：</p>\n\n<p><code>set(key, value, duration)</code>&nbsp;：接收参数为整型键 <code>key</code> 、整型值 <code>value</code> 和以毫秒为单位的持续时间 <code>duration</code> 。一旦 <code>duration</code>&nbsp;到期后，这个键就无法访问。如果相同的未过期键已经存在，该方法将返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。如果该键已经存在，则它的值和持续时间都应该被覆盖。</p>\n\n<p><code>get(key)</code>&nbsp;：如果存在一个未过期的键，它应该返回这个键相关的值。否则返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p><code>count()</code>&nbsp;：返回未过期键的总数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong> \n[\"TimeLimitedCache\", \"set\", \"get\", \"count\", \"get\"]\n[[], [1, 42, 100], [1], [], [1]]\n[0, 0, 50, 50, 150]\n<strong>输出：</strong> [null, false, 42, 1, -1]\n<strong>解释：</strong>\n在 t=0 时，缓存被构造。\n在 t=0 时，添加一个键值对 (1: 42) ，过期时间为 100ms 。因为该值不存在，因此返回false。\n在 t=50 时，请求 key=1 并返回值 42。\n在 t=50 时，调用 count() ，缓存中有一个未过期的键。\n在 t=100 时，key=1 到期。\n在 t=150 时，调用 get(1) ，返回 -1，因为缓存是空的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"TimeLimitedCache\", \"set\", \"set\", \"get\", \"get\", \"get\", \"count\"]\n[[], [1, 42, 50], [1, 50, 100], [1], [1], [1], []]\n[0, 0, 40, 50, 120, 200, 250]\n<strong>输出：</strong> [null, false, true, 50, 50, -1]\n<strong>解释：</strong>\n在 t=0 时，缓存被构造。\n在 t=0 时，添加一个键值对 (1: 42) ，过期时间为 50ms。因为该值不存在，因此返回false。\n当 t=40 时，添加一个键值对 (1: 50) ，过期时间为 100ms。因为一个未过期的键已经存在，返回 true 并覆盖这个键的旧值。\n在 t=50 时，调用 get(1) ，返回 50。\n在 t=120 时，调用 get(1) ，返回 50。\n在 t=140 时，key=1 过期。\n在 t=200 时，调用 get(1) ，但缓存为空，因此返回 -1。\n在 t=250 时，count() 返回0 ，因为缓存是空的，没有未过期的键。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= key &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= value &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= duration &lt;= 1000</code></li>\n\t<li><code>方法调用总数不会超过100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2623.记忆函数",
        "hardRate": "MEDIUM",
        "passRate": "60.34%",
        "problemsUrl": "https://leetcode.cn/problems/memoize/",
        "solutionsUrl": "https://leetcode.cn/problems/memoize/solution",
        "problemsDesc": "<p>请你编写一个函数，它接收另一个函数作为输入，并返回该函数的 <strong>记忆化</strong> 后的结果。</p>\n\n<p><strong>记忆函数</strong> 是一个对于相同的输入永远不会被调用两次的函数。相反，它将返回一个缓存值。</p>\n\n<p>你可以假设有 <strong>3</strong> 个可能的输入函数：<code>sum</code> 、<code>fib</code> 和 <code>factorial</code> 。</p>\n\n<ul>\n\t<li>&nbsp;<code>sum</code> 接收两个整型参数 <code>a</code> 和 <code>b</code> ，并返回 <code>a + b</code> 。</li>\n\t<li>&nbsp;<code>fib</code> 接收一个整型参数&nbsp;<code>n</code> ，如果 <code>n &lt;= 1</code> 则返回 <code>1</code>，否则返回 <code>fib (n - 1) + fib (n - 2)</code>。</li>\n\t<li>&nbsp;<code>factorial</code> 接收一个整型参数 <code>n</code> ，如果 <code>n &lt;= 1</code> 则返回&nbsp;&nbsp;<code>1</code>&nbsp;，否则返回 <code>factorial(n - 1) * n</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n\"sum\"\n[\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\n[[2,2],[2,2],[],[1,2],[]]\n<strong>输出：</strong>\n[4,4,1,3,2]\n\n<strong>解释：</strong>\nconst sum = (a, b) =&gt; a + b;\nconst memoizedSum = memoize(sum);\nmemoizedSum (2, 2);// 返回 4。sum() 被调用，因为之前没有使用参数 (2, 2) 调用过。\nmemoizedSum (2, 2);// 返回 4。没有调用 sum()，因为前面有相同的输入。\n//总调用数： 1\nmemoizedSum(1、2);// 返回 3。sum() 被调用，因为之前没有使用参数 (1, 2) 调用过。\n//总调用数： 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：\n</strong>\"factorial\"\n[\"call\",\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\n[[2],[3],[2],[],[3],[]]\n<strong>输出：</strong>\n[2,6,2,2,6,2]\n\n<strong>解释：</strong>\nconst factorial = (n) =&gt; (n &lt;= 1) ? 1 : (n * factorial(n - 1));\nconst memoFactorial = memoize(factorial);\nmemoFactorial(2); // 返回 2。\nmemoFactorial(3); // 返回 6。\nmemoFactorial(2); // 返回 2。 没有调用 factorial()，因为前面有相同的输入。\n// 总调用数：2\nmemoFactorial(3); // 返回 6。 没有调用 factorial()，因为前面有相同的输入。\n// 总调用数：2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：\n</strong>\"fib\"\n[\"call\",\"getCallCount\"]\n[[5],[]]\n<strong>输出：</strong>\n[8,1]\n\n<strong>解释：\n</strong>fib(5) = 8\n// 总调用数：1\n\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= a, b &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>at most 10<sup>5</sup>&nbsp;function calls</code></li>\n\t<li><code>at most 10<sup>5</sup>&nbsp;attempts to access callCount</code></li>\n\t<li><code>input function is sum, fib, or factorial</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2624.蜗牛排序",
        "hardRate": "MEDIUM",
        "passRate": "62.40%",
        "problemsUrl": "https://leetcode.cn/problems/snail-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/snail-traversal/solution",
        "problemsDesc": "<p>请你编写一段代码为所有数组实现&nbsp;&nbsp;<code>snail(rowsCount，colsCount)</code> 方法，该方法将 1D 数组转换为以蜗牛排序的模式的 2D 数组。无效的输入值应该输出一个空数组。当 <code>rowsCount * colsCount&nbsp;!==</code><code>nums.length</code>&nbsp;时。这个输入被认为是无效的。</p>\n\n<p>蜗牛排序从左上角的单元格开始，从当前数组的第一个值开始。然后，它从上到下遍历第一列，接着移动到右边的下一列，并从下到上遍历它。将这种模式持续下去，每列交替变换遍历方向，直到覆盖整个数组。例如，当给定输入数组&nbsp;&nbsp;<code>[19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15]</code> ，当 <code>rowsCount = 5</code>&nbsp;且&nbsp;<code>colsCount = 4</code> 时，需要输出矩阵如下图所示。注意，矩阵沿箭头方向对应于原数组中数字的顺序</p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"Traversal Diagram\" src=\"https://assets.leetcode.com/uploads/2023/04/10/screen-shot-2023-04-10-at-100006-pm.png\" style=\"width: 275px; height: 343px;\" /></p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>\nnums = [19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15]\nrowsCount = 5\ncolsCount = 4\n<b>输出：</b>\n[\n [19,17,16,15],\n&nbsp;[10,1,14,4],\n&nbsp;[3,2,12,20],\n&nbsp;[7,5,18,11],\n&nbsp;[9,8,6,13]\n]\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre>\n<b>输入：</b>\nnums = [1,2,3,4]\nrowsCount = 1\ncolsCount = 4\n<b>输出：</b>[[1, 2, 3, 4]]\n</pre>\n\n<p><b>示例 3：</b></p>\n\n<pre>\n<b>输入：</b>\nnums = [1,3]\nrowsCount = 2\ncolsCount = 2\n<b>输出：</b>[]\n<strong>Explanation:</strong> 2 * 2 = 4, 且原数组 [1,3] 的长度为 2; 所以，输入是无效的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 250</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= rowsCount &lt;= 250</code></li>\n\t<li><code>1 &lt;= colsCount &lt;= 250</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2625.扁平化嵌套数组",
        "hardRate": "MEDIUM",
        "passRate": "49.99%",
        "problemsUrl": "https://leetcode.cn/problems/flatten-deeply-nested-array/",
        "solutionsUrl": "https://leetcode.cn/problems/flatten-deeply-nested-array/solution",
        "problemsDesc": "<p>请你编写一个函数，它接收一个&nbsp;<strong>多维数组&nbsp;</strong><code>arr</code> 和它的深度 <code>n</code> ，并返回该数组的&nbsp;<strong>扁平化&nbsp;</strong>后的结果。</p>\n\n<p><strong>多维数组&nbsp;</strong>是一种包含整数或其他&nbsp;<strong>多维数组&nbsp;</strong>的递归数据结构。</p>\n\n<p>数组 <strong>扁平化</strong> 是对数组的一种操作，定义是将原数组部分或全部子数组删除，并替换为该子数组中的实际元素。只有当嵌套的数组深度大于 <code>n</code> 时，才应该执行扁平化操作。第一层数组中元素的深度被认为是 0。</p>\n\n<p>请在没有使用内置方法&nbsp;<code>Array.flat</code> 的前提下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\narr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\nn = 0\n<strong>输出</strong>\n[1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\n\n<strong>解释</strong>\n传递深度 n=0 的多维数组将始终得到原始数组。这是因为 子数组(0) 的最小可能的深度不小于 n=0 。因此，任何子数组都不应该被平面化。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入</strong>\narr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\nn = 1\n<strong>输出</strong>\n[1, 2, 3, 4, 5, 6, 7, 8, [9, 10, 11], 12, 13, 14, 15]\n\n<strong>解释</strong>\n以 4 、7 和 13 开头的子数组都被扁平化了，这是因为它们的深度为 0 ， 而 0 小于 1 。然而 [9,10,11] 其深度为 1 ，所以未被扁平化。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入</strong>\narr = [[1, 2, 3], [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\nn = 2\n<strong>输出</strong>\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\n<strong>解释</strong>\n所有子数组的最大深度都为 1 。因此，它们都被扁平化了。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr 的元素个数&nbsp;&lt;=&nbsp;10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= arr 的子数组个数&nbsp;&lt;=&nbsp;10<sup>5</sup></code></li>\n\t<li><code>maxDepth &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= each number &lt;= 1000</code></li>\n\t<li><code><font face=\"monospace\">0 &lt;= n &lt;= 1000</font></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2626.数组归约运算",
        "hardRate": "EASY",
        "passRate": "77.05%",
        "problemsUrl": "https://leetcode.cn/problems/array-reduce-transformation/",
        "solutionsUrl": "https://leetcode.cn/problems/array-reduce-transformation/solution",
        "problemsDesc": "<p>请你编写一个函数，它的参数为一个整数数组&nbsp;<code>nums</code>&nbsp;、一个计算函数&nbsp;<code>fn</code>&nbsp;和初始值&nbsp;<font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">init&nbsp;</span></span></font></font>。返回一个数组&nbsp;<strong>归约后 </strong>的值。</p>\n\n<p>你可以定义一个数组&nbsp;<strong>归约后 </strong>的值，然后应用以下操作： <code>val = fn(init, nums[0])</code>&nbsp;， <code>val = fn(val, nums[1])</code>&nbsp;， <code>val = fn(val, nums[2])</code>&nbsp;，<code>...</code>&nbsp;直到数组中的每个元素都被处理完毕。返回 <code>val</code> 的最终值。</p>\n\n<p>如果数组的长度为 0，它应该返回 <code>init</code>&nbsp;的值。</p>\n\n<p>请你在不使用内置数组方法的&nbsp;<code>Array.reduce</code>&nbsp;前提下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nnums = [1,2,3,4]\nfn = function sum(accum, curr) { return accum + curr; }\ninit = 0\n<strong>输出：</strong>10\n<strong>解释：</strong>\n初始值为 init=0 。\n(0) + nums[0] = 1\n(1) + nums[1] = 3\n(3) + nums[2] = 6\n(6) + nums[3] = 10\nVal 最终值为 10。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong> \nnums = [1,2,3,4]\nfn = function sum(accum, curr) { return accum + curr * curr; }\ninit = 100\n<strong>输出：</strong>130\n<strong>解释：</strong>\n初始值为 init=0 。\n(100) + nums[0]^2 = 101\n(101) + nums[1]^2 = 105\n(105) + nums[2]^2 = 114\n(114) + nums[3]^2 = 130\nVal 最终值为 130。\n</pre>\n\n<p><strong class=\"example\">示例3:</strong></p>\n\n<pre>\n<strong>输入：</strong> \nnums = []\nfn = function sum(accum, curr) { return 0; }\ninit = 25\n<strong>输出：</strong>25\n<b>解释：</b>这是一个空数组，所以返回 init 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= init &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2627.函数防抖",
        "hardRate": "MEDIUM",
        "passRate": "77.18%",
        "problemsUrl": "https://leetcode.cn/problems/debounce/",
        "solutionsUrl": "https://leetcode.cn/problems/debounce/solution",
        "problemsDesc": "<p>请你编写一个函数，接收参数为另一个函数和一个以毫秒为单位的时间 <code>t</code> ，并返回该函数的&nbsp;<b>函数防抖&nbsp;</b>后的结果。</p>\n\n<p><b>函数防抖 </b>方法是一个函数，它的执行被延迟了 <code>t</code> 毫秒，如果在这个时间窗口内再次调用它，它的执行将被取消。你编写的防抖函数也应该接收传递的参数。</p>\n\n<p>例如，假设 <code>t = 50ms</code> ，函数分别在 <code>30ms</code> 、 <code>60ms</code> 和 <code>100ms</code> 时调用。前两个函数调用将被取消，第三个函数调用将在 <code>150ms</code> 执行。如果改为 <code>t = 35ms</code> ，则第一个调用将被取消，第二个调用将在 <code>95ms</code> 执行，第三个调用将在 <code>135ms</code> 执行。</p>\n\n<p><img alt=\"Debounce Schematic\" src=\"https://assets.leetcode.com/uploads/2023/04/08/screen-shot-2023-04-08-at-11048-pm.png\" style=\"width: 800px; height: 242px;\" /></p>\n\n<p>上图展示了了防抖函数是如何转换事件的。其中，每个矩形表示 100ms，反弹时间为 400ms。每种颜色代表一组不同的输入。</p>\n\n<p>请在不使用 lodash 的 <code>_.debounce()</code> 函数的前提下解决该问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\nt = 50\ncalls = [\n&nbsp; {\"t\": 50, inputs: [1]},\n&nbsp; {\"t\": 75, inputs: [2]}\n]\n<b>输出：</b>[{\"t\": 125, inputs: [2]}]\n<strong>解释：</strong>\nlet start = Date.now();\nfunction log(...inputs) { \n&nbsp; console.log([Date.now() - start, inputs ])\n}\nconst dlog = debounce(log, 50);\nsetTimeout(() =&gt; dlog(1), 50);\nsetTimeout(() =&gt; dlog(2), 75);\n\n第一次调用被第二次调用取消，因为第二次调用发生在 100ms 之前\n第二次调用延迟 50ms，在 125ms 执行。输入为 (2)。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\nt = 20\ncalls = [\n&nbsp; {\"t\": 50, inputs: [1]},\n&nbsp; {\"t\": 100, inputs: [2]}\n]\n<b>输出：</b>[{\"t\": 70, inputs: [1]}, {\"t\": 120, inputs: [2]}]\n<strong>解释：</strong>\n第一次调用延迟到 70ms。输入为 (1)。\n第二次调用延迟到 120ms。输入为 (2)。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>\nt = 150\ncalls = [\n&nbsp; {\"t\": 50, inputs: [1, 2]},\n&nbsp; {\"t\": 300, inputs: [3, 4]},\n&nbsp; {\"t\": 300, inputs: [5, 6]}\n]\n<b>输出：</b>[{\"t\": 200, inputs: [1,2]}, {\"t\": 450, inputs: [5, 6]}]\n<strong>解释：</strong>\n第一次调用延迟了 150ms，运行时间为 200ms。输入为 (1, 2)。\n第二次调用被第三次调用取消\n第三次调用延迟了 150ms，运行时间为 450ms。输入为 (5, 6)。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= t &lt;= 1000</code></li>\n\t<li><code>1 &lt;= calls.length &lt;= 10</code></li>\n\t<li><code>0 &lt;= calls[i].t &lt;= 1000</code></li>\n\t<li><code>0 &lt;= calls[i].inputs.length &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2628.完全相等的 JSON 字符串",
        "hardRate": "MEDIUM",
        "passRate": "32.41%",
        "problemsUrl": "https://leetcode.cn/problems/json-deep-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/json-deep-equal/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2629.复合函数",
        "hardRate": "EASY",
        "passRate": "81.21%",
        "problemsUrl": "https://leetcode.cn/problems/function-composition/",
        "solutionsUrl": "https://leetcode.cn/problems/function-composition/solution",
        "problemsDesc": "<p>请你编写一个函数，它接收一个函数数组 <code>[f<sub>1</sub>, f<sub>2</sub>, f<sub>3</sub>，…， f<sub>n</sub>]</code> ，并返回一个新的函数 <code>fn</code>&nbsp;，它是函数数组的 <strong>复合函数</strong> 。</p>\n\n<p><code>[f(x)， g(x)， h(x)]</code> 的 <strong>复合函数</strong> 为 <code>fn(x) = f(g(h(x)))</code>&nbsp;。</p>\n\n<p>一个空函数列表的 <strong>复合函数</strong> 是 <strong>恒等函数</strong> <code>f(x) = x</code> 。</p>\n\n<p>你可以假设数组中的每个函数接受一个整型参数作为输入，并返回一个整型作为输出。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>functions = [x =&gt; x + 1, x =&gt; x * x, x =&gt; 2 * x], x = 4\n<b>输出：</b>65\n<strong>解释：</strong>\n从右向左计算......\nStarting with x = 4.\n2 * (4) = 8\n(8) * (8) = 64\n(64) + 1 = 65\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输出：</b>functions = [x =&gt; 10 * x, x =&gt; 10 * x, x =&gt; 10 * x], x = 1\n<b>输入：</b>1000\n<strong>解释：</strong>\n从右向左计算......\n10 * (1) = 10\n10 * (10) = 100\n10 * (100) = 1000\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>functions = [], x = 42\n<b>输出：</b>42\n<strong>解释：</strong>\n空函数列表的复合函数就是恒等函数</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code><font face=\"monospace\">-1000 &lt;= x &lt;= 1000</font></code></li>\n\t<li><code><font face=\"monospace\">0 &lt;= functions.length &lt;= 1000</font></code></li>\n\t<li><font face=\"monospace\"><code>所有函数都接受并返回一个整型</code></font></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2630.记忆函数 II",
        "hardRate": "HARD",
        "passRate": "41.69%",
        "problemsUrl": "https://leetcode.cn/problems/memoize-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/memoize-ii/solution",
        "problemsDesc": "<p>现给定一个函数 <code>fn</code> ，返回该函数的一个 <strong>记忆化</strong> 版本。</p>\n\n<p>一个 <strong>记忆化</strong> 的函数是一个函数，它不会被相同的输入调用两次。而是会返回一个缓存的值。</p>\n\n<p>函数 <code>fn</code> 可以是任何函数，对它所接受的值类型没有任何限制。如果两个输入值在 JavaScript 中使用 <code>===</code>&nbsp;运算符比较时相等，则它们被视为相同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong> \ngetInputs = () =&gt; [[2,2],[2,2],[1,2]]\nfn = function (a, b) { return a + b; }\n<b>输出：</b>[{\"val\":4,\"calls\":1},{\"val\":4,\"calls\":1},{\"val\":3,\"calls\":2}]\n<strong>解释：</strong>\nconst inputs = getInputs();\nconst memoized = memoize(fn);\nfor (const arr of inputs) {\n  memoized(...arr);\n}\n\n对于参数为 (2, 2) 的输入: 2 + 2 = 4，需要调用 fn() 。\n对于参数为 (2, 2) 的输入: 2 + 2 = 4，这些输入之前已经出现过，因此不需要再次调用 fn()。\n对于参数为 (1, 2) 的输入: 1 + 2 = 3，需要再次调用 fn()，总共调用了 2 次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\ngetInputs = () =&gt; [[{},{}],[{},{}],[{},{}]] \nfn = function (a, b) { return a + b; }\n<b>输出：</b>[{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":2},{\"val\":{},\"calls\":3}]\n<strong>解释：</strong>\n将两个空对象合并总是会得到一个空对象。尽管看起来应该缓存命中并只调用一次 <code>fn()</code>，但是这些空对象彼此之间都不是 <code>===</code> 相等的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong> \ngetInputs = () =&gt; { const o = {}; return [[o,o],[o,o],[o,o]]; }\nfn = function (a, b) { return ({...a, ...b}); }\n<b>输出：</b>[{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":1}]\n<strong>解释：</strong>\n将两个空对象合并总是会得到一个空对象。因为传入的每个对象都是相同的，所以第二个和第三个函数调用都会命中缓存。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= inputs.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= inputs.flat().length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>inputs[i][j] != NaN</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2631.分组",
        "hardRate": "MEDIUM",
        "passRate": "79.58%",
        "problemsUrl": "https://leetcode.cn/problems/group-by/",
        "solutionsUrl": "https://leetcode.cn/problems/group-by/solution",
        "problemsDesc": "<p>请你编写一段可应用于所有数组的代码，使任何数组调用 <code>array. groupBy(fn)</code> 方法时，它返回对该数组 <strong>分组后</strong> 的结果。</p>\n\n<p>数组 <strong>分组</strong> 是一个对象，其中的每个键都是 <code>fn(arr[i])</code> 的输出的一个数组，该数组中含有原数组中具有该键的所有项。</p>\n\n<p>提供的回调函数 <code>fn</code> 将接受数组中的项并返回一个字符串类型的键。</p>\n\n<p>每个值列表的顺序应该与元素在数组中出现的顺序相同。任何顺序的键都是可以接受的。</p>\n\n<p>请在不使用 lodash 的&nbsp;<code>_.groupBy</code> 函数的前提下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\narray = [\n&nbsp; {\"id\":\"1\"},\n&nbsp; {\"id\":\"1\"},\n&nbsp; {\"id\":\"2\"}\n], \nfn = function (item) { \n&nbsp; return item.id; \n}\n<b>输出：</b>\n{ \n&nbsp; \"1\": [{\"id\": \"1\"}, {\"id\": \"1\"}], &nbsp; \n&nbsp; \"2\": [{\"id\": \"2\"}] \n}\n<strong>解释：</strong>\n输出来自函数 array.groupBy(fn)。\n分组选择方法是从数组中的每个项中获取 \"id\" 。\n有两个 \"id\" 为 1 的对象。所以将这两个对象都放在第一个数组中。\n有一个 \"id\" 为 2 的对象。所以该对象被放到第二个数组中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\narray = [\n&nbsp; [1, 2, 3],\n&nbsp; [1, 3, 5],\n&nbsp; [1, 5, 9]\n]\nfn = function (list) { \n&nbsp; return String(list[0]); \n}\n<b>输出：</b>\n{ \n&nbsp; \"1\": [[1, 2, 3], [1, 3, 5], [1, 5, 9]] \n}\n<strong>解释：</strong>\n数组可以是任何类型的。在本例中，分组选择方法是将键定义为数组中的第一个元素。\n所有数组的第一个元素都是1，所以它们被组合在一起。\n{\n  \"1\": [[1, 2, 3], [1, 3, 5], [1, 5, 9]]\n}\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输出：</b>\narray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfn = function (n) { \n&nbsp; return String(n &gt; 5);\n}\n<strong>输入：</strong>\n{\n&nbsp; \"true\": [6, 7, 8, 9, 10],\n&nbsp; \"false\": [1, 2, 3, 4, 5]\n}\n<strong>解释：</strong>\n分组选择方法是根据每个数字是否大于 5 来分割数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= array.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>fn 返回一个字符串</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2632.柯里化",
        "hardRate": "MEDIUM",
        "passRate": "81.42%",
        "problemsUrl": "https://leetcode.cn/problems/curry/",
        "solutionsUrl": "https://leetcode.cn/problems/curry/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2633.将对象转换为 JSON 字符串",
        "hardRate": "MEDIUM",
        "passRate": "57.14%",
        "problemsUrl": "https://leetcode.cn/problems/convert-object-to-json-string/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-object-to-json-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2634.过滤数组中的元素",
        "hardRate": "EASY",
        "passRate": "70.74%",
        "problemsUrl": "https://leetcode.cn/problems/filter-elements-from-array/",
        "solutionsUrl": "https://leetcode.cn/problems/filter-elements-from-array/solution",
        "problemsDesc": "<p>给定一个整数数组&nbsp;<code>arr</code> 和一个过滤函数 <code>fn</code>，并返回一个过滤后的数组 <code>filteredArr</code> 。</p>\n\n<p><code>fn</code> 函数接受一个或两个参数：</p>\n\n<ul>\n\t<li><code>arr[i]</code> - <code>arr</code> 中的数字</li>\n\t<li><code>i</code> - <code>arr[i]</code> 的索引</li>\n</ul>\n\n<p><code>filteredArr</code> 应该只包含使表达式 <code>fn(arr[i], i)</code> 的值为 <strong>真值</strong> 的 <code>arr</code> 中的元素。<strong>真值</strong> 是指 <code>Boolean(value)</code>&nbsp;返回参数为&nbsp;<code>true</code> 的值。</p>\n\n<p>请在不使用内置的 Array.filter 方法的情况下解决该问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,10,20,30], fn = function greaterThan10(n) { return n &gt; 10; }\n<b>输出：</b> [20,30]\n<b>解释：</b>\nconst newArray = filter(arr, fn); // [20, 30]\n过滤函数过滤掉不大于 10 的值</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [1,2,3], fn = function firstIndex(n, i) { return i === 0; }\n<b>输出：</b>[1]\n<strong>解释：</strong>\n过滤函数 fn 也可以接受每个元素的索引\n在这种情况下，过滤函数删除索引不为 0 的元素\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [-2,-1,0,1,2], fn = function plusOne(n) { return n + 1 }\n<b>输出：</b>[-2,0,1,2]\n<strong>解释：</strong>\n像 0 这样的假值应被过滤掉\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code><font face=\"monospace\">-10<sup>9</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>9</sup></font></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2635.转换数组中的每个元素",
        "hardRate": "EASY",
        "passRate": "73.66%",
        "problemsUrl": "https://leetcode.cn/problems/apply-transform-over-each-element-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/apply-transform-over-each-element-in-array/solution",
        "problemsDesc": "<p>编写一个函数，这个函数接收一个整数数组&nbsp;<code>arr</code> 和一个映射函数&nbsp; <code>fn</code>&nbsp;，通过该映射函数返回一个新的数组。</p>\n\n<p>返回数组的创建语句应为 <code>returnedArray[i] = fn(arr[i], i)</code>&nbsp;。</p>\n\n<p>请你在不使用内置方法&nbsp;<code>Array.map</code>&nbsp;的前提下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3], fn = function plusone(n) { return n + 1; }\n<strong>输出：</strong>[2,3,4]\n<strong>解释： </strong>\nconst newArray = map(arr, plusone); // [2,3,4]\n此映射函数返回值是将数组中每个元素的值加 1。\n</pre>\n\n<p><strong class=\"example\">示例</strong><strong class=\"example\"> 2:</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3], fn = function plusI(n, i) { return n + i; }\n<strong>输出：</strong>[1,3,5]\n<strong>解释：</strong>此映射函数返回值根据输入数组索引增加每个值。\n</pre>\n\n<p><strong class=\"example\">示例&nbsp;3:</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [10,20,30], fn = function constant() { return 42; }\n<strong>输出：</strong>[42,42,42]\n<strong>解释：</strong>此映射函数返回值恒为 42。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code><font face=\"monospace\">-10<sup>9</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>9</sup></font></code></li>\n\t<li><font face=\"monospace\"><code>fn 返回一个数</code></font></li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​​​​</span></span></span>",
        "isPlus": false
    },
    {
        "problemsName": " 2636.Promise 对象池",
        "hardRate": "MEDIUM",
        "passRate": "61.80%",
        "problemsUrl": "https://leetcode.cn/problems/promise-pool/",
        "solutionsUrl": "https://leetcode.cn/problems/promise-pool/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2637.有时间限制的 Promise 对象",
        "hardRate": "EASY",
        "passRate": "61.06%",
        "problemsUrl": "https://leetcode.cn/problems/promise-time-limit/",
        "solutionsUrl": "https://leetcode.cn/problems/promise-time-limit/solution",
        "problemsDesc": "<p>请你编写一个函数，它接受一个异步函数 <code>fn</code>&nbsp;和一个以毫秒为单位的时间 <code>t</code>。它应根据限时函数返回一个有 <strong>限时</strong> 效果的函数。函数 <code>fn</code> 接受提供给 <strong>限时</strong> 函数的参数。</p>\n\n<p><strong>限时</strong> 函数应遵循以下规则：</p>\n\n<ul>\n\t<li>如果 <code>fn</code> 在 <code>t</code> 毫秒的时间限制内完成，<strong>限时</strong> 函数应返回结果。</li>\n\t<li>如果 <code>fn</code> 的执行超过时间限制，<strong>限时&nbsp;</strong>函数应拒绝并返回字符串 <code>\"Time Limit Exceeded\"</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>\nfn = async (n) =&gt; { \n&nbsp; await new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp; return n * n; \n}\ninputs = [5]\nt = 50\n<b>输出：</b>{\"rejected\":\"Time Limit Exceeded\",\"time\":50}\n<b>解释：</b>\nconst limited = timeLimit(fn, t)\nconst start = performance.now()\nlet result;\ntry {\n&nbsp; &nbsp;const res = await limited(...inputs)\n&nbsp; &nbsp;result = {\"resolved\": res, \"time\": Math.floor(performance.now() - start)};\n} catch (err) {\n&nbsp;  result = {\"rejected\": err, \"time\": Math.floor(performance.now() - start)};\n}\nconsole.log(result) // 输出结果\n<b>\n</b>提供的函数设置在 100ms 后执行完成，但是设置的超时时间为 50ms，所以在 t=50ms 时拒绝因为达到了超时时间。\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre>\n<b>输入：</b>\nfn = async (n) =&gt; { \n&nbsp; await new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp; return n * n; \n}\ninputs = [5]\nt = 150\n<b>输出：</b>{\"resolved\":25,\"time\":100}\n<b>解释：</b>\n在 t=100ms 时执行 5*5=25 ，没有达到超时时间。\n</pre>\n\n<p><b>示例 3：</b></p>\n\n<pre>\n<b>输入：</b>\nfn = async (a, b) =&gt; { \n&nbsp; await new Promise(res =&gt; setTimeout(res, 120)); \n&nbsp; return a + b; \n}\ninputs = [5,10]\nt = 150\n<b>输出：</b>{\"resolved\":15,\"time\":120}\n<b>解释：\n</b>在 t=120ms 时执行 5+10=15，没有达到超时时间。\n</pre>\n\n<p><b>示例 4：</b></p>\n\n<pre>\n<b>输入：</b>\nfn = async () =&gt; { \n&nbsp; throw \"Error\";\n}\ninputs = []\nt = 1000\n<b>输出：</b>{\"rejected\":\"Error\",\"time\":0}\n<b>解释：</b>\n此函数始终丢出 Error</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>0 &lt;= inputs.length &lt;= 10</code></li>\n\t<li><code>0 &lt;= t &lt;= 1000</code></li>\n\t<li><code>fn 返回一个 Promise 对象</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2638.统计 K-Free 子集的总数",
        "hardRate": "MEDIUM",
        "passRate": "58.27%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-k-free-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-k-free-subsets/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2639.查询网格图中每一列的宽度",
        "hardRate": "EASY",
        "passRate": "76.16%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-width-of-columns-of-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-width-of-columns-of-a-grid/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;整数矩阵&nbsp;<code>grid</code>&nbsp;。矩阵中某一列的宽度是这一列数字的最大 <strong>字符串长度</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，如果&nbsp;<code>grid = [[-10], [3], [12]]</code>&nbsp;，那么唯一一列的宽度是&nbsp;<code>3</code>&nbsp;，因为&nbsp;<code>-10</code>&nbsp;的字符串长度为&nbsp;<code>3</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回一个大小为 <code>n</code>&nbsp;的整数数组&nbsp;<code>ans</code>&nbsp;，其中&nbsp;<code>ans[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;列的宽度。</p>\n\n<p>一个有 <code>len</code>&nbsp;个数位的整数 <code>x</code>&nbsp;，如果是非负数，那么&nbsp;<strong>字符串</strong><strong>长度</strong>&nbsp;为&nbsp;<code>len</code>&nbsp;，否则为&nbsp;<code>len + 1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>grid = [[1],[22],[333]]\n<b>输出：</b>[3]\n<b>解释：</b>第 0 列中，333 字符串长度为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>grid = [[-15,1,3],[15,7,12],[5,6,-2]]\n<b>输出：</b>[3,1,2]\n<b>解释：</b>\n第 0 列中，只有 -15 字符串长度为 3 。\n第 1 列中，所有整数的字符串长度都是 1 。\n第 2 列中，12 和 -2 的字符串长度都为 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100 </code></li>\n\t<li><code>-10<sup>9</sup> &lt;= grid[r][c] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2640.一个数组所有前缀的分数",
        "hardRate": "MEDIUM",
        "passRate": "79.45%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-score-of-all-prefixes-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-score-of-all-prefixes-of-an-array/solution",
        "problemsDesc": "<p>定义一个数组 <code>arr</code>&nbsp;的 <strong>转换数组</strong>&nbsp;<code>conver</code>&nbsp;为：</p>\n\n<ul>\n\t<li><code>conver[i] = arr[i] + max(arr[0..i])</code>，其中&nbsp;<code>max(arr[0..i])</code>&nbsp;是满足 <code>0 &lt;= j &lt;= i</code>&nbsp;的所有&nbsp;<code>arr[j]</code>&nbsp;中的最大值。</li>\n</ul>\n\n<p>定义一个数组 <code>arr</code>&nbsp;的 <strong>分数</strong>&nbsp;为 <code>arr</code>&nbsp;转换数组中所有元素的和。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;，请你返回一个长度为 <code>n</code>&nbsp;的数组<em>&nbsp;</em><code>ans</code>&nbsp;，其中&nbsp;<code>ans[i]</code>是前缀&nbsp;<code>nums[0..i]</code>&nbsp;的分数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,7,5,10]\n<b>输出：</b>[4,10,24,36,56]\n<b>解释：</b>\n对于前缀 [2] ，转换数组为 [4] ，所以分数为 4 。\n对于前缀 [2, 3] ，转换数组为 [4, 6] ，所以分数为 10 。\n对于前缀 [2, 3, 7] ，转换数组为 [4, 6, 14] ，所以分数为 24 。\n对于前缀 [2, 3, 7, 5] ，转换数组为 [4, 6, 14, 12] ，所以分数为 36 。\n对于前缀 [2, 3, 7, 5, 10] ，转换数组为 [4, 6, 14, 12, 20] ，所以分数为 56 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,2,4,8,16]\n<b>输出：</b>[2,4,8,16,32,64]\n<b>解释：</b>\n对于前缀 [1] ，转换数组为 [2] ，所以分数为 2 。\n对于前缀 [1, 1]，转换数组为 [2, 2] ，所以分数为 4 。\n对于前缀 [1, 1, 2]，转换数组为 [2, 2, 4] ，所以分数为 8 。\n对于前缀 [1, 1, 2, 4]，转换数组为 [2, 2, 4, 8] ，所以分数为 16 。\n对于前缀 [1, 1, 2, 4, 8]，转换数组为 [2, 2, 4, 8, 16] ，所以分数为 32 。\n对于前缀 [1, 1, 2, 4, 8, 16]，转换数组为 [2, 2, 4, 8, 16, 32] ，所以分数为 64 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2641.二叉树的堂兄弟节点 II",
        "hardRate": "MEDIUM",
        "passRate": "70.41%",
        "problemsUrl": "https://leetcode.cn/problems/cousins-in-binary-tree-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/cousins-in-binary-tree-ii/solution",
        "problemsDesc": "<p>给你一棵二叉树的根&nbsp;<code>root</code>&nbsp;，请你将每个节点的值替换成该节点的所有 <strong>堂兄弟节点值的和&nbsp;</strong>。</p>\n\n<p>如果两个节点在树中有相同的深度且它们的父节点不同，那么它们互为 <strong>堂兄弟</strong>&nbsp;。</p>\n\n<p>请你返回修改值之后，树的根<em>&nbsp;</em><code>root</code><em>&nbsp;</em>。</p>\n\n<p><strong>注意</strong>，一个节点的深度指的是从树根节点到这个节点经过的边数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/11/example11.png\" style=\"width: 571px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>root = [5,4,9,1,10,null,7]\n<b>输出：</b>[0,0,0,7,7,null,11]\n<b>解释：</b>上图展示了初始的二叉树和修改每个节点的值之后的二叉树。\n- 值为 5 的节点没有堂兄弟，所以值修改为 0 。\n- 值为 4 的节点没有堂兄弟，所以值修改为 0 。\n- 值为 9 的节点没有堂兄弟，所以值修改为 0 。\n- 值为 1 的节点有一个堂兄弟，值为 7 ，所以值修改为 7 。\n- 值为 10 的节点有一个堂兄弟，值为 7 ，所以值修改为 7 。\n- 值为 7 的节点有两个堂兄弟，值分别为 1 和 10 ，所以值修改为 11 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/11/diagram33.png\" style=\"width: 481px; height: 91px;\" /></p>\n\n<pre>\n<b>输入：</b>root = [3,1,2]\n<b>输出：</b>[0,0,0]\n<b>解释：</b>上图展示了初始的二叉树和修改每个节点的值之后的二叉树。\n- 值为 3 的节点没有堂兄弟，所以值修改为 0 。\n- 值为 1 的节点没有堂兄弟，所以值修改为 0 。\n- 值为 2 的节点没有堂兄弟，所以值修改为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目的范围是&nbsp;<code>[1, 10<sup>5</sup>]</code> 。</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2642.设计可以求最短路径的图类",
        "hardRate": "HARD",
        "passRate": "55.87%",
        "problemsUrl": "https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/",
        "solutionsUrl": "https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/solution",
        "problemsDesc": "<p>给你一个有&nbsp;<code>n</code>&nbsp;个节点的&nbsp;<strong>有向带权</strong>&nbsp;图，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。图中的初始边用数组&nbsp;<code>edges</code>&nbsp;表示，其中&nbsp;<code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, edgeCost<sub>i</sub>]</code>&nbsp;表示从&nbsp;<code>from<sub>i</sub></code>&nbsp;到&nbsp;<code>to<sub>i</sub></code>&nbsp;有一条代价为&nbsp;<code>edgeCost<sub>i</sub></code>&nbsp;的边。</p>\n\n<p>请你实现一个&nbsp;<code>Graph</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>Graph(int n, int[][] edges)</code>&nbsp;初始化图有&nbsp;<code>n</code>&nbsp;个节点，并输入初始边。</li>\n\t<li><code>addEdge(int[] edge)</code>&nbsp;向边集中添加一条边，其中<strong>&nbsp;</strong><code>edge = [from, to, edgeCost]</code>&nbsp;。数据保证添加这条边之前对应的两个节点之间没有有向边。</li>\n\t<li><code>int shortestPath(int node1, int node2)</code>&nbsp;返回从节点&nbsp;<code>node1</code>&nbsp;到&nbsp;<code>node2</code>&nbsp;的路径<strong>&nbsp;最小</strong>&nbsp;代价。如果路径不存在，返回&nbsp;<code>-1</code>&nbsp;。一条路径的代价是路径中所有边代价之和。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/11/graph3drawio-2.png\" style=\"width: 621px; height: 191px;\"></p>\n\n<pre><strong>输入：</strong>\n[\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]\n[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\n<b>输出：</b>\n[null, 6, -1, null, 6]\n\n<strong>解释：</strong>\nGraph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\ng.shortestPath(3, 2); // 返回 6 。从 3 到 2 的最短路径如第一幅图所示：3 -&gt; 0 -&gt; 1 -&gt; 2 ，总代价为 3 + 2 + 1 = 6 。\ng.shortestPath(0, 3); // 返回 -1 。没有从 0 到 3 的路径。\ng.addEdge([1, 3, 4]); // 添加一条节点 1 到节点 3 的边，得到第二幅图。\ng.shortestPath(0, 3); // 返回 6 。从 0 到 3 的最短路径为 0 -&gt; 1 -&gt; 3 ，总代价为 2 + 4 = 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= edges.length &lt;= n * (n - 1)</code></li>\n\t<li><code>edges[i].length == edge.length == 3</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub>, from, to, node1, node2 &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= edgeCost<sub>i</sub>, edgeCost &lt;= 10<sup>6</sup></code></li>\n\t<li>图中任何时候都不会有重边和自环。</li>\n\t<li>调用 <code>addEdge</code>&nbsp;至多&nbsp;<code>100</code>&nbsp;次。</li>\n\t<li>调用 <code>shortestPath</code>&nbsp;至多&nbsp;<code>100</code>&nbsp;次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2643.一最多的行",
        "hardRate": "EASY",
        "passRate": "80.04%",
        "problemsUrl": "https://leetcode.cn/problems/row-with-maximum-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/row-with-maximum-ones/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>mat</code> ，请你找出包含最多 <strong>1</strong> 的行的下标（从 <strong>0</strong> 开始）以及这一行中 <strong>1</strong> 的数目。</p>\n\n<p>如果有多行包含最多的 1 ，只需要选择 <strong>行下标最小</strong> 的那一行。</p>\n\n<p>返回一个由行下标和该行中 1 的数量组成的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[0,1],[1,0]]\n<strong>输出：</strong>[0,1]\n<strong>解释：</strong>两行中 1 的数量相同。所以返回下标最小的行，下标为 0 。该行 1 的数量为 1 。所以，答案为 [0,1] 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[0,0,0],[0,1,1]]\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>下标为 1 的行中 1 的数量最多<code>。</code>该行 1 的数量<code>为 2 。所以，答案为</code> [1,2] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[0,0],[1,1],[0,0]]\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>下标为 1 的行中 1 的数量最多。该行 1 的数量<code>为 2 。所以，答案为</code> [1,2] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code>&nbsp;</li>\n\t<li><code>n == mat[i].length</code>&nbsp;</li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code>&nbsp;</li>\n\t<li><code>mat[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2644.找出可整除性得分最大的整数",
        "hardRate": "EASY",
        "passRate": "50.15%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-maximum-divisibility-score/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-maximum-divisibility-score/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和 <code>divisors</code> 。</p>\n\n<p><code>divisors[i]</code> 的 <strong>可整除性得分</strong> 等于满足 <code>nums[j]</code> 能被 <code>divisors[i]</code> 整除的下标 <code>j</code> 的数量。</p>\n\n<p>返回 <strong>可整除性得分</strong> 最大的整数 <code>divisors[i]</code> 。如果有多个整数具有最大得分，则返回数值最小的一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,7,9,3,9], divisors = [5,2,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>divisors 中每个元素的可整除性得分为：\ndivisors[0] 的可整除性得分为 0 ，因为 nums 中没有任何数字能被 5 整除。\ndivisors[1] 的可整除性得分为 1 ，因为 nums[0] 能被 2 整除。 \ndivisors[2] 的可整除性得分为 3 ，因为 nums[2]、nums[3] 和 nums[4] 都能被 3 整除。 \n因此，返回 divisors[2] ，它的可整除性得分最大。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [20,14,21,10], divisors = [5,7,5]\n<strong>输出：</strong>5\n<strong>解释：</strong>divisors 中每个元素的可整除性得分为：\ndivisors[0] 的可整除性得分为 2 ，因为 nums[0] 和 nums[3] 都能被 5 整除。\ndivisors[1] 的可整除性得分为 2 ，因为 nums[1] 和 nums[2] 都能被 7 整除。\ndivisors[2] 的可整除性得分为 2 ，因为 nums[0] 和 nums[3] 都能被5整除。 \n由于 divisors[0]、divisors[1] 和 divisors[2] 的可整除性得分都是最大的，因此，我们返回数值最小的一个，即 divisors[2] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [12], divisors = [10,16]\n<strong>输出：</strong>10\n<strong>解释：</strong>divisors 中每个元素的可整除性得分为：\ndivisors[0] 的可整除性得分为 0 ，因为 nums 中没有任何数字能被 10 整除。\ndivisors[1] 的可整除性得分为 0 ，因为 nums 中没有任何数字能被 16 整除。 \n由于 divisors[0] 和 divisors[1] 的可整除性得分都是最大的，因此，我们返回数值最小的一个，即 divisors[0] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, divisors.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i], divisors[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2645.构造有效字符串的最少插入数",
        "hardRate": "MEDIUM",
        "passRate": "56.35%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-additions-to-make-valid-string/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-additions-to-make-valid-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>word</code> ，你可以向其中任何位置插入 \"a\"、\"b\" 或 \"c\" 任意次，返回使 <code>word</code> <strong>有效</strong> 需要插入的最少字母数。</p>\n\n<p>如果字符串可以由 \"abc\" 串联多次得到，则认为该字符串 <strong>有效</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>word = \"b\"\n<strong>输出：</strong>2\n<strong>解释：</strong>在 \"b\" 之前插入 \"a\" ，在 \"b\" 之后插入 \"c\" 可以得到有效字符串 \"<strong>a</strong>b<strong>c</strong>\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>word = \"aaa\"\n<strong>输出：</strong>6\n<strong>解释：</strong>在每个 \"a\" 之后依次插入 \"b\" 和 \"c\" 可以得到有效字符串 \"a<strong>bc</strong>a<strong>bc</strong>a<strong>bc</strong>\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>word = \"abc\"\n<strong>输出：</strong>0\n<strong>解释：</strong>word 已经是有效字符串，不需要进行修改。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 50</code></li>\n\t<li><code>word</code> 仅由字母 \"a\"、\"b\" 和 \"c\" 组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2646.最小化旅行的价格总和",
        "hardRate": "HARD",
        "passRate": "50.04%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/solution",
        "problemsDesc": "<p>现有一棵无向、无根的树，树中有 <code>n</code> 个节点，按从 <code>0</code> 到 <code>n - 1</code> 编号。给你一个整数 <code>n</code> 和一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示树中节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间存在一条边。</p>\n\n<p>每个节点都关联一个价格。给你一个整数数组 <code>price</code> ，其中 <code>price[i]</code> 是第 <code>i</code> 个节点的价格。</p>\n\n<p>给定路径的 <strong>价格总和</strong> 是该路径上所有节点的价格之和。</p>\n\n<p>另给你一个二维整数数组 <code>trips</code> ，其中 <code>trips[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 表示您从节点 <code>start<sub>i</sub></code> 开始第 <code>i</code> 次旅行，并通过任何你喜欢的路径前往节点 <code>end<sub>i</sub></code> 。</p>\n\n<p>在执行第一次旅行之前，你可以选择一些 <strong>非相邻节点</strong> 并将价格减半。</p>\n\n<p>返回执行所有旅行的最小价格总和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/16/diagram2.png\" style=\"width: 541px; height: 181px;\">\n<pre><strong>输入：</strong>n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\n<strong>输出：</strong>23\n<strong>解释：\n</strong>上图表示将节点 2 视为根之后的树结构。第一个图表示初始树，第二个图表示选择节点 0 、2 和 3 并使其价格减半后的树。\n第 1 次旅行，选择路径 [0,1,3] 。路径的价格总和为 1 + 2 + 3 = 6 。\n第 2 次旅行，选择路径 [2,1] 。路径的价格总和为 2 + 5 = 7 。\n第 3 次旅行，选择路径 [2,1,3] 。路径的价格总和为 5 + 2 + 3 = 10 。\n所有旅行的价格总和为 6 + 7 + 10 = 23 。可以证明，23 是可以实现的最小答案。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/16/diagram3.png\" style=\"width: 456px; height: 111px;\">\n<pre><strong>输入：</strong>n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n上图表示将节点 0 视为根之后的树结构。第一个图表示初始树，第二个图表示选择节点 0 并使其价格减半后的树。 \n第 1 次旅行，选择路径 [0] 。路径的价格总和为 1 。 \n所有旅行的价格总和为 1 。可以证明，1 是可以实现的最小答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>edges</code> 表示一棵有效的树</li>\n\t<li><code>price.length == n</code></li>\n\t<li><code>price[i]</code> 是一个偶数</li>\n\t<li><code>1 &lt;= price[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= trips.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub>, end<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2647.把三角形染成红色",
        "hardRate": "HARD",
        "passRate": "67.31%",
        "problemsUrl": "https://leetcode.cn/problems/color-the-triangle-red/",
        "solutionsUrl": "https://leetcode.cn/problems/color-the-triangle-red/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2648.生成斐波那契数列",
        "hardRate": "EASY",
        "passRate": "82.59%",
        "problemsUrl": "https://leetcode.cn/problems/generate-fibonacci-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/generate-fibonacci-sequence/solution",
        "problemsDesc": "<p>请你编写一个生成器函数，并返回一个可以生成 <strong>斐波那契数列</strong> 的生成器对象。</p>\n\n<p><strong>斐波那契数列</strong> 的递推公式为 <code>X<sub>n</sub>&nbsp;= X<sub>n-1</sub>&nbsp;+ X<sub>n-2</sub></code> 。</p>\n\n<p>这个数列的前几个数字是 <code>0, 1, 1, 2, 3, 5, 8, 13</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>callCount = 5\n<b>输出：</b>[0,1,1,2,3]\n<strong>解释：</strong>\nconst gen = fibGenerator();\ngen.next().value; // 0\ngen.next().value; // 1\ngen.next().value; // 1\ngen.next().value; // 2\ngen.next().value; // 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>callCount = 0\n<strong>输出：</strong>[]\n<b>解释：</b>gen.next() 永远不会被调用，所以什么也不会输出\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= callCount &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2649.嵌套数组生成器",
        "hardRate": "MEDIUM",
        "passRate": "77.10%",
        "problemsUrl": "https://leetcode.cn/problems/nested-array-generator/",
        "solutionsUrl": "https://leetcode.cn/problems/nested-array-generator/solution",
        "problemsDesc": "<p>现给定一个整数的 <strong>多维数组</strong> ，请你返回一个生成器对象，按照&nbsp;<strong>中序遍历</strong> 的顺序逐个生成整数。</p>\n\n<p><strong>多维数组</strong> 是一个递归数据结构，包含整数和其他 <strong>多维数组</strong>。</p>\n\n<p><strong>中序遍历</strong> 是从左到右遍历每个数组，在遇到任何整数时生成它，遇到任何数组时递归应用 <strong>中序遍历</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [[[6]],[1,3],[]]\n<b>输出：</b>[6,1,3]\n<strong>解释：</strong>\nconst generator = inorderTraversal(arr);\ngenerator.next().value; // 6\ngenerator.next().value; // 1\ngenerator.next().value; // 3\ngenerator.next().done; // true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = []\n<b>输出：</b>[]\n<b>解释：</b>输入的多维数组没有任何参数，所以生成器不需要生成任何值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.flat().length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= arr.flat()[i]&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>maxNestingDepth &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2650.设计可取消函数",
        "hardRate": "HARD",
        "passRate": "51.11%",
        "problemsUrl": "https://leetcode.cn/problems/design-cancellable-function/",
        "solutionsUrl": "https://leetcode.cn/problems/design-cancellable-function/solution",
        "problemsDesc": "<p>有时候你会有一个长时间运行的任务，并且你可能希望在它完成之前取消它。为了实现这个目标，请你编写一个名为 <code>cancellable</code> 的函数，它接收一个生成器对象，并返回一个包含两个值的数组：一个 <strong>取消函数</strong> 和一个 <strong>promise</strong> 对象。</p>\n\n<p>你可以假设生成器函数只会生成 promise 对象。你的函数负责将 promise 对象解析的值传回生成器。如果 promise 被拒绝，你的函数应将该错误抛回给生成器。</p>\n\n<p>如果在生成器完成之前调用了取消回调函数，则你的函数应该将错误抛回给生成器。该错误应该是字符串 <code>\"Cancelled\"</code>（而不是一个 <code>Error</code> 对象）。如果错误被捕获，则返回的 promise 应该解析为下一个生成或返回的值。否则，promise 应该被拒绝并抛出该错误。不应执行任何其他代码。</p>\n\n<p>当生成器完成时，您的函数返回的 promise 应该解析为生成器返回的值。但是，如果生成器抛出错误，则返回的 promise 应该拒绝并抛出该错误。</p>\n\n<p>下面是您的代码应如何使用的示例：</p>\n\n<pre>\nfunction* tasks() {\n  const val = yield new Promise(resolve =&gt; resolve(2 + 2));\n  yield new Promise(resolve =&gt; setTimeout(resolve, 100));\n  return val + 1; // calculation shouldn't be done.\n}\nconst [cancel, promise] = cancellable(tasks());\nsetTimeout(cancel, 50);\npromise.catch(console.log); // logs \"Cancelled\" at t=50ms\n</pre>\n\n<p>如果相反， <code>cancel()</code> 没有被调用或者在 <code>t=100ms</code> 之后才被调用，那么 Promise 应被解析为 <code>5</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\ngeneratorFunction = function*() { \n&nbsp; return 42; \n}\ncancelledAt = 100\n<b>输出：</b>{\"resolved\": 42}\n<strong>解释：</strong>\nconst generator = generatorFunction();\nconst [cancel, promise] = cancellable(generator);\nsetTimeout(cancel, 100);\npromise.then(console.log); // 在 t=0ms 解析为 42\n\n该生成器立即生成 42 并完成。因此，返回的 promise 立即解析为 42。请注意，取消已经完成的生成器没有任何作用。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ngeneratorFunction = function*() { \n&nbsp; const msg = yield new Promise(res =&gt; res(\"Hello\")); \n&nbsp; throw `Error: ${msg}`; \n}\ncancelledAt = null\n<b>输出：</b>{\"rejected\": \"Error: Hello\"}\n<strong>解释：</strong>\n一个 Promise 被生成。该函数通过等待 promise 解析并将解析后的值传回生成器来处理它。然后抛出一个错误，这会导致 promise 被同样抛出的错误拒绝。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>\ngeneratorFunction = function*() { \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 200)); \n&nbsp; return \"Success\"; \n}\ncancelledAt = 100\n<b>输出：</b>{\"rejected\": \"Cancelled\"}\n<strong>解释：</strong>\n当函数等待被生成的 promise 解析时，cancel() 被调用。这会导致一个错误消息被发送回生成器。由于这个错误没有被捕获，返回的 promise 会因为这个错误而被拒绝。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ngeneratorFunction = function*() { \n&nbsp; let result = 0; \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 100));\n&nbsp; result += yield new Promise(res =&gt; res(1)); \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp; result += yield new Promise(res =&gt; res(1)); \n&nbsp; return result;\n}\ncancelledAt = null\n<b>输出：</b>{\"resolved\": 2}\n<strong>解释：</strong>\n生成器生成了 4 个 promise 。其中两个 promise 的值被添加到结果中。200ms 后，生成器以值 2 完成，该值被返回的 promise 解析。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<b>输入：</b>\ngeneratorFunction = function*() { \n&nbsp; let result = 0; \n&nbsp; try { \n&nbsp;   yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp;   result += yield new Promise(res =&gt; res(1)); \n&nbsp;   yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp;   result += yield new Promise(res =&gt; res(1)); \n&nbsp; } catch(e) { \n&nbsp;   return result; \n&nbsp; } \n&nbsp; return result; \n}\ncancelledAt = 150\n<b>输出：</b>{\"resolved\": 1}\n<strong>解释：</strong>\n前两个生成的 promise 解析并导致结果递增。然而，在 t=150ms 时，生成器被取消了。发送给生成器的错误被捕获，结果被返回并最终由返回的 promise 解析。\n</pre>\n\n<p><strong>示例 6：</strong></p>\n\n<pre>\n<b>输入：</b>\ngeneratorFunction = function*() { \n&nbsp; try { \n&nbsp;   yield new Promise((resolve, reject) =&gt; reject(\"Promise Rejected\")); \n&nbsp; } catch(e) { \n&nbsp;   let a = yield new Promise(resolve =&gt; resolve(2));\n    let b = yield new Promise(resolve =&gt; resolve(2)); \n&nbsp;   return a + b; \n&nbsp; }; \n}\ncancelledAt = null\n<b>输出：</b>{\"resolved\": 4}\n<strong>解释：</strong>\n第一个生成的 promise 立即被拒绝。该错误被捕获。因为生成器没有被取消，执行继续像往常一样。最终解析为 2 + 2 = 4。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>cancelledAt == null or 0 &lt;= cancelledAt &lt;= 1000</code></li>\n\t<li><code>generatorFunction 返回一个生成器对象</code></li>\n</ul>\n",
        "isPlus": false
    }
]