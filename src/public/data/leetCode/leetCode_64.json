[
    {
        "problemsName": " 3151.马戏团人塔",
        "hardRate": "MEDIUM",
        "passRate": "28.51%",
        "problemsUrl": "https://leetcode.cn/problems/circus-tower-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/circus-tower-lcci/solution",
        "problemsDesc": "<p>有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>height = [65,70,56,75,60,68] weight = [100,150,90,190,95,110]\n<strong>输出：</strong>6\n<strong>解释：</strong>从上往下数，叠罗汉最多能叠 6 层：(56,90), (60,95), (65,100), (68,110), (70,150), (75,190)</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>height.length == weight.length <= 10000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3152.第 k 个数",
        "hardRate": "MEDIUM",
        "passRate": "56.09%",
        "problemsUrl": "https://leetcode.cn/problems/get-kth-magic-number-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/get-kth-magic-number-lcci/solution",
        "problemsDesc": "<p>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入: </strong>k = 5\n\n<strong>输出: </strong>9\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3153.主要元素",
        "hardRate": "EASY",
        "passRate": "56.21%",
        "problemsUrl": "https://leetcode.cn/problems/find-majority-element-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/find-majority-element-lcci/solution",
        "problemsDesc": "<p>数组中占比超过一半的元素称之为主要元素。给你一个<strong> 整数 </strong>数组，找出其中的主要元素。若没有，返回 <code>-1</code> 。请设计时间复杂度为 <code>O(N)</code> 、空间复杂度为 <code>O(1)</code> 的解决方案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,5,9,5,9,5,5,5]\n<strong>输出：</strong>5</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[3,2]\n<strong>输出：</strong>-1</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>[2,2,1,1,1,2,2]\n<strong>输出：</strong>2</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3154.单词距离",
        "hardRate": "MEDIUM",
        "passRate": "73.06%",
        "problemsUrl": "https://leetcode.cn/problems/find-closest-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/find-closest-lcci/solution",
        "problemsDesc": "<p>有个内含单词的超大文本文件，给定任意两个<code>不同的</code>单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"I\",\"am\",\"a\",\"student\",\"from\",\"a\",\"university\",\"in\",\"a\",\"city\"], word1 = \"a\", word2 = \"student\"\n<strong>输出：</strong>1</pre>\n\n<p>提示：</p>\n\n<ul>\n\t<li><code>words.length &lt;= 100000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3155.BiNode",
        "hardRate": "EASY",
        "passRate": "63.91%",
        "problemsUrl": "https://leetcode.cn/problems/binode-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/binode-lcci/solution",
        "problemsDesc": "<p>二叉树数据结构<code>TreeNode</code>可用来表示单向链表（其中<code>left</code>置空，<code>right</code>为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。</p>\n\n<p>返回转换后的单向链表的头节点。</p>\n\n<p><strong>注意：</strong>本题相对原题稍作改动</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong> [4,2,5,1,3,null,6,0]\n<strong>输出：</strong> [0,null,1,null,2,null,3,null,4,null,5,null,6]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>节点数量不会超过 100000。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3156.恢复空格",
        "hardRate": "MEDIUM",
        "passRate": "55.42%",
        "problemsUrl": "https://leetcode.cn/problems/re-space-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/re-space-lcci/solution",
        "problemsDesc": "<p>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子<code>&quot;I reset the computer. It still didn&rsquo;t boot!&quot;</code>已经变成了<code>&quot;iresetthecomputeritstilldidntboot&quot;</code>。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典<code>dictionary</code>，不过，有些词没在词典里。假设文章用<code>sentence</code>表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</p>\n\n<p><strong>注意：</strong>本题相对原题稍作改动，只需返回未识别的字符数</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>\ndictionary = [&quot;looked&quot;,&quot;just&quot;,&quot;like&quot;,&quot;her&quot;,&quot;brother&quot;]\nsentence = &quot;jesslookedjustliketimherbrother&quot;\n<strong>输出：</strong> 7\n<strong>解释：</strong> 断句后为&quot;<strong>jess</strong> looked just like <strong>tim</strong> her brother&quot;，共7个未识别字符。\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= len(sentence) &lt;= 1000</code></li>\n\t<li><code>dictionary</code>中总字符数不超过 150000。</li>\n\t<li>你可以认为<code>dictionary</code>和<code>sentence</code>中只包含小写字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3157.最小K个数",
        "hardRate": "MEDIUM",
        "passRate": "58.89%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-k-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-k-lcci/solution",
        "problemsDesc": "<p>设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong> arr = [1,3,5,7,2,4,6,8], k = 4\n<strong>输出：</strong> [1,2,3,4]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= len(arr) &lt;= 100000</code></li>\n\t<li><code>0 &lt;= k &lt;= min(100000, len(arr))</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3158.最长单词",
        "hardRate": "MEDIUM",
        "passRate": "40.85%",
        "problemsUrl": "https://leetcode.cn/problems/longest-word-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-word-lcci/solution",
        "problemsDesc": "<p>给定一组单词<code>words</code>，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong> [&quot;cat&quot;,&quot;banana&quot;,&quot;dog&quot;,&quot;nana&quot;,&quot;walk&quot;,&quot;walker&quot;,&quot;dogwalker&quot;]\n<strong>输出：</strong> &quot;dogwalker&quot;\n<strong>解释：</strong> &quot;dogwalker&quot;可由&quot;dog&quot;和&quot;walker&quot;组成。\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= len(words) &lt;= 200</code></li>\n\t<li><code>1 &lt;= len(words[i]) &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3159.按摩师",
        "hardRate": "EASY",
        "passRate": "51.04%",
        "problemsUrl": "https://leetcode.cn/problems/the-masseuse-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/the-masseuse-lcci/solution",
        "problemsDesc": "<p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>\n\n<p><strong>注意：</strong>本题相对原题稍作改动</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong> [1,2,3,1]\n<strong>输出：</strong> 4\n<strong>解释：</strong> 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong> [2,7,9,3,1]\n<strong>输出：</strong> 12\n<strong>解释：</strong> 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong> [2,1,4,5,3,1,1,3]\n<strong>输出：</strong> 12\n<strong>解释：</strong> 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3160.多次搜索",
        "hardRate": "MEDIUM",
        "passRate": "44.75%",
        "problemsUrl": "https://leetcode.cn/problems/multi-search-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/multi-search-lcci/solution",
        "problemsDesc": "<p>给定一个较长字符串<code>big</code>和一个包含较短字符串的数组<code>smalls</code>，设计一个方法，根据<code>smalls</code>中的每一个较短字符串，对<code>big</code>进行搜索。输出<code>smalls</code>中的字符串在<code>big</code>里出现的所有位置<code>positions</code>，其中<code>positions[i]</code>为<code>smalls[i]</code>出现的所有位置。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>\nbig = &quot;mississippi&quot;\nsmalls = [&quot;is&quot;,&quot;ppi&quot;,&quot;hi&quot;,&quot;sis&quot;,&quot;i&quot;,&quot;ssippi&quot;]\n<strong>输出：</strong> [[1,4],[8],[],[3],[1,4,7,10],[5]]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= len(big) &lt;= 1000</code></li>\n\t<li><code>0 &lt;= len(smalls[i]) &lt;= 1000</code></li>\n\t<li><code>smalls</code>的总字符数不会超过 100000。</li>\n\t<li>你可以认为<code>smalls</code>中没有重复字符串。</li>\n\t<li>所有出现的字符均为英文小写字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3161.最短超串",
        "hardRate": "MEDIUM",
        "passRate": "44.35%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-supersequence-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-supersequence-lcci/solution",
        "problemsDesc": "<p>假设你有两个数组，一个长一个短，短的元素均不相同。找到长数组中包含短数组所有的元素的最短子数组，其出现顺序无关紧要。</p>\n\n<p>返回最短子数组的左端点和右端点，如有多个满足条件的子数组，返回左端点最小的一个。若不存在，返回空数组。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong>\nbig = <code>[7,5,9,0,2,1,3,<strong>5,7,9,1</strong>,1,5,8,8,9,7]\nsmall = [1,5,9]</code>\n<strong>输出: </strong>[7,10]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong>\nbig = <code>[1,2,3]\nsmall = [4]</code>\n<strong>输出: </strong>[]</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>big.length&nbsp;&lt;= 100000</code></li>\n\t<li><code>1 &lt;= small.length&nbsp;&lt;= 100000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3162.消失的两个数字",
        "hardRate": "HARD",
        "passRate": "60.58%",
        "problemsUrl": "https://leetcode.cn/problems/missing-two-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/missing-two-lcci/solution",
        "problemsDesc": "<p>给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？</p>\n\n<p>以任意顺序返回这两个数字均可。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> <code>[1]</code>\n<strong>输出: </strong>[2,3]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> <code>[2,3]</code>\n<strong>输出: </strong>[1,4]</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length &lt;=&nbsp;30000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3163.连续中值",
        "hardRate": "HARD",
        "passRate": "58.39%",
        "problemsUrl": "https://leetcode.cn/problems/continuous-median-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/continuous-median-lcci/solution",
        "problemsDesc": "<p>随机产生数字并传递给一个方法。你能否完成这个方法，在每次产生新值时，寻找当前所有值的中间值（中位数）并保存。</p>\n\n<p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>\n\n<p>例如，</p>\n\n<p>[2,3,4]&nbsp;的中位数是 3</p>\n\n<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>\n\n<p>设计一个支持以下两种操作的数据结构：</p>\n\n<ul>\n\t<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>\n\t<li>double findMedian() - 返回目前所有元素的中位数。</li>\n</ul>\n\n<p><strong>示例：</strong></p>\n\n<pre>addNum(1)\naddNum(2)\nfindMedian() -&gt; 1.5\naddNum(3) \nfindMedian() -&gt; 2\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3164.直方图的水量",
        "hardRate": "HARD",
        "passRate": "63.75%",
        "problemsUrl": "https://leetcode.cn/problems/volume-of-histogram-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/volume-of-histogram-lcci/solution",
        "problemsDesc": "<p>给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png\" style=\"height: 161px; width: 412px;\"></p>\n\n<p><small>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。&nbsp;<strong>感谢 Marcos</strong> 贡献此图。</small></p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> [0,1,0,2,1,0,1,3,2,1,2,1]\n<strong>输出:</strong> 6</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3165.单词转换",
        "hardRate": "MEDIUM",
        "passRate": "40.31%",
        "problemsUrl": "https://leetcode.cn/problems/word-transformer-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/word-transformer-lcci/solution",
        "problemsDesc": "<p>给定字典中的两个词，长度相等。写一个方法，把一个词转换成另一个词， 但是一次只能改变一个字符。每一步得到的新词都必须能在字典中找到。</p>\n\n<p>编写一个程序，返回一个可能的转换序列。如有多个可能的转换序列，你可以返回任何一个。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong>\nbeginWord = &quot;hit&quot;,\nendWord = &quot;cog&quot;,\nwordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n\n<strong>输出:</strong>\n[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong>\nbeginWord = &quot;hit&quot;\nendWord = &quot;cog&quot;\nwordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n\n<strong>输出: </strong>[]\n\n<strong>解释:</strong>&nbsp;<em>endWord</em> &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3166.最大黑方阵",
        "hardRate": "MEDIUM",
        "passRate": "37.83%",
        "problemsUrl": "https://leetcode.cn/problems/max-black-square-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/max-black-square-lcci/solution",
        "problemsDesc": "<p>给定一个方阵，其中每个单元(像素)非黑即白。设计一个算法，找出 4 条边皆为黑色像素的最大子方阵。</p>\n\n<p>返回一个数组 <code>[r, c, size]</code> ，其中&nbsp;<code>r</code>,&nbsp;<code>c</code>&nbsp;分别代表子方阵左上角的行号和列号，<code>size</code> 是子方阵的边长。若有多个满足条件的子方阵，返回 <code>r</code> 最小的，若 <code>r</code> 相同，返回 <code>c</code> 最小的子方阵。若无满足条件的子方阵，返回空数组。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:\n</strong>[\n&nbsp;  [1,0,1],\n&nbsp;  [<strong>0,0</strong>,1],\n&nbsp;  [<strong>0,0</strong>,1]\n]\n<strong>输出: </strong>[1,0,2]\n<strong>解释: </strong>输入中 0 代表黑色，1 代表白色，标粗的元素即为满足条件的最大子方阵\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:\n</strong>[\n&nbsp;  [<strong>0</strong>,1,1],\n&nbsp;  [1,0,1],\n&nbsp;  [1,1,0]\n]\n<strong>输出: </strong>[0,0,1]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>matrix.length == matrix[0].length &lt;= 200</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3167.最大子矩阵",
        "hardRate": "HARD",
        "passRate": "53.59%",
        "problemsUrl": "https://leetcode.cn/problems/max-submatrix-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/max-submatrix-lcci/solution",
        "problemsDesc": "<p>给定一个正整数、负整数和 0 组成的 N &times; M&nbsp;矩阵，编写代码找出元素总和最大的子矩阵。</p>\n\n<p>返回一个数组 <code>[r1, c1, r2, c2]</code>，其中 <code>r1</code>, <code>c1</code> 分别代表子矩阵左上角的行号和列号，<code>r2</code>, <code>c2</code> 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。</p>\n\n<p><strong>注意：</strong>本题相对书上原题稍作改动</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：\n</strong><code>[\n&nbsp;  [-1,<strong>0</strong>],\n&nbsp;  [0,-1]\n]</code>\n<strong>输出：</strong>[0,1,0,1]\n<strong>解释：</strong>输入中标粗的元素即为输出所表示的矩阵</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= matrix.length, matrix[0].length &lt;= 200</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3168.单词矩阵",
        "hardRate": "HARD",
        "passRate": "50.90%",
        "problemsUrl": "https://leetcode.cn/problems/word-rectangle-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/word-rectangle-lcci/solution",
        "problemsDesc": "<p>给定一份单词的清单，设计一个算法，创建由字母组成的面积最大的矩形，其中每一行组成一个单词(自左向右)，每一列也组成一个单词(自上而下)。不要求这些单词在清单里连续出现，但要求所有行等长，所有列等高。</p>\n\n<p>如果有多个面积最大的矩形，输出任意一个均可。一个单词可以重复使用。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> <code>[&quot;this&quot;, &quot;real&quot;, &quot;hard&quot;, &quot;trh&quot;, &quot;hea&quot;, &quot;iar&quot;, &quot;sld&quot;]</code>\n<strong>输出:\n</strong><code>[\n&nbsp;  &quot;this&quot;,\n&nbsp;  &quot;real&quot;,\n&nbsp;  &quot;hard&quot;</code>\n]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> <code>[&quot;aa&quot;]</code>\n<strong>输出: </strong>[&quot;aa&quot;,&quot;aa&quot;]</pre>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li><code>words.length &lt;= 1000</code></li>\n\t<li><code>words[i].length &lt;= 100</code></li>\n\t<li>数据保证单词足够随机</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3169.稀疏相似度",
        "hardRate": "HARD",
        "passRate": "35.28%",
        "problemsUrl": "https://leetcode.cn/problems/sparse-similarity-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/sparse-similarity-lcci/solution",
        "problemsDesc": "<p>两个(具有不同单词的)文档的交集(intersection)中元素的个数除以并集(union)中元素的个数，就是这两个文档的相似度。例如，{1, 5, 3} 和 {1, 7, 2, 3} 的相似度是 0.4，其中，交集的元素有 2 个，并集的元素有 5 个。给定一系列的长篇文档，每个文档元素各不相同，并与一个 ID 相关联。它们的相似度非常&ldquo;稀疏&rdquo;，也就是说任选 2 个文档，相似度都很接近 0。请设计一个算法返回每对文档的 ID 及其相似度。只需输出相似度大于 0 的组合。请忽略空文档。为简单起见，可以假定每个文档由一个含有不同整数的数组表示。</p>\n\n<p>输入为一个二维数组 <code>docs</code>，<code>docs[i]</code>&nbsp;表示&nbsp;id 为 <code>i</code> 的文档。返回一个数组，其中每个元素是一个字符串，代表每对相似度大于 0 的文档，其格式为 <code>{id1},{id2}: {similarity}</code>，其中 <code>id1</code> 为两个文档中较小的 id，<code>similarity</code> 为相似度，精确到小数点后 4 位。以任意顺序返回数组均可。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> \n<code>[\n&nbsp; [14, 15, 100, 9, 3],\n&nbsp; [32, 1, 9, 3, 5],\n&nbsp; [15, 29, 2, 6, 8, 7],\n&nbsp; [7, 10]\n]</code>\n<strong>输出:</strong>\n[\n&nbsp; &quot;0,1: 0.2500&quot;,\n&nbsp; &quot;0,2: 0.1000&quot;,\n&nbsp; &quot;2,3: 0.1429&quot;\n]</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>docs.length &lt;= 500</code></li>\n\t<li><code>docs[i].length &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    }
]