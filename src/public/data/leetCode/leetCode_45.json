[
    {
        "problemsName": " 2201.统计可以提取的工件",
        "hardRate": "MEDIUM",
        "passRate": "49.44%",
        "problemsUrl": "https://leetcode.cn/problems/count-artifacts-that-can-be-extracted/",
        "solutionsUrl": "https://leetcode.cn/problems/count-artifacts-that-can-be-extracted/solution",
        "problemsDesc": "<p>存在一个 <code>n x n</code> 大小、下标从 <strong>0</strong> 开始的网格，网格中埋着一些工件。给你一个整数 <code>n</code> 和一个下标从 <strong>0</strong> 开始的二维整数数组 <code>artifacts</code> ，<code>artifacts</code> 描述了矩形工件的位置，其中 <code>artifacts[i] = [r1<sub>i</sub>, c1<sub>i</sub>, r2<sub>i</sub>, c2<sub>i</sub>]</code> 表示第 <code>i</code> 个工件在子网格中的填埋情况：</p>\n\n<ul>\n\t<li><code>(r1<sub>i</sub>, c1<sub>i</sub>)</code> 是第 <code>i</code> 个工件 <strong>左上</strong> 单元格的坐标，且</li>\n\t<li><code>(r2<sub>i</sub>, c2<sub>i</sub>)</code> 是第 <code>i</code> 个工件 <strong>右下</strong> 单元格的坐标。</li>\n</ul>\n\n<p>你将会挖掘网格中的一些单元格，并清除其中的填埋物。如果单元格中埋着工件的一部分，那么该工件这一部分将会裸露出来。如果一个工件的所有部分都都裸露出来，你就可以提取该工件。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>dig</code> ，其中 <code>dig[i] = [r<sub>i</sub>, c<sub>i</sub>]</code> 表示你将会挖掘单元格 <code>(r<sub>i</sub>, c<sub>i</sub>)</code> ，返回你可以提取的工件数目。</p>\n\n<p>生成的测试用例满足：</p>\n\n<ul>\n\t<li>不存在重叠的两个工件。</li>\n\t<li>每个工件最多只覆盖 <code>4</code> 个单元格。</li>\n\t<li><code>dig</code> 中的元素互不相同。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/16/untitled-diagram.jpg\" style=\"width: 216px; height: 216px;\">\n<pre><strong>输入：</strong>n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]\n<strong>输出：</strong>1\n<strong>解释：</strong> \n不同颜色表示不同的工件。挖掘的单元格用 'D' 在网格中进行标记。\n有 1 个工件可以提取，即红色工件。\n蓝色工件在单元格 (1,1) 的部分尚未裸露出来，所以无法提取该工件。\n因此，返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/16/untitled-diagram-1.jpg\" style=\"width: 216px; height: 216px;\">\n<pre><strong>输入：</strong>n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1],[1,1]]\n<strong>输出：</strong>2\n<strong>解释：</strong>红色工件和蓝色工件的所有部分都裸露出来（用 'D' 标记），都可以提取。因此，返回 2 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= artifacts.length, dig.length &lt;= min(n<sup>2</sup>, 10<sup>5</sup>)</code></li>\n\t<li><code>artifacts[i].length == 4</code></li>\n\t<li><code>dig[i].length == 2</code></li>\n\t<li><code>0 &lt;= r1<sub>i</sub>, c1<sub>i</sub>, r2<sub>i</sub>, c2<sub>i</sub>, r<sub>i</sub>, c<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>r1<sub>i</sub> &lt;= r2<sub>i</sub></code></li>\n\t<li><code>c1<sub>i</sub> &lt;= c2<sub>i</sub></code></li>\n\t<li>不存在重叠的两个工件</li>\n\t<li>每个工件 <strong>最多</strong> 只覆盖 <code>4</code> 个单元格</li>\n\t<li><code>dig</code> 中的元素互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2202.K 次操作后最大化顶端元素",
        "hardRate": "MEDIUM",
        "passRate": "21.69%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-the-topmost-element-after-k-moves/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-the-topmost-element-after-k-moves/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它表示一个 <strong>栈</strong> ，其中 <code>nums[0]</code>&nbsp;是栈顶的元素。</p>\n\n<p>每一次操作中，你可以执行以下操作 <strong>之一</strong>&nbsp;：</p>\n\n<ul>\n\t<li>如果栈非空，那么 <strong>删除</strong>&nbsp;栈顶端的元素。</li>\n\t<li>如果存在 1 个或者多个被删除的元素，你可以从它们中选择任何一个，<b>添加</b>&nbsp;回栈顶，这个元素成为新的栈顶元素。</li>\n</ul>\n\n<p>同时给你一个整数&nbsp;<code>k</code>&nbsp;，它表示你总共需要执行操作的次数。</p>\n\n<p>请你返回 <strong>恰好</strong>&nbsp;执行 <code>k</code>&nbsp;次操作以后，栈顶元素的 <strong>最大值</strong>&nbsp;。如果执行完 <code>k</code>&nbsp;次操作以后，栈一定为空，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,2,2,4,0,6], k = 4\n<b>输出：</b>5\n<strong>解释：</strong>\n4 次操作后，栈顶元素为 5 的方法之一为：\n- 第 1 次操作：删除栈顶元素 5 ，栈变为 [2,2,4,0,6] 。\n- 第 2 次操作：删除栈顶元素 2 ，栈变为 [2,4,0,6] 。\n- 第 3 次操作：删除栈顶元素 2 ，栈变为 [4,0,6] 。\n- 第 4 次操作：将 5 添加回栈顶，栈变为 [5,4,0,6] 。\n注意，这不是最后栈顶元素为 5 的唯一方式。但可以证明，4 次操作以后 5 是能得到的最大栈顶元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2], k = 1\n<b>输出：</b>-1\n<b>解释：</b>\n第 1 次操作中，我们唯一的选择是将栈顶元素弹出栈。\n由于 1 次操作后无法得到一个非空的栈，所以我们返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i], k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2203.得到要求路径的最小带权子图",
        "hardRate": "HARD",
        "passRate": "37.77%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-weighted-subgraph-with-the-required-paths/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-weighted-subgraph-with-the-required-paths/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，它表示一个 <strong>带权有向</strong> 图的节点数，节点编号为&nbsp;<code>0</code> 到&nbsp;<code>n - 1</code>&nbsp;。</p>\n\n<p>同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code>&nbsp;，表示从&nbsp;<code>from<sub>i</sub></code>&nbsp;到&nbsp;<code>to<sub>i</sub></code>&nbsp;有一条边权为&nbsp;<code>weight<sub>i</sub></code>&nbsp;的 <strong>有向</strong> 边。</p>\n\n<p>最后，给你三个 <strong>互不相同</strong>&nbsp;的整数&nbsp;<code>src1</code>&nbsp;，<code>src2</code>&nbsp;和&nbsp;<code>dest</code>&nbsp;，表示图中三个不同的点。</p>\n\n<p>请你从图中选出一个 <b>边权和最小</b>&nbsp;的子图，使得从 <code>src1</code>&nbsp;和 <code>src2</code>&nbsp;出发，在这个子图中，都 <strong>可以</strong>&nbsp;到达 <code>dest</code>&nbsp;。如果这样的子图不存在，请返回 <code>-1</code>&nbsp;。</p>\n\n<p><strong>子图</strong>&nbsp;中的点和边都应该属于原图的一部分。子图的边权和定义为它所包含的所有边的权值之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/17/example1drawio.png\" style=\"width: 263px; height: 250px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5\n<b>输出：</b>9\n<strong>解释：</strong>\n上图为输入的图。\n蓝色边为最优子图之一。\n注意，子图 [[1,0,3],[0,5,6]] 也能得到最优解，但无法在满足所有限制的前提下，得到更优解。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/17/example2-1drawio.png\" style=\"width: 350px; height: 51px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2\n<b>输出：</b>-1\n<strong>解释：</strong>\n上图为输入的图。\n可以看到，不存在从节点 1 到节点 2 的路径，所以不存在任何子图满足所有限制。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub>, src1, src2, dest &lt;= n - 1</code></li>\n\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\n\t<li><code>src1</code>&nbsp;，<code>src2</code>&nbsp;和&nbsp;<code>dest</code>&nbsp;两两不同。</li>\n\t<li><code>1 &lt;= weight[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2204.无向图中到环的距离",
        "hardRate": "HARD",
        "passRate": "75.62%",
        "problemsUrl": "https://leetcode.cn/problems/distance-to-a-cycle-in-undirected-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/distance-to-a-cycle-in-undirected-graph/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2205.有资格享受折扣的用户数量",
        "hardRate": "EASY",
        "passRate": "44.83%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-users-that-are-eligible-for-discount/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-users-that-are-eligible-for-discount/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2206.将数组划分成相等数对",
        "hardRate": "EASY",
        "passRate": "73.80%",
        "problemsUrl": "https://leetcode.cn/problems/divide-array-into-equal-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-array-into-equal-pairs/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;，它包含&nbsp;<code>2 * n</code>&nbsp;个整数。</p>\n\n<p>你需要将&nbsp;<code>nums</code> 划分成&nbsp;<code>n</code>&nbsp;个数对，满足：</p>\n\n<ul>\n\t<li>每个元素 <strong>只属于一个 </strong>数对。</li>\n\t<li>同一数对中的元素 <strong>相等</strong>&nbsp;。</li>\n</ul>\n\n<p>如果可以将 <code>nums</code>&nbsp;划分成 <code>n</code>&nbsp;个数对，请你返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,2,3,2,2,2]\n<b>输出：</b>true\n<b>解释：</b>\nnums<code>&nbsp;中总共有 6 个元素，所以它们应该被划分成</code> 6 / 2 = 3 个数对。\nnums 可以划分成 (2, 2) ，(3, 3) 和 (2, 2) ，满足所有要求。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4]\n<b>输出：</b>false\n<b>解释：</b>\n无法将 nums 划分成 4 / 2 = 2 个数对且满足所有要求。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == 2 * n</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2207.字符串中最多数目的子字符串",
        "hardRate": "MEDIUM",
        "passRate": "31.59%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-number-of-subsequences-in-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-number-of-subsequences-in-a-string/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>text</code>&nbsp;和另一个下标从 <strong>0</strong>&nbsp;开始且长度为 <code>2</code>&nbsp;的字符串&nbsp;<code>pattern</code>&nbsp;，两者都只包含小写英文字母。</p>\n\n<p>你可以在 <code>text</code>&nbsp;中任意位置插入 <strong>一个</strong> 字符，这个插入的字符必须是&nbsp;<code>pattern[0]</code>&nbsp;<b>或者</b>&nbsp;<code>pattern[1]</code>&nbsp;。注意，这个字符可以插入在 <code>text</code>&nbsp;开头或者结尾的位置。</p>\n\n<p>请你返回插入一个字符后，<code>text</code>&nbsp;中最多包含多少个等于 <code>pattern</code>&nbsp;的 <strong>子序列</strong>&nbsp;。</p>\n\n<p><strong>子序列</strong> 指的是将一个字符串删除若干个字符后（也可以不删除），剩余字符保持原本顺序得到的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>text = \"abdcdbc\", pattern = \"ac\"\n<b>输出：</b>4\n<strong>解释：</strong>\n如果我们在 text[1] 和 text[2] 之间添加 pattern[0] = 'a' ，那么我们得到 \"ab<em><strong>a</strong></em>dcdbc\" 。那么 \"ac\" 作为子序列出现 4 次。\n其他得到 4 个 \"ac\" 子序列的方案还有 \"<em><strong>a</strong></em>abdcdbc\" 和 \"abd<em><strong>a</strong></em>cdbc\" 。\n但是，\"abdc<em><strong>a</strong></em>dbc\" ，\"abd<em><strong>c</strong></em>cdbc\" 和 \"abdcdbc<em><strong>c</strong></em>\" 这些字符串虽然是可行的插入方案，但是只出现了 3 次 \"ac\" 子序列，所以不是最优解。\n可以证明插入一个字符后，无法得到超过 4 个 \"ac\" 子序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>text = \"aabb\", pattern = \"ab\"\n<b>输出：</b>6\n<strong>解释：</strong>\n可以得到 6 个 \"ab\" 子序列的部分方案为 \"<em><strong>a</strong></em>aabb\" ，\"aa<em><strong>a</strong></em>bb\" 和 \"aab<em><strong>b</strong></em>b\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pattern.length == 2</code></li>\n\t<li><code>text</code> 和&nbsp;<code>pattern</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2208.将数组和减半的最少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "40.95%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>nums</code>&nbsp;。每一次操作中，你可以从&nbsp;<code>nums</code>&nbsp;中选择 <strong>任意</strong>&nbsp;一个数并将它减小到 <strong>恰好</strong>&nbsp;一半。（注意，在后续操作中你可以对减半过的数继续执行操作）</p>\n\n<p>请你返回将 <code>nums</code>&nbsp;数组和 <strong>至少</strong>&nbsp;减少一半的 <strong>最少</strong>&nbsp;操作数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [5,19,8,1]\n<b>输出：</b>3\n<b>解释：</b>初始 nums 的和为 5 + 19 + 8 + 1 = 33 。\n以下是将数组和减少至少一半的一种方法：\n选择数字 19 并减小为 9.5 。\n选择数字 9.5 并减小为 4.75 。\n选择数字 8 并减小为 4 。\n最终数组为 [5, 4.75, 4, 1] ，和为 5 + 4.75 + 4 + 1 = 14.75 。\nnums 的和减小了 33 - 14.75 = 18.25 ，减小的部分超过了初始数组和的一半，18.25 &gt;= 33/2 = 16.5 。\n我们需要 3 个操作实现题目要求，所以返回 3 。\n可以证明，无法通过少于 3 个操作使数组和减少至少一半。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,8,20]\n<b>输出：</b>3\n<strong>解释：</strong>初始 nums 的和为 3 + 8 + 20 = 31 。\n以下是将数组和减少至少一半的一种方法：\n选择数字 20 并减小为 10 。\n选择数字 10 并减小为 5 。\n选择数字 3 并减小为 1.5 。\n最终数组为 [1.5, 8, 5] ，和为 1.5 + 8 + 5 = 14.5 。\nnums 的和减小了 31 - 14.5 = 16.5 ，减小的部分超过了初始数组和的一半， 16.5 &gt;= 31/2 = 16.5 。\n我们需要 3 个操作实现题目要求，所以返回 3 。\n可以证明，无法通过少于 3 个操作使数组和减少至少一半。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2209.用地毯覆盖后的最少白色砖块",
        "hardRate": "HARD",
        "passRate": "39.23%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/solution",
        "problemsDesc": "<p>给你一个下标从<strong>&nbsp;0</strong>&nbsp;开始的 <strong>二进制</strong>&nbsp;字符串&nbsp;<code>floor</code>&nbsp;，它表示地板上砖块的颜色。</p>\n\n<ul>\n\t<li><code>floor[i] = '0'</code>&nbsp;表示地板上第&nbsp;<code>i</code>&nbsp;块砖块的颜色是 <strong>黑色</strong>&nbsp;。</li>\n\t<li><code>floor[i] = '1'</code>&nbsp;表示地板上第&nbsp;<code>i</code>&nbsp;块砖块的颜色是 <strong>白色</strong>&nbsp;。</li>\n</ul>\n\n<p>同时给你&nbsp;<code>numCarpets</code> 和&nbsp;<code>carpetLen</code>&nbsp;。你有&nbsp;<code>numCarpets</code>&nbsp;条&nbsp;<strong>黑色</strong>&nbsp;的地毯，每一条&nbsp;<strong>黑色</strong>&nbsp;的地毯长度都为&nbsp;<code>carpetLen</code>&nbsp;块砖块。请你使用这些地毯去覆盖砖块，使得未被覆盖的剩余 <strong>白色</strong>&nbsp;砖块的数目 <strong>最小</strong>&nbsp;。地毯相互之间可以覆盖。</p>\n\n<p>请你返回没被覆盖的白色砖块的 <strong>最少</strong>&nbsp;数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/10/ex1-1.png\" style=\"width: 400px; height: 73px;\"></p>\n\n<pre><b>输入：</b>floor = \"10110101\", numCarpets = 2, carpetLen = 2\n<b>输出：</b>2\n<b>解释：</b>\n上图展示了剩余 2 块白色砖块的方案。\n没有其他方案可以使未被覆盖的白色砖块少于 2 块。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/10/ex2.png\" style=\"width: 353px; height: 123px;\"></p>\n\n<pre><b>输入：</b>floor = \"11111\", numCarpets = 2, carpetLen = 3\n<b>输出：</b>0\n<b>解释：</b>\n上图展示了所有白色砖块都被覆盖的一种方案。\n注意，地毯相互之间可以覆盖。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= carpetLen &lt;= floor.length &lt;= 1000</code></li>\n\t<li><code>floor[i]</code> 要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code>&nbsp;。</li>\n\t<li><code>1 &lt;= numCarpets &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2210.统计数组中峰和谷的数量",
        "hardRate": "EASY",
        "passRate": "58.63%",
        "problemsUrl": "https://leetcode.cn/problems/count-hills-and-valleys-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/count-hills-and-valleys-in-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。如果两侧距 <code>i</code> 最近的不相等邻居的值均小于 <code>nums[i]</code> ，则下标 <code>i</code> 是 <code>nums</code> 中，某个峰的一部分。类似地，如果两侧距 <code>i</code> 最近的不相等邻居的值均大于 <code>nums[i]</code> ，则下标 <code>i</code> 是 <code>nums</code> 中某个谷的一部分。对于相邻下标&nbsp;<code>i</code> 和 <code>j</code> ，如果&nbsp;<code>nums[i] == nums[j]</code> ， 则认为这两下标属于 <strong>同一个</strong> 峰或谷。</p>\n\n<p>注意，要使某个下标所做峰或谷的一部分，那么它左右两侧必须 <strong>都</strong> 存在不相等邻居。</p>\n\n<p>返回 <code>nums</code> 中峰和谷的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,1,1,6,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n在下标 0 ：由于 2 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。\n在下标 1 ：4 的最近不相等邻居是 2 和 1 。由于 4 &gt; 2 且 4 &gt; 1 ，下标 1 是一个峰。\n在下标 2 ：1 的最近不相等邻居是 4 和 6 。由于 1 &lt; 4 且 1 &lt; 6 ，下标 2 是一个谷。\n在下标 3 ：1 的最近不相等邻居是 4 和 6 。由于 1 &lt; 4 且 1 &lt; 6 ，下标 3 符合谷的定义，但需要注意它和下标 2 是同一个谷的一部分。\n在下标 4 ：6 的最近不相等邻居是 1 和 5 。由于 6 &gt; 1 且 6 &gt; 5 ，下标 4 是一个峰。\n在下标 5 ：由于 5 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。\n共有 3 个峰和谷，所以返回 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,6,5,5,4,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n在下标 0 ：由于 6 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。\n在下标 1 ：由于 6 的左侧不存在不相等邻居，所以下标 1 既不是峰也不是谷。\n在下标 2 ：5 的最近不相等邻居是 6 和 4 。由于 5 &lt; 6 且 5 &gt; 4 ，下标 2 既不是峰也不是谷。\n在下标 3 ：5 的最近不相等邻居是 6 和 4 。由于 5 &lt; 6 且 5 &gt; 4 ，下标 3 既不是峰也不是谷。\n在下标 4 ：4 的最近不相等邻居是 5 和 1 。由于 4 &lt; 5 且 4 &gt; 1 ，下标 4 既不是峰也不是谷。\n在下标 5 ：由于 1 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。\n共有 0 个峰和谷，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2211.统计道路上的碰撞次数",
        "hardRate": "MEDIUM",
        "passRate": "41.15%",
        "problemsUrl": "https://leetcode.cn/problems/count-collisions-on-a-road/",
        "solutionsUrl": "https://leetcode.cn/problems/count-collisions-on-a-road/solution",
        "problemsDesc": "<p>在一条无限长的公路上有 <code>n</code> 辆汽车正在行驶。汽车按从左到右的顺序按从 <code>0</code> 到 <code>n - 1</code> 编号，每辆车都在一个 <strong>独特的</strong> 位置。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>directions</code> ，长度为 <code>n</code> 。<code>directions[i]</code> 可以是 <code>'L'</code>、<code>'R'</code> 或 <code>'S'</code> 分别表示第 <code>i</code> 辆车是向 <strong>左</strong> 、向 <strong>右</strong> 或者 <strong>停留</strong> 在当前位置。每辆车移动时 <strong>速度相同</strong> 。</p>\n\n<p>碰撞次数可以按下述方式计算：</p>\n\n<ul>\n\t<li>当两辆移动方向&nbsp;<strong>相反</strong>&nbsp;的车相撞时，碰撞次数加 <code>2</code> 。</li>\n\t<li>当一辆移动的车和一辆静止的车相撞时，碰撞次数加 <code>1</code> 。</li>\n</ul>\n\n<p>碰撞发生后，涉及的车辆将无法继续移动并停留在碰撞位置。除此之外，汽车不能改变它们的状态或移动方向。</p>\n\n<p>返回在这条道路上发生的 <strong>碰撞总次数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>directions = \"RLRSLL\"\n<strong>输出：</strong>5\n<strong>解释：</strong>\n将会在道路上发生的碰撞列出如下：\n- 车 0 和车 1 会互相碰撞。由于它们按相反方向移动，碰撞数量变为 0 + 2 = 2 。\n- 车 2 和车 3 会互相碰撞。由于 3 是静止的，碰撞数量变为 2 + 1 = 3 。\n- 车 3 和车 4 会互相碰撞。由于 3 是静止的，碰撞数量变为 3 + 1 = 4 。\n- 车 4 和车 5 会互相碰撞。在车 4 和车 3 碰撞之后，车 4 会待在碰撞位置，接着和车 5 碰撞。碰撞数量变为 4 + 1 = 5 。\n因此，将会在道路上发生的碰撞总次数是 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>directions = \"LLRR\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\n不存在会发生碰撞的车辆。因此，将会在道路上发生的碰撞总次数是 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= directions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>directions[i]</code> 的值为 <code>'L'</code>、<code>'R'</code> 或 <code>'S'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2212.射箭比赛中的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "47.87%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-points-in-an-archery-competition/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-points-in-an-archery-competition/solution",
        "problemsDesc": "<p>Alice 和 Bob 是一场射箭比赛中的对手。比赛规则如下：</p>\n\n<ol>\n\t<li>Alice 先射 <code>numArrows</code> 支箭，然后 Bob 也射 <code>numArrows</code> 支箭。</li>\n\t<li>分数按下述规则计算：\n\t<ol>\n\t\t<li>箭靶有若干整数计分区域，范围从 <code>0</code> 到 <code>11</code> （含 <code>0</code> 和 <code>11</code>）。</li>\n\t\t<li>箭靶上每个区域都对应一个得分 <code>k</code>（范围是 <code>0</code> 到 <code>11</code>），Alice 和 Bob 分别在得分 <code>k</code>&nbsp;区域射中&nbsp;<code>a<sub>k</sub></code> 和 <code>b<sub>k</sub></code> 支箭。如果 <code>a<sub>k</sub> &gt;= b<sub>k</sub></code> ，那么 Alice 得 <code>k</code> 分。如果 <code>a<sub>k</sub> &lt; b<sub>k</sub></code> ，则 Bob 得 <code>k</code> 分</li>\n\t\t<li>如果 <code>a<sub>k</sub> == b<sub>k</sub> == 0</code> ，那么无人得到 <code>k</code> 分。</li>\n\t</ol>\n\t</li>\n</ol>\n\n<ul>\n\t<li>\n\t<p>例如，Alice 和 Bob 都向计分为 <code>11</code> 的区域射 <code>2</code> 支箭，那么 Alice 得 <code>11</code> 分。如果 Alice 向计分为 <code>11</code> 的区域射 <code>0</code> 支箭，但 Bob 向同一个区域射 <code>2</code> 支箭，那么 Bob 得&nbsp;<code>11</code> 分。</p>\n\t</li>\n</ul>\n\n<p>给你整数 <code>numArrows</code> 和一个长度为 <code>12</code> 的整数数组 <code>aliceArrows</code> ，该数组表示 Alice 射中&nbsp;<code>0</code> 到 <code>11</code> 每个计分区域的箭数量。现在，Bob 想要尽可能 <strong>最大化</strong> 他所能获得的总分。</p>\n\n<p>返回数组 <code>bobArrows</code><em> </em>，该数组表示 Bob 射中&nbsp;<code>0</code> 到 <code>11</code> <strong>每个</strong> 计分区域的箭数量。且 <code>bobArrows</code> 的总和应当等于 <code>numArrows</code> 。</p>\n\n<p>如果存在多种方法都可以使 Bob 获得最大总分，返回其中 <strong>任意一种</strong> 即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1647744752-kQKrXw-image.png\" style=\"width: 600px; height: 120px;\" /></p>\n\n<pre>\n<strong>输入：</strong>numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]\n<strong>输出：</strong>[0,0,0,0,1,1,0,0,1,2,3,1]\n<strong>解释：</strong>上表显示了比赛得分情况。\nBob 获得总分 4 + 5 + 8 + 9 + 10 + 11 = 47 。\n可以证明 Bob 无法获得比 47 更高的分数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1647744785-cMHzaC-image.png\" style=\"width: 600px; height: 117px;\" /></p>\n\n<pre>\n<strong>输入：</strong>numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]\n<strong>输出：</strong>[0,0,0,0,0,0,0,0,1,1,1,0]\n<strong>解释：</strong>上表显示了比赛得分情况。\nBob 获得总分 8 + 9 + 10 = 27 。\n可以证明 Bob 无法获得比 27 更高的分数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numArrows &lt;= 10<sup>5</sup></code></li>\n\t<li><code>aliceArrows.length == bobArrows.length == 12</code></li>\n\t<li><code>0 &lt;= aliceArrows[i], bobArrows[i] &lt;= numArrows</code></li>\n\t<li><code>sum(aliceArrows[i]) == numArrows</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2213.由单个字符重复的最长子字符串",
        "hardRate": "HARD",
        "passRate": "40.71%",
        "problemsUrl": "https://leetcode.cn/problems/longest-substring-of-one-repeating-character/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-substring-of-one-repeating-character/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> 。另给你一个下标从 <strong>0</strong> 开始、长度为 <code>k</code> 的字符串 <code>queryCharacters</code> ，一个下标从 <code>0</code> 开始、长度也是 <code>k</code> 的整数 <strong>下标</strong> 数组&nbsp;<code>queryIndices</code> ，这两个都用来描述 <code>k</code> 个查询。</p>\n\n<p>第 <code>i</code> 个查询会将 <code>s</code> 中位于下标 <code>queryIndices[i]</code> 的字符更新为 <code>queryCharacters[i]</code> 。</p>\n\n<p>返回一个长度为 <code>k</code> 的数组 <code>lengths</code> ，其中 <code>lengths[i]</code> 是在执行第 <code>i</code> 个查询 <strong>之后</strong> <code>s</code> 中仅由 <strong>单个字符重复</strong> 组成的 <strong>最长子字符串</strong> 的 <strong>长度</strong> <em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"babacc\", queryCharacters = \"bcb\", queryIndices = [1,3,3]\n<strong>输出：</strong>[3,3,4]\n<strong>解释：</strong>\n- 第 1 次查询更新后 s = \"<em>b<strong>b</strong>b</em>acc\" 。由单个字符重复组成的最长子字符串是 \"bbb\" ，长度为 3 。\n- 第 2 次查询更新后 s = \"bbb<em><strong>c</strong>cc</em>\" 。由单个字符重复组成的最长子字符串是 \"bbb\" 或 \"ccc\"，长度为 3 。\n- 第 3 次查询更新后 s = \"<em>bbb<strong>b</strong></em>cc\" 。由单个字符重复组成的最长子字符串是 \"bbbb\" ，长度为 4 。\n因此，返回 [3,3,4] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abyzz\", queryCharacters = \"aa\", queryIndices = [2,1]\n<strong>输出：</strong>[2,3]\n<strong>解释：</strong>\n- 第 1 次查询更新后 s = \"ab<strong>a</strong><em>zz</em>\" 。由单个字符重复组成的最长子字符串是 \"zz\" ，长度为 2 。\n- 第 2 次查询更新后 s = \"<em>a<strong>a</strong>a</em>zz\" 。由单个字符重复组成的最长子字符串是 \"aaa\" ，长度为 3 。\n因此，返回 [2,3] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n\t<li><code>k == queryCharacters.length == queryIndices.length</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queryCharacters</code> 由小写英文字母组成</li>\n\t<li><code>0 &lt;= queryIndices[i] &lt; s.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2214.通关游戏所需的最低生命值",
        "hardRate": "MEDIUM",
        "passRate": "55.58%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-health-to-beat-game/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-health-to-beat-game/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2215.找出两数组的不同",
        "hardRate": "EASY",
        "passRate": "66.98%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-difference-of-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-difference-of-two-arrays/solution",
        "problemsDesc": "<p>给你两个下标从 <code>0</code> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你返回一个长度为 <code>2</code> 的列表 <code>answer</code> ，其中：</p>\n\n<ul>\n\t<li><code>answer[0]</code> 是 <code>nums1</code> 中所有<strong> 不 </strong>存在于 <code>nums2</code> 中的 <strong>不同</strong> 整数组成的列表。</li>\n\t<li><code>answer[1]</code> 是 <code>nums2</code> 中所有<strong> 不 </strong>存在于 <code>nums1</code> 中的 <strong>不同</strong> 整数组成的列表。</li>\n</ul>\n\n<p><strong>注意：</strong>列表中的整数可以按 <strong>任意</strong> 顺序返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,3], nums2 = [2,4,6]\n<strong>输出：</strong>[[1,3],[4,6]]\n<strong>解释：\n</strong>对于 nums1 ，nums1[1] = 2 出现在 nums2 中下标 0 处，然而 nums1[0] = 1 和 nums1[2] = 3 没有出现在 nums2 中。因此，answer[0] = [1,3]。\n对于 nums2 ，nums2[0] = 2 出现在 nums1 中下标 1 处，然而 nums2[1] = 4 和 nums2[2] = 6 没有出现在 nums2 中。因此，answer[1] = [4,6]。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,3,3], nums2 = [1,1,2,2]\n<strong>输出：</strong>[[3],[]]\n<strong>解释：\n</strong>对于 nums1 ，nums1[2] 和 nums1[3] 没有出现在 nums2 中。由于 nums1[2] == nums1[3] ，二者的值只需要在 answer[0] 中出现一次，故 answer[0] = [3]。\nnums2 中的每个整数都在 nums1 中出现，因此，answer[1] = [] 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2216.美化数组的最少删除数",
        "hardRate": "MEDIUM",
        "passRate": "48.63%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-array-beautiful/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-array-beautiful/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，如果满足下述条件，则认为数组 <code>nums</code> 是一个 <strong>美丽数组</strong> ：</p>\n\n<ul>\n\t<li><code>nums.length</code> 为偶数</li>\n\t<li>对所有满足 <code>i % 2 == 0</code> 的下标 <code>i</code> ，<code>nums[i] != nums[i + 1]</code> 均成立</li>\n</ul>\n\n<p>注意，空数组同样认为是美丽数组。</p>\n\n<p>你可以从 <code>nums</code> 中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持 <strong>不变</strong> 。</p>\n\n<p>返回使 <code>nums</code> 变为美丽数组所需删除的 <strong>最少</strong> 元素数目<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,2,3,5]\n<strong>输出：</strong>1\n<strong>解释：</strong>可以删除 <code>nums[0]</code> 或 <code>nums[1]</code> ，这样得到的 <code>nums</code> = [1,2,3,5] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 1 个元素。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,2,2,3,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>可以删除 <code>nums[0]</code> 和 <code>nums[5]</code> ，这样得到的 nums = [1,2,2,3] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 2 个元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2217.找到指定长度的回文数",
        "hardRate": "MEDIUM",
        "passRate": "33.69%",
        "problemsUrl": "https://leetcode.cn/problems/find-palindrome-with-fixed-length/",
        "solutionsUrl": "https://leetcode.cn/problems/find-palindrome-with-fixed-length/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>queries</code>&nbsp;和一个 <strong>正</strong>&nbsp;整数&nbsp;<code>intLength</code>&nbsp;，请你返回一个数组&nbsp;<code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code> 是长度为&nbsp;<code>intLength</code>&nbsp;的&nbsp;<strong>正回文数</strong> 中第<em>&nbsp;</em><code>queries[i]</code>&nbsp;小的数字，如果不存在这样的回文数，则为 <code>-1</code>&nbsp;。</p>\n\n<p><strong>回文数</strong> 指的是从前往后和从后往前读一模一样的数字。回文数不能有前导 0 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>queries = [1,2,3,4,5,90], intLength = 3\n<b>输出：</b>[101,111,121,131,141,999]\n<strong>解释：</strong>\n长度为 3 的最小回文数依次是：\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, ...\n第 90 个长度为 3 的回文数是 999 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>queries = [2,4,6], intLength = 4\n<b>输出：</b>[1111,1331,1551]\n<strong>解释：</strong>\n长度为 4 的前 6 个回文数是：\n1001, 1111, 1221, 1331, 1441 和 1551 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= queries[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= intLength&nbsp;&lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2218.从栈中取出 K 个硬币的最大面值和",
        "hardRate": "HARD",
        "passRate": "55.39%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/solution",
        "problemsDesc": "<p>一张桌子上总共有 <code>n</code>&nbsp;个硬币 <b>栈</b>&nbsp;。每个栈有 <strong>正整数</strong>&nbsp;个带面值的硬币。</p>\n\n<p>每一次操作中，你可以从任意一个栈的 <strong>顶部</strong>&nbsp;取出 1 个硬币，从栈中移除它，并放入你的钱包里。</p>\n\n<p>给你一个列表&nbsp;<code>piles</code>&nbsp;，其中&nbsp;<code>piles[i]</code>&nbsp;是一个整数数组，分别表示第 <code>i</code>&nbsp;个栈里 <strong>从顶到底</strong>&nbsp;的硬币面值。同时给你一个正整数&nbsp;<code>k</code>&nbsp;，请你返回在&nbsp;<strong>恰好</strong>&nbsp;进行&nbsp;<code>k</code>&nbsp;次操作的前提下，你钱包里硬币面值之和&nbsp;<strong>最大为多少</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/09/e1.png\" style=\"width: 600px; height: 243px;\" /></p>\n\n<pre>\n<b>输入：</b>piles = [[1,100,3],[7,8,9]], k = 2\n<b>输出：</b>101\n<strong>解释：</strong>\n上图展示了几种选择 k 个硬币的不同方法。\n我们可以得到的最大面值为 101 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7\n<b>输出：</b>706\n<strong>解释：\n</strong>如果我们所有硬币都从最后一个栈中取，可以得到最大面值和。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == piles.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= piles[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= sum(piles[i].length) &lt;= 2000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2219.数组的最大总分",
        "hardRate": "MEDIUM",
        "passRate": "64.56%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-score-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-score-of-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2220.转换数字的最少位翻转次数",
        "hardRate": "EASY",
        "passRate": "82.61%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-bit-flips-to-convert-number/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-bit-flips-to-convert-number/solution",
        "problemsDesc": "<p>一次 <strong>位翻转</strong>&nbsp;定义为将数字&nbsp;<code>x</code>&nbsp;二进制中的一个位进行 <strong>翻转</strong>&nbsp;操作，即将&nbsp;<code>0</code>&nbsp;变成&nbsp;<code>1</code>&nbsp;，或者将&nbsp;<code>1</code>&nbsp;变成&nbsp;<code>0</code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，<code>x = 7</code>&nbsp;，二进制表示为&nbsp;<code>111</code>&nbsp;，我们可以选择任意一个位（包含没有显示的前导 0 ）并进行翻转。比方说我们可以翻转最右边一位得到&nbsp;<code>110</code>&nbsp;，或者翻转右边起第二位得到&nbsp;<code>101</code>&nbsp;，或者翻转右边起第五位（这一位是前导 0 ）得到&nbsp;<code>10111</code>&nbsp;等等。</li>\n</ul>\n\n<p>给你两个整数&nbsp;<code>start</code> 和&nbsp;<code>goal</code>&nbsp;，请你返回将&nbsp;<code>start</code>&nbsp;转变成&nbsp;<code>goal</code>&nbsp;的&nbsp;<strong>最少位翻转</strong>&nbsp;次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>start = 10, goal = 7\n<b>输出：</b>3\n<b>解释：</b>10 和 7 的二进制表示分别为 1010 和 0111 。我们可以通过 3 步将 10 转变成 7 ：\n- 翻转右边起第一位得到：101<strong><em>0</em></strong> -&gt; 101<strong><em>1 。</em></strong>\n- 翻转右边起第三位：1<strong><em>0</em></strong>11 -&gt; 1<strong><em>1</em></strong>11 。\n- 翻转右边起第四位：<strong><em>1</em></strong>111 -&gt; <strong><em>0</em></strong>111 。\n我们无法在 3 步内将 10 转变成 7 。所以我们返回 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>start = 3, goal = 4\n<b>输出：</b>3\n<b>解释：</b>3 和 4 的二进制表示分别为 011 和 100 。我们可以通过 3 步将 3 转变成 4 ：\n- 翻转右边起第一位：01<strong><em>1</em></strong> -&gt; 01<em><strong>0 </strong></em>。\n- 翻转右边起第二位：0<strong><em>1</em></strong>0 -&gt; 0<strong><em>0</em></strong>0 。\n- 翻转右边起第三位：<strong><em>0</em></strong>00 -&gt; <strong><em>1</em></strong>00 。\n我们无法在 3 步内将 3 变成 4 。所以我们返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= start, goal &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2221.数组的三角和",
        "hardRate": "MEDIUM",
        "passRate": "79.53%",
        "problemsUrl": "https://leetcode.cn/problems/find-triangular-sum-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-triangular-sum-of-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，其中&nbsp;<code>nums[i]</code>&nbsp;是 <code>0</code>&nbsp;到 <code>9</code>&nbsp;之间（两者都包含）的一个数字。</p>\n\n<p><code>nums</code>&nbsp;的 <strong>三角和</strong>&nbsp;是执行以下操作以后最后剩下元素的值：</p>\n\n<ol>\n\t<li><code>nums</code>&nbsp;初始包含&nbsp;<code>n</code>&nbsp;个元素。如果&nbsp;<code>n == 1</code>&nbsp;，<strong>终止</strong>&nbsp;操作。否则，<strong>创建</strong>&nbsp;一个新的下标从&nbsp;<strong>0</strong>&nbsp;开始的长度为 <code>n - 1</code>&nbsp;的整数数组&nbsp;<code>newNums</code>&nbsp;。</li>\n\t<li>对于满足&nbsp;<code>0 &lt;= i &lt;&nbsp;n - 1</code>&nbsp;的下标&nbsp;<code>i</code>&nbsp;，<code>newNums[i]</code> <strong>赋值</strong>&nbsp;为&nbsp;<code>(nums[i] + nums[i+1]) % 10</code>&nbsp;，<code>%</code>&nbsp;表示取余运算。</li>\n\t<li>将&nbsp;<code>newNums</code>&nbsp;<strong>替换</strong> 数组&nbsp;<code>nums</code>&nbsp;。</li>\n\t<li>从步骤 1 开始&nbsp;<strong>重复</strong>&nbsp;整个过程。</li>\n</ol>\n\n<p>请你返回&nbsp;<code>nums</code>&nbsp;的三角和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/22/ex1drawio.png\" style=\"width: 250px; height: 250px;\" /></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>8\n<strong>解释：</strong>\n上图展示了得到数组三角和的过程。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5]\n<b>输出：</b>5\n<b>解释：</b>\n由于 nums 中只有一个元素，数组的三角和为这个元素自己。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2222.选择建筑的方案数",
        "hardRate": "MEDIUM",
        "passRate": "49.93%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-select-buildings/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-select-buildings/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二进制字符串&nbsp;<code>s</code>&nbsp;，它表示一条街沿途的建筑类型，其中：</p>\n\n<ul>\n\t<li><code>s[i] = '0'</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;栋建筑是一栋办公楼，</li>\n\t<li><code>s[i] = '1'</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;栋建筑是一间餐厅。</li>\n</ul>\n\n<p>作为市政厅的官员，你需要随机<strong>&nbsp;选择</strong>&nbsp;3 栋建筑。然而，为了确保多样性，选出来的 3 栋建筑 <strong>相邻</strong>&nbsp;的两栋不能是同一类型。</p>\n\n<ul>\n\t<li>比方说，给你&nbsp;<code>s = \"0<em><strong>0</strong></em>1<em><strong>1</strong></em>0<em><strong>1</strong></em>\"</code>&nbsp;，我们不能选择第&nbsp;<code>1</code>&nbsp;，<code>3</code>&nbsp;和&nbsp;<code>5</code>&nbsp;栋建筑，因为得到的子序列是&nbsp;<code>\"0<em><strong>11</strong></em>\"</code>&nbsp;，有相邻两栋建筑是同一类型，所以 <strong>不合</strong>&nbsp;题意。</li>\n</ul>\n\n<p>请你返回可以选择 3 栋建筑的 <strong>有效方案数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"001101\"\n<b>输出：</b>6\n<b>解释：</b>\n以下下标集合是合法的：\n- [0,2,4] ，从 \"<em><strong>0</strong></em>0<em><strong>1</strong></em>1<em><strong>0</strong></em>1\" 得到 \"010\"\n- [0,3,4] ，从 \"<em><strong>0</strong></em>01<em><strong>10</strong></em>1\" 得到 \"010\"\n- [1,2,4] ，从 \"0<em><strong>01</strong></em>1<em><strong>0</strong></em>1\" 得到 \"010\"\n- [1,3,4] ，从 \"0<em><strong>0</strong></em>1<em><strong>10</strong></em>1\" 得到 \"010\"\n- [2,4,5] ，从 \"00<em><strong>1</strong></em>1<em><strong>01</strong></em>\" 得到 \"101\"\n- [3,4,5] ，从 \"001<em><strong>101</strong></em>\" 得到 \"101\"\n没有别的合法选择，所以总共有 6 种方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"11100\"\n<b>输出：</b>0\n<b>解释：</b>没有任何符合题意的选择。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2223.构造字符串的总得分和",
        "hardRate": "HARD",
        "passRate": "38.36%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-scores-of-built-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-scores-of-built-strings/solution",
        "problemsDesc": "<p>你需要从空字符串开始&nbsp;<strong>构造</strong> 一个长度为 <code>n</code>&nbsp;的字符串 <code>s</code>&nbsp;，构造的过程为每次给当前字符串 <strong>前面</strong>&nbsp;添加 <strong>一个</strong> 字符。构造过程中得到的所有字符串编号为 <code>1</code>&nbsp;到 <code>n</code>&nbsp;，其中长度为 <code>i</code>&nbsp;的字符串编号为 <code>s<sub>i</sub></code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，<code>s = \"abaca\"</code>&nbsp;，<code>s<sub>1</sub> == \"a\"</code>&nbsp;，<code>s<sub>2</sub> == \"ca\"</code>&nbsp;，<code>s<sub>3</sub> == \"aca\"</code>&nbsp;依次类推。</li>\n</ul>\n\n<p><code>s<sub>i</sub></code>&nbsp;的 <strong>得分</strong>&nbsp;为&nbsp;<code>s<sub>i</sub></code> 和&nbsp;<code>s<sub>n</sub></code>&nbsp;的 <strong>最长公共前缀</strong> 的长度（注意&nbsp;<code>s == s<sub>n</sub></code>&nbsp;）。</p>\n\n<p>给你最终的字符串&nbsp;<code>s</code>&nbsp;，请你返回每一个<em>&nbsp;</em><code>s<sub>i</sub></code>&nbsp;的&nbsp;<strong>得分之和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"babab\"\n<b>输出：</b>9\n<b>解释：</b>\ns<sub>1</sub> == \"b\" ，最长公共前缀是 \"b\" ，得分为 1 。\ns<sub>2</sub> == \"ab\" ，没有公共前缀，得分为 0 。\ns<sub>3</sub> == \"bab\" ，最长公共前缀为 \"bab\" ，得分为 3 。\ns<sub>4</sub> == \"abab\" ，没有公共前缀，得分为 0 。\ns<sub>5</sub> == \"babab\" ，最长公共前缀为 \"babab\" ，得分为 5 。\n得分和为 1 + 0 + 3 + 0 + 5 = 9 ，所以我们返回 9 。</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"azbazbzaz\"\n<b>输出：</b>14\n<b>解释：</b>\ns<sub>2</sub> == \"az\" ，最长公共前缀为 \"az\" ，得分为 2 。\ns<sub>6</sub> == \"azbzaz\" ，最长公共前缀为 \"azb\" ，得分为 3 。\ns<sub>9</sub> == \"azbazbzaz\" ，最长公共前缀为 \"azbazbzaz\" ，得分为 9 。\n其他 s<sub>i</sub> 得分均为 0 。\n得分和为 2 + 3 + 9 = 14 ，所以我们返回 14 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2224.转化时间需要的最少操作数",
        "hardRate": "EASY",
        "passRate": "69.41%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-convert-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-convert-time/solution",
        "problemsDesc": "<p>给你两个字符串 <code>current</code> 和 <code>correct</code> ，表示两个 <strong>24 小时制时间</strong> 。</p>\n\n<p><strong>24 小时制时间</strong> 按 <code>\"HH:MM\"</code> 进行格式化，其中 <code>HH</code> 在 <code>00</code> 和 <code>23</code> 之间，而 <code>MM</code> 在 <code>00</code> 和 <code>59</code> 之间。最早的 24 小时制时间为 <code>00:00</code> ，最晚的是 <code>23:59</code> 。</p>\n\n<p>在一步操作中，你可以将 <code>current</code> 这个时间增加 <code>1</code>、<code>5</code>、<code>15</code> 或 <code>60</code> 分钟。你可以执行这一操作 <strong>任意</strong> 次数。</p>\n\n<p>返回将&nbsp;<code>current</code><em> </em>转化为<em> </em><code>correct</code> 需要的 <strong>最少操作数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>current = \"02:30\", correct = \"04:35\"\n<strong>输出：</strong>3\n<strong>解释：\n</strong>可以按下述 3 步操作将 current 转换为 correct ：\n- 为 current 加 60 分钟，current 变为 \"03:30\" 。\n- 为 current 加 60 分钟，current 变为 \"04:30\" 。 \n- 为 current 加 5 分钟，current 变为 \"04:35\" 。\n可以证明，无法用少于 3 步操作将 current 转化为 correct 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>current = \"11:00\", correct = \"11:01\"\n<strong>输出：</strong>1\n<strong>解释：</strong>只需要为 current 加一分钟，所以最小操作数是 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>current</code> 和 <code>correct</code> 都符合 <code>\"HH:MM\"</code> 格式</li>\n\t<li><code>current &lt;= correct</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2225.找出输掉零场或一场比赛的玩家",
        "hardRate": "MEDIUM",
        "passRate": "63.02%",
        "problemsUrl": "https://leetcode.cn/problems/find-players-with-zero-or-one-losses/",
        "solutionsUrl": "https://leetcode.cn/problems/find-players-with-zero-or-one-losses/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>matches</code> 其中 <code>matches[i] = [winner<sub>i</sub>, loser<sub>i</sub>]</code> 表示在一场比赛中 <code>winner<sub>i</sub></code> 击败了 <code>loser<sub>i</sub></code> 。</p>\n\n<p>返回一个长度为 2 的列表<em> </em><code>answer</code> ：</p>\n\n<ul>\n\t<li><code>answer[0]</code> 是所有 <strong>没有</strong> 输掉任何比赛的玩家列表。</li>\n\t<li><code>answer[1]</code> 是所有恰好输掉 <strong>一场</strong> 比赛的玩家列表。</li>\n</ul>\n\n<p>两个列表中的值都应该按 <strong>递增</strong> 顺序返回。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>只考虑那些参与 <strong>至少一场</strong> 比赛的玩家。</li>\n\t<li>生成的测试用例保证 <strong>不存在</strong> 两场比赛结果 <strong>相同</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\n<strong>输出：</strong>[[1,2,10],[4,5,7,8]]\n<strong>解释：</strong>\n玩家 1、2 和 10 都没有输掉任何比赛。\n玩家 4、5、7 和 8 每个都输掉一场比赛。\n玩家 3、6 和 9 每个都输掉两场比赛。\n因此，answer[0] = [1,2,10] 和 answer[1] = [4,5,7,8] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matches = [[2,3],[1,3],[5,4],[6,4]]\n<strong>输出：</strong>[[1,2,5,6],[]]\n<strong>解释：</strong>\n玩家 1、2、5 和 6 都没有输掉任何比赛。\n玩家 3 和 4 每个都输掉两场比赛。\n因此，answer[0] = [1,2,5,6] 和 answer[1] = [] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= matches.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>matches[i].length == 2</code></li>\n\t<li><code>1 &lt;= winner<sub>i</sub>, loser<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>winner<sub>i</sub> != loser<sub>i</sub></code></li>\n\t<li>所有 <code>matches[i]</code> <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2226.每个小孩最多能分到多少糖果",
        "hardRate": "MEDIUM",
        "passRate": "34.25%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/solution",
        "problemsDesc": "<p>给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>candies</code> 。数组中的每个元素表示大小为 <code>candies[i]</code> 的一堆糖果。你可以将每堆糖果分成任意数量的 <strong>子堆</strong> ，但 <strong>无法</strong> 再将两堆合并到一起。</p>\n\n<p>另给你一个整数 <code>k</code> 。你需要将这些糖果分配给 <code>k</code> 个小孩，使每个小孩分到 <strong>相同</strong> 数量的糖果。每个小孩可以拿走 <strong>至多一堆</strong> 糖果，有些糖果可能会不被分配。</p>\n\n<p>返回每个小孩可以拿走的 <strong>最大糖果数目</strong><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>candies = [5,8,6], k = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>可以将 candies[1] 分成大小分别为 5 和 3 的两堆，然后把 candies[2] 分成大小分别为 5 和 1 的两堆。现在就有五堆大小分别为 5、5、3、5 和 1 的糖果。可以把 3 堆大小为 5 的糖果分给 3 个小孩。可以证明无法让每个小孩得到超过 5 颗糖果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>candies = [2,5], k = 11\n<strong>输出：</strong>0\n<strong>解释：</strong>总共有 11 个小孩，但只有 7 颗糖果，但如果要分配糖果的话，必须保证每个小孩至少能得到 1 颗糖果。因此，最后每个小孩都没有得到糖果，答案是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candies.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= candies[i] &lt;= 10<sup>7</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>12</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2227.加密解密字符串",
        "hardRate": "HARD",
        "passRate": "39.55%",
        "problemsUrl": "https://leetcode.cn/problems/encrypt-and-decrypt-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/encrypt-and-decrypt-strings/solution",
        "problemsDesc": "<p>给你一个字符数组 <code>keys</code> ，由若干 <strong>互不相同</strong> 的字符组成。还有一个字符串数组 <code>values</code> ，内含若干长度为 2 的字符串。另给你一个字符串数组 <code>dictionary</code> ，包含解密后所有允许的原字符串。请你设计并实现一个支持加密及解密下标从 <strong>0</strong> 开始字符串的数据结构。</p>\n\n<p>字符串 <strong>加密</strong> 按下述步骤进行：</p>\n\n<ol>\n\t<li>对字符串中的每个字符 <code>c</code> ，先从 <code>keys</code> 中找出满足 <code>keys[i] == c</code> 的下标 <code>i</code> 。</li>\n\t<li>在字符串中，用&nbsp;<code>values[i]</code> 替换字符 <code>c</code> 。</li>\n</ol>\n\n<p>字符串 <strong>解密</strong> 按下述步骤进行：</p>\n\n<ol>\n\t<li>将字符串每相邻 2 个字符划分为一个子字符串，对于每个子字符串 <code>s</code> ，找出满足 <code>values[i] == s</code> 的一个下标 <code>i</code> 。如果存在多个有效的 <code>i</code> ，从中选择 <strong>任意</strong> 一个。这意味着一个字符串解密可能得到多个解密字符串。</li>\n\t<li>在字符串中，用 <code>keys[i]</code> 替换 <code>s</code> 。</li>\n</ol>\n\n<p>实现 <code>Encrypter</code> 类：</p>\n\n<ul>\n\t<li><code>Encrypter(char[] keys, String[] values, String[] dictionary)</code> 用 <code>keys</code>、<code>values</code> 和 <code>dictionary</code> 初始化 <code>Encrypter</code> 类。</li>\n\t<li><code>String encrypt(String word1)</code> 按上述加密过程完成对 <code>word1</code> 的加密，并返回加密后的字符串。</li>\n\t<li><code>int decrypt(String word2)</code> 统计并返回可以由 <code>word2</code> 解密得到且出现在 <code>dictionary</code> 中的字符串数目。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Encrypter\", \"encrypt\", \"decrypt\"]\n[[['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]], [\"abcd\"], [\"eizfeiam\"]]\n<strong>输出：</strong>\n[null, \"eizfeiam\", 2]\n\n<strong>解释：</strong>\nEncrypter encrypter = new Encrypter([['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]);\nencrypter.encrypt(\"abcd\"); // 返回 \"eizfeiam\"。 \n&nbsp;                          // 'a' 映射为 \"ei\"，'b' 映射为 \"zf\"，'c' 映射为 \"ei\"，'d' 映射为 \"am\"。\nencrypter.decrypt(\"eizfeiam\"); // return 2. \n                              // \"ei\" 可以映射为 'a' 或 'c'，\"zf\" 映射为 'b'，\"am\" 映射为 'd'。 \n                              // 因此，解密后可以得到的字符串是 \"abad\"，\"cbad\"，\"abcd\" 和 \"cbcd\"。 \n                              // 其中 2 个字符串，\"abad\" 和 \"abcd\"，在 dictionary 中出现，所以答案是 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= keys.length == values.length &lt;= 26</code></li>\n\t<li><code>values[i].length == 2</code></li>\n\t<li><code>1 &lt;= dictionary.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= dictionary[i].length &lt;= 100</code></li>\n\t<li>所有 <code>keys[i]</code> 和 <code>dictionary[i]</code> <strong>互不相同</strong></li>\n\t<li><code>1 &lt;= word1.length &lt;= 2000</code></li>\n\t<li><code>1 &lt;= word2.length &lt;= 200</code></li>\n\t<li>所有 <code>word1[i]</code> 都出现在 <code>keys</code> 中</li>\n\t<li><code>word2.length</code> 是偶数</li>\n\t<li><code>keys</code>、<code>values[i]</code>、<code>dictionary[i]</code>、<code>word1</code> 和 <code>word2</code> 只含小写英文字母</li>\n\t<li>至多调用 <code>encrypt</code> 和 <code>decrypt</code> <strong>总计</strong> <code>200</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2228.7 天内两次购买的用户",
        "hardRate": "MEDIUM",
        "passRate": "47.34%",
        "problemsUrl": "https://leetcode.cn/problems/users-with-two-purchases-within-seven-days/",
        "solutionsUrl": "https://leetcode.cn/problems/users-with-two-purchases-within-seven-days/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2229.检查数组是否连贯",
        "hardRate": "EASY",
        "passRate": "69.93%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-an-array-is-consecutive/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-an-array-is-consecutive/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2230.查找可享受优惠的用户",
        "hardRate": "EASY",
        "passRate": "49.61%",
        "problemsUrl": "https://leetcode.cn/problems/the-users-that-are-eligible-for-discount/",
        "solutionsUrl": "https://leetcode.cn/problems/the-users-that-are-eligible-for-discount/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2231.按奇偶性交换后的最大数字",
        "hardRate": "EASY",
        "passRate": "64.27%",
        "problemsUrl": "https://leetcode.cn/problems/largest-number-after-digit-swaps-by-parity/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-number-after-digit-swaps-by-parity/solution",
        "problemsDesc": "<p>给你一个正整数 <code>num</code> 。你可以交换 <code>num</code> 中 <strong>奇偶性</strong> 相同的任意两位数字（即，都是奇数或者偶数）。</p>\n\n<p>返回交换 <strong>任意</strong> 次之后 <code>num</code> 的 <strong>最大</strong> 可能值<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 1234\n<strong>输出：</strong>3412\n<strong>解释：</strong>交换数字 3 和数字 1 ，结果得到 3214 。\n交换数字 2 和数字 4 ，结果得到 3412 。\n注意，可能存在其他交换序列，但是可以证明 3412 是最大可能值。\n注意，不能交换数字 4 和数字 1 ，因为它们奇偶性不同。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 65875\n<strong>输出：</strong>87655\n<strong>解释：</strong>交换数字 8 和数字 6 ，结果得到 85675 。\n交换数字 5 和数字 7 ，结果得到 87655 。\n注意，可能存在其他交换序列，但是可以证明 87655 是最大可能值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2232.向表达式添加括号后的最小结果",
        "hardRate": "MEDIUM",
        "passRate": "61.25%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-result-by-adding-parentheses-to-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-result-by-adding-parentheses-to-expression/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>expression</code> ，格式为 <code>\"&lt;num1&gt;+&lt;num2&gt;\"</code> ，其中 <code>&lt;num1&gt;</code> 和 <code>&lt;num2&gt;</code> 表示正整数。</p>\n\n<p>请你向 <code>expression</code> 中添加一对括号，使得在添加之后， <code>expression</code> 仍然是一个有效的数学表达式，并且计算后可以得到 <strong>最小</strong> 可能值。左括号 <strong>必须</strong> 添加在 <code>'+'</code> 的左侧，而右括号必须添加在 <code>'+'</code> 的右侧。</p>\n\n<p>返回添加一对括号后形成的表达式&nbsp;<code>expression</code> ，且满足<em> </em><code>expression</code><em> </em>计算得到 <strong>最小</strong> 可能值<em>。</em>如果存在多个答案都能产生相同结果，返回任意一个答案。</p>\n\n<p>生成的输入满足：<code>expression</code> 的原始值和添加满足要求的任一对括号之后 <code>expression</code> 的值，都符合 32-bit 带符号整数范围。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>expression = \"247+38\"\n<strong>输出：</strong>\"2(47+38)\"\n<strong>解释：</strong>表达式计算得到 2 * (47 + 38) = 2 * 85 = 170 。\n注意 \"2(4)7+38\" 不是有效的结果，因为右括号必须添加在 <code>'+' 的右侧。</code>\n可以证明 170 是最小可能值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>expression = \"12+34\"\n<strong>输出：</strong>\"1(2+3)4\"\n<strong>解释：</strong>表达式计算得到 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>expression = \"999+999\"\n<strong>输出：</strong>\"(999+999)\"\n<strong>解释：</strong>表达式计算得到 999 + 999 = 1998 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= expression.length &lt;= 10</code></li>\n\t<li><code>expression</code> 仅由数字 <code>'1'</code> 到 <code>'9'</code> 和 <code>'+'</code> 组成</li>\n\t<li><code>expression</code> 由数字开始和结束</li>\n\t<li><code>expression</code> 恰好仅含有一个 <code>'+'</code>.</li>\n\t<li><code>expression</code> 的原始值和添加满足要求的任一对括号之后 <code>expression</code> 的值，都符合 32-bit 带符号整数范围</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2233.K 次增加后的最大乘积",
        "hardRate": "MEDIUM",
        "passRate": "36.71%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-after-k-increments/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-after-k-increments/solution",
        "problemsDesc": "<p>给你一个非负整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。每次操作，你可以选择&nbsp;<code>nums</code>&nbsp;中 <strong>任一</strong>&nbsp;元素并将它 <strong>增加</strong>&nbsp;<code>1</code>&nbsp;。</p>\n\n<p>请你返回 <strong>至多</strong>&nbsp;<code>k</code>&nbsp;次操作后，能得到的<em>&nbsp;</em><code>nums</code>的&nbsp;<strong>最大乘积</strong>&nbsp;。由于答案可能很大，请你将答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [0,4], k = 5\n<b>输出：</b>20\n<b>解释：</b>将第一个数增加 5 次。\n得到 nums = [5, 4] ，乘积为 5 * 4 = 20 。\n可以证明 20 是能得到的最大乘积，所以我们返回 20 。\n存在其他增加 nums 的方法，也能得到最大乘积。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [6,3,3,2], k = 2\n<b>输出：</b>216\n<b>解释：</b>将第二个数增加 1 次，将第四个数增加 1 次。\n得到 nums = [6, 4, 3, 3] ，乘积为 6 * 4 * 3 * 3 = 216 。\n可以证明 216 是能得到的最大乘积，所以我们返回 216 。\n存在其他增加 nums 的方法，也能得到最大乘积。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2234.花园的最大总美丽值",
        "hardRate": "HARD",
        "passRate": "27.91%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-total-beauty-of-the-gardens/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-total-beauty-of-the-gardens/solution",
        "problemsDesc": "<p>Alice 是&nbsp;<code>n</code>&nbsp;个花园的园丁，她想通过种花，最大化她所有花园的总美丽值。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始大小为 <code>n</code>&nbsp;的整数数组&nbsp;<code>flowers</code>&nbsp;，其中&nbsp;<code>flowers[i]</code>&nbsp;是第 <code>i</code>&nbsp;个花园里已经种的花的数目。已经种了的花 <strong>不能</strong>&nbsp;移走。同时给你&nbsp;<code>newFlowers</code>&nbsp;，表示 Alice 额外可以种花的&nbsp;<strong>最大数目</strong>&nbsp;。同时给你的还有整数&nbsp;<code>target</code>&nbsp;，<code>full</code>&nbsp;和&nbsp;<code>partial</code>&nbsp;。</p>\n\n<p>如果一个花园有 <strong>至少</strong>&nbsp;<code>target</code>&nbsp;朵花，那么这个花园称为 <strong>完善的</strong>&nbsp;，花园的 <strong>总美丽值</strong>&nbsp;为以下分数之 <strong>和</strong> ：</p>\n\n<ul>\n\t<li><b>完善</b> 花园数目乘以&nbsp;<code>full</code>.</li>\n\t<li>剩余 <strong>不完善</strong>&nbsp;花园里，花的 <strong>最少数目</strong>&nbsp;乘以&nbsp;<code>partial</code>&nbsp;。如果没有不完善花园，那么这一部分的值为&nbsp;<code>0</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回 Alice 种最多 <code>newFlowers</code>&nbsp;朵花以后，能得到的<strong>&nbsp;最大</strong>&nbsp;总美丽值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1\n<b>输出：</b>14\n<b>解释：</b>Alice 可以按以下方案种花\n- 在第 0 个花园种 2 朵花\n- 在第 1 个花园种 3 朵花\n- 在第 2 个花园种 1 朵花\n- 在第 3 个花园种 1 朵花\n花园里花的数目为 [3,6,2,2] 。总共种了 2 + 3 + 1 + 1 = 7 朵花。\n只有 1 个花园是完善的。\n不完善花园里花的最少数目是 2 。\n所以总美丽值为 1 * 12 + 2 * 1 = 12 + 2 = 14 。\n没有其他方案可以让花园总美丽值超过 14 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6\n<b>输出：</b>30\n<b>解释：</b>Alice 可以按以下方案种花\n- 在第 0 个花园种 3 朵花\n- 在第 1 个花园种 0 朵花\n- 在第 2 个花园种 0 朵花\n- 在第 3 个花园种 2 朵花\n花园里花的数目为 [5,4,5,5] 。总共种了 3 + 0 + 0 + 2 = 5 朵花。\n有 3 个花园是完善的。\n不完善花园里花的最少数目为 4 。\n所以总美丽值为 3 * 2 + 4 * 6 = 6 + 24 = 30 。\n没有其他方案可以让花园总美丽值超过 30 。\n注意，Alice可以让所有花园都变成完善的，但这样她的总美丽值反而更小。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= flowers.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= flowers[i], target &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= newFlowers &lt;= 10<sup>10</sup></code></li>\n\t<li><code>1 &lt;= full, partial &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2235.两整数相加",
        "hardRate": "EASY",
        "passRate": "83.74%",
        "problemsUrl": "https://leetcode.cn/problems/add-two-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/add-two-integers/solution",
        "problemsDesc": "给你两个整数&nbsp;<code>num1</code> 和 <code>num2</code>，返回这两个整数的和。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = 12, num2 = 5\n<strong>输出：</strong>17\n<strong>解释：</strong>num1 是 12，num2 是 5 ，它们的和是 12 + 5 = 17 ，因此返回 17 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = -10, num2 = 4\n<strong>输出：</strong>-6\n<strong>解释：</strong>num1 + num2 = -6 ，因此返回 -6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-100 &lt;= num1, num2 &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2236.判断根结点是否等于子结点之和",
        "hardRate": "EASY",
        "passRate": "85.05%",
        "problemsUrl": "https://leetcode.cn/problems/root-equals-sum-of-children/",
        "solutionsUrl": "https://leetcode.cn/problems/root-equals-sum-of-children/solution",
        "problemsDesc": "<p>给你一个 <strong>二叉树 </strong>的根结点&nbsp;<code>root</code>，该二叉树由恰好&nbsp;<code>3</code>&nbsp;个结点组成：根结点、左子结点和右子结点。</p>\n\n<p>如果根结点值等于两个子结点值之和，返回&nbsp;<code>true</code>&nbsp;，否则返回<em>&nbsp;</em><code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/08/graph3drawio.png\" style=\"width: 281px; height: 199px;\" />\n<pre>\n<strong>输入：</strong>root = [10,4,6]\n<strong>输出：</strong>true\n<strong>解释：</strong>根结点、左子结点和右子结点的值分别是 10 、4 和 6 。\n由于 10 等于 4 + 6 ，因此返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/08/graph3drawio-1.png\" style=\"width: 281px; height: 199px;\" />\n<pre>\n<strong>输入：</strong>root = [5,3,1]\n<strong>输出：</strong>false\n<strong>解释：</strong>根结点、左子结点和右子结点的值分别是 5 、3 和 1 。\n由于 5 不等于 3 + 1 ，因此返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树只包含根结点、左子结点和右子结点</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2237.计算街道上满足所需亮度的位置数量",
        "hardRate": "MEDIUM",
        "passRate": "74.53%",
        "problemsUrl": "https://leetcode.cn/problems/count-positions-on-street-with-required-brightness/",
        "solutionsUrl": "https://leetcode.cn/problems/count-positions-on-street-with-required-brightness/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2238.司机成为乘客的次数",
        "hardRate": "MEDIUM",
        "passRate": "69.96%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-times-a-driver-was-a-passenger/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-times-a-driver-was-a-passenger/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2239.找到最接近 0 的数字",
        "hardRate": "EASY",
        "passRate": "53.50%",
        "problemsUrl": "https://leetcode.cn/problems/find-closest-number-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/find-closest-number-to-zero/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;，请你返回 <code>nums</code>&nbsp;中最 <strong>接近</strong>&nbsp;<code>0</code>&nbsp;的数字。如果有多个答案，请你返回它们中的 <strong>最大值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [-4,-2,1,4,8]\n<b>输出：</b>1\n<strong>解释：</strong>\n-4 到 0 的距离为 |-4| = 4 。\n-2 到 0 的距离为 |-2| = 2 。\n1 到 0 的距离为 |1| = 1 。\n4 到 0 的距离为 |4| = 4 。\n8 到 0 的距离为 |8| = 8 。\n所以，数组中距离 0 最近的数字为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,-1,1]\n<b>输出：</b>1\n<b>解释：</b>1 和 -1 都是距离 0 最近的数字，所以返回较大值 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2240.买钢笔和铅笔的方案数",
        "hardRate": "MEDIUM",
        "passRate": "57.49%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-buy-pens-and-pencils/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-buy-pens-and-pencils/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>total</code>&nbsp;，表示你拥有的总钱数。同时给你两个整数&nbsp;<code>cost1</code> 和&nbsp;<code>cost2</code>&nbsp;，分别表示一支钢笔和一支铅笔的价格。你可以花费你部分或者全部的钱，去买任意数目的两种笔。</p>\n\n<p>请你返回购买钢笔和铅笔的&nbsp;<strong>不同方案数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>total = 20, cost1 = 10, cost2 = 5\n<b>输出：</b>9\n<b>解释：</b>一支钢笔的价格为 10 ，一支铅笔的价格为 5 。\n- 如果你买 0 支钢笔，那么你可以买 0 ，1 ，2 ，3 或者 4 支铅笔。\n- 如果你买 1 支钢笔，那么你可以买 0 ，1 或者 2 支铅笔。\n- 如果你买 2 支钢笔，那么你没法买任何铅笔。\n所以买钢笔和铅笔的总方案数为 5 + 3 + 1 = 9 种。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>total = 5, cost1 = 10, cost2 = 10\n<b>输出：</b>1\n<b>解释：</b>钢笔和铅笔的价格都为 10 ，都比拥有的钱数多，所以你没法购买任何文具。所以只有 1 种方案：买 0 支钢笔和 0 支铅笔。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= total, cost1, cost2 &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2241.设计一个 ATM 机器",
        "hardRate": "MEDIUM",
        "passRate": "36.26%",
        "problemsUrl": "https://leetcode.cn/problems/design-an-atm-machine/",
        "solutionsUrl": "https://leetcode.cn/problems/design-an-atm-machine/solution",
        "problemsDesc": "<p>一个 ATM 机器，存有&nbsp;<code>5</code>&nbsp;种面值的钞票：<code>20</code>&nbsp;，<code>50</code>&nbsp;，<code>100</code>&nbsp;，<code>200</code>&nbsp;和&nbsp;<code>500</code>&nbsp;美元。初始时，ATM 机是空的。用户可以用它存或者取任意数目的钱。</p>\n\n<p>取款时，机器会优先取 <b>较大</b>&nbsp;数额的钱。</p>\n\n<ul>\n\t<li>比方说，你想取&nbsp;<code>$300</code>&nbsp;，并且机器里有&nbsp;<code>2</code>&nbsp;张 <code>$50</code>&nbsp;的钞票，<code>1</code>&nbsp;张&nbsp;<code>$100</code>&nbsp;的钞票和<code>1</code>&nbsp;张&nbsp;<code>$200</code>&nbsp;的钞票，那么机器会取出&nbsp;<code>$100</code> 和&nbsp;<code>$200</code>&nbsp;的钞票。</li>\n\t<li>但是，如果你想取&nbsp;<code>$600</code>&nbsp;，机器里有&nbsp;<code>3</code>&nbsp;张&nbsp;<code>$200</code>&nbsp;的钞票和<code>1</code>&nbsp;张&nbsp;<code>$500</code>&nbsp;的钞票，那么取款请求会被拒绝，因为机器会先取出&nbsp;<code>$500</code>&nbsp;的钞票，然后无法取出剩余的&nbsp;<code>$100</code>&nbsp;。注意，因为有&nbsp;<code>$500</code>&nbsp;钞票的存在，机器&nbsp;<strong>不能</strong>&nbsp;取&nbsp;<code>$200</code>&nbsp;的钞票。</li>\n</ul>\n\n<p>请你实现 ATM 类：</p>\n\n<ul>\n\t<li><code>ATM()</code>&nbsp;初始化 ATM 对象。</li>\n\t<li><code>void deposit(int[] banknotesCount)</code>&nbsp;分别存入&nbsp;<code>$20</code>&nbsp;，<code>$50</code>，<code>$100</code>，<code>$200</code>&nbsp;和&nbsp;<code>$500</code>&nbsp;钞票的数目。</li>\n\t<li><code>int[] withdraw(int amount)</code>&nbsp;返回一个长度为&nbsp;<code>5</code>&nbsp;的数组，分别表示&nbsp;<code>$20</code>&nbsp;，<code>$50</code>，<code>$100</code>&nbsp;，<code>$200</code>&nbsp;和&nbsp;<code>$500</code>&nbsp;钞票的数目，并且更新 ATM 机里取款后钞票的剩余数量。如果无法取出指定数额的钱，请返回&nbsp;<code>[-1]</code>&nbsp;（这种情况下 <strong>不</strong>&nbsp;取出任何钞票）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"ATM\", \"deposit\", \"withdraw\", \"deposit\", \"withdraw\", \"withdraw\"]\n[[], [[0,0,1,2,1]], [600], [[0,1,0,1,1]], [600], [550]]\n<strong>输出：</strong>\n[null, null, [0,0,1,0,1], null, [-1], [0,1,0,0,1]]\n\n<strong>解释：</strong>\nATM atm = new ATM();\natm.deposit([0,0,1,2,1]); // 存入 1 张 $100 ，2 张 $200 和 1 张 $500 的钞票。\natm.withdraw(600);        // 返回 [0,0,1,0,1] 。机器返回 1 张 $100 和 1 张 $500 的钞票。机器里剩余钞票的数量为 [0,0,0,2,0] 。\natm.deposit([0,1,0,1,1]); // 存入 1 张 $50 ，1 张 $200 和 1 张 $500 的钞票。\n                          // 机器中剩余钞票数量为 [0,1,0,3,1] 。\natm.withdraw(600);        // 返回 [-1] 。机器会尝试取出 $500 的钞票，然后无法得到剩余的 $100 ，所以取款请求会被拒绝。\n                          // 由于请求被拒绝，机器中钞票的数量不会发生改变。\natm.withdraw(550);        // 返回 [0,1,0,0,1] ，机器会返回 1 张 $50 的钞票和 1 张 $500 的钞票。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>banknotesCount.length == 5</code></li>\n\t<li><code>0 &lt;= banknotesCount[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= amount &lt;= 10<sup>9</sup></code></li>\n\t<li><strong>总共</strong>&nbsp;最多有&nbsp;<code>5000</code>&nbsp;次&nbsp;<code>withdraw</code> 和&nbsp;<code>deposit</code>&nbsp;的调用。</li>\n\t<li><span style=\"\">函数 </span><code>withdraw</code> 和&nbsp;<code>deposit</code>&nbsp;至少各有 <strong>一次&nbsp;</strong>调用。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2242.节点序列的最大得分",
        "hardRate": "HARD",
        "passRate": "34.09%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-of-a-node-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-of-a-node-sequence/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>n</code>&nbsp;个节点的&nbsp;<strong>无向图</strong>&nbsp;，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>scores</code>&nbsp;，其中&nbsp;<code>scores[i]</code>&nbsp;是第 <code>i</code>&nbsp;个节点的分数。同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;，表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条&nbsp;<strong>无向</strong>&nbsp;边。</p>\n\n<p>一个合法的节点序列如果满足以下条件，我们称它是 <strong>合法的</strong>&nbsp;：</p>\n\n<ul>\n\t<li>序列中每&nbsp;<b>相邻</b>&nbsp;节点之间有边相连。</li>\n\t<li>序列中没有节点出现超过一次。</li>\n</ul>\n\n<p>节点序列的分数定义为序列中节点分数之 <strong>和</strong> 。</p>\n\n<p>请你返回一个长度为 <code>4</code>&nbsp;的合法节点序列的最大分数。如果不存在这样的序列，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/15/ex1new3.png\" style=\"width: 290px; height: 215px;\" /></p>\n\n<pre>\n<b>输入：</b>scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\n<b>输出：</b>24\n<b>解释：</b>上图为输入的图，节点序列为 [0,1,2,3] 。\n节点序列的分数为 5 + 2 + 9 + 8 = 24 。\n观察可知，没有其他节点序列得分和超过 24 。\n注意节点序列 [3,1,2,0] 和 [1,0,2,3] 也是合法的，且分数为 24 。\n序列 [0,3,2,4] 不是合法的，因为没有边连接节点 0 和 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/17/ex2.png\" style=\"width: 333px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]\n<b>输出：</b>-1\n<b>解释：</b>上图为输入的图。\n没有长度为 4 的合法序列，所以我们返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == scores.length</code></li>\n\t<li><code>4 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= scores[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>不会有重边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2243.计算字符串的数字和",
        "hardRate": "EASY",
        "passRate": "63.44%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-digit-sum-of-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-digit-sum-of-a-string/solution",
        "problemsDesc": "<p>给你一个由若干数字（<code>0</code> - <code>9</code>）组成的字符串 <code>s</code> ，和一个整数。</p>\n\n<p>如果 <code>s</code> 的长度大于 <code>k</code> ，则可以执行一轮操作。在一轮操作中，需要完成以下工作：</p>\n\n<ol>\n\t<li>将 <code>s</code> <strong>拆分 </strong>成长度为 <code>k</code> 的若干 <strong>连续数字组</strong> ，使得前 <code>k</code> 个字符都分在第一组，接下来的 <code>k</code> 个字符都分在第二组，依此类推。<strong>注意</strong>，最后一个数字组的长度可以小于 <code>k</code> 。</li>\n\t<li>用表示每个数字组中所有数字之和的字符串来 <strong>替换</strong> 对应的数字组。例如，<code>\"346\"</code> 会替换为 <code>\"13\"</code> ，因为 <code>3 + 4 + 6 = 13</code> 。</li>\n\t<li><strong>合并</strong> 所有组以形成一个新字符串。如果新字符串的长度大于 <code>k</code> 则重复第一步。</li>\n</ol>\n\n<p>返回在完成所有轮操作后的 <code>s</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"11111222223\", k = 3\n<strong>输出：</strong>\"135\"\n<strong>解释：</strong>\n- 第一轮，将 s 分成：\"111\"、\"112\"、\"222\" 和 \"23\" 。\n  接着，计算每一组的数字和：1 + 1 + 1 = 3、1 + 1 + 2 = 4、2 + 2 + 2 = 6 和 2 + 3 = 5 。 \n&nbsp; 这样，s 在第一轮之后变成 \"3\" + \"4\" + \"6\" + \"5\" = \"3465\" 。\n- 第二轮，将 s 分成：\"346\" 和 \"5\" 。\n&nbsp; 接着，计算每一组的数字和：3 + 4 + 6 = 13 、5 = 5 。\n&nbsp; 这样，s 在第二轮之后变成 \"13\" + \"5\" = \"135\" 。 \n现在，s.length &lt;= k ，所以返回 \"135\" 作为答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"00000000\", k = 3\n<strong>输出：</strong>\"000\"\n<strong>解释：</strong>\n将 \"000\", \"000\", and \"00\".\n接着，计算每一组的数字和：0 + 0 + 0 = 0 、0 + 0 + 0 = 0 和 0 + 0 = 0 。 \ns 变为 \"0\" + \"0\" + \"0\" = \"000\" ，其长度等于 k ，所以返回 \"000\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>2 &lt;= k &lt;= 100</code></li>\n\t<li><code>s</code> 仅由数字（<code>0</code> - <code>9</code>）组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2244.完成所有任务需要的最少轮数",
        "hardRate": "MEDIUM",
        "passRate": "57.18%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-rounds-to-complete-all-tasks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-rounds-to-complete-all-tasks/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>tasks</code> ，其中 <code>tasks[i]</code> 表示任务的难度级别。在每一轮中，你可以完成 2 个或者 3 个 <strong>相同难度级别</strong> 的任务。</p>\n\n<p>返回完成所有任务需要的 <strong>最少</strong> 轮数，如果无法完成所有任务，返回<em> </em><code>-1</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>tasks = [2,2,3,3,2,4,4,4,4,4]\n<strong>输出：</strong>4\n<strong>解释：</strong>要想完成所有任务，一个可能的计划是：\n- 第一轮，完成难度级别为 2 的 3 个任务。 \n- 第二轮，完成难度级别为 3 的 2 个任务。 \n- 第三轮，完成难度级别为 4 的 3 个任务。 \n- 第四轮，完成难度级别为 4 的 2 个任务。 \n可以证明，无法在少于 4 轮的情况下完成所有任务，所以答案为 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>tasks = [2,3,3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>难度级别为 2 的任务只有 1 个，但每一轮执行中，只能选择完成 2 个或者 3 个相同难度级别的任务。因此，无法完成所有任务，答案为 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= tasks[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2245.转角路径的乘积中最多能有几个尾随零",
        "hardRate": "MEDIUM",
        "passRate": "36.13%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-trailing-zeros-in-a-cornered-path/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-trailing-zeros-in-a-cornered-path/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>grid</code> ，大小为 <code>m x n</code>，其中每个单元格都含一个正整数。</p>\n\n<p><strong>转角路径</strong> 定义为：包含至多一个弯的一组相邻单元。具体而言，路径应该完全 <strong>向水平方向</strong> 或者 <strong>向竖直方向</strong> 移动过弯（如果存在弯），而不能访问之前访问过的单元格。在过弯之后，路径应当完全朝 <strong>另一个</strong> 方向行进：如果之前是向水平方向，那么就应该变为向竖直方向；反之亦然。当然，同样不能访问之前已经访问过的单元格。</p>\n\n<p>一条路径的 <strong>乘积</strong> 定义为：路径上所有值的乘积。</p>\n\n<p>请你从 <code>grid</code> 中找出一条乘积中尾随零数目最多的转角路径，并返回该路径中尾随零的数目。</p>\n\n<p>注意：</p>\n\n<ul>\n\t<li><strong>水平</strong> 移动是指向左或右移动。</li>\n\t<li><strong>竖直 </strong>移动是指向上或下移动。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/23/ex1new2.jpg\" style=\"width: 577px; height: 190px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]\n<strong>输出：</strong>3\n<strong>解释：</strong>左侧的图展示了一条有效的转角路径。\n其乘积为 15 * 20 * 6 * 1 * 10 = 18000 ，共计 3 个尾随零。\n可以证明在这条转角路径的乘积中尾随零数目最多。\n\n中间的图不是一条有效的转角路径，因为它有不止一个弯。\n右侧的图也不是一条有效的转角路径，因为它需要重复访问已经访问过的单元格。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/25/ex2.jpg\" style=\"width: 150px; height: 157px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[4,3,2],[7,6,1],[8,8,8]]\n<strong>输出：</strong>0\n<strong>解释：</strong>网格如上图所示。\n不存在乘积含尾随零的转角路径。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2246.相邻字符不同的最长路径",
        "hardRate": "HARD",
        "passRate": "47.14%",
        "problemsUrl": "https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/solution",
        "problemsDesc": "<p>给你一棵 <strong>树</strong>（即一个连通、无向、无环图），根节点是节点 <code>0</code> ，这棵树由编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个节点组成。用下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>parent</code> 来表示这棵树，其中 <code>parent[i]</code> 是节点 <code>i</code> 的父节点，由于节点 <code>0</code> 是根节点，所以 <code>parent[0] == -1</code> 。</p>\n\n<p>另给你一个字符串 <code>s</code> ，长度也是 <code>n</code> ，其中 <code>s[i]</code> 表示分配给节点 <code>i</code> 的字符。</p>\n\n<p>请你找出路径上任意一对相邻节点都没有分配到相同字符的 <strong>最长路径</strong> ，并返回该路径的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/25/testingdrawio.png\" style=\"width: 201px; height: 241px;\" /></p>\n\n<pre>\n<strong>输入：</strong>parent = [-1,0,0,1,1,2], s = \"abacbe\"\n<strong>输出：</strong>3\n<strong>解释：</strong>任意一对相邻节点字符都不同的最长路径是：0 -&gt; 1 -&gt; 3 。该路径的长度是 3 ，所以返回 3 。\n可以证明不存在满足上述条件且比 3 更长的路径。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/25/graph2drawio.png\" style=\"width: 201px; height: 221px;\" /></p>\n\n<pre>\n<strong>输入：</strong>parent = [-1,0,0,0], s = \"aabc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>任意一对相邻节点字符都不同的最长路径是：2 -&gt; 0 -&gt; 3 。该路径的长度为 3 ，所以返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == parent.length == s.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li>对所有 <code>i &gt;= 1</code> ，<code>0 &lt;= parent[i] &lt;= n - 1</code> 均成立</li>\n\t<li><code>parent[0] == -1</code></li>\n\t<li><code>parent</code> 表示一棵有效的树</li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2247.K 条高速公路的最大旅行费用",
        "hardRate": "HARD",
        "passRate": "56.67%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-cost-of-trip-with-k-highways/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-cost-of-trip-with-k-highways/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2248.多个数组求交集",
        "hardRate": "EASY",
        "passRate": "67.11%",
        "problemsUrl": "https://leetcode.cn/problems/intersection-of-multiple-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/intersection-of-multiple-arrays/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 是由 <strong>不同</strong> 正整数组成的一个非空数组，按 <strong>升序排列</strong> 返回一个数组，数组中的每个元素在 <code>nums</code>&nbsp;<strong>所有数组</strong> 中都出现过。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[<em><strong>3</strong></em>,1,2,<em><strong>4</strong></em>,5],[1,2,<em><strong>3</strong></em>,<em><strong>4</strong></em>],[<em><strong>3</strong></em>,<em><strong>4</strong></em>,5,6]]\n<strong>输出：</strong>[3,4]\n<strong>解释：</strong>\nnums[0] = [<em><strong>3</strong></em>,1,2,<em><strong>4</strong></em>,5]，nums[1] = [1,2,<em><strong>3</strong></em>,<em><strong>4</strong></em>]，nums[2] = [<em><strong>3</strong></em>,<em><strong>4</strong></em>,5,6]，在 nums 中每个数组中都出现的数字是 3 和 4 ，所以返回 [3,4] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[1,2,3],[4,5,6]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>\n不存在同时出现在 nums[0] 和 nums[1] 的整数，所以返回一个空列表 [] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= sum(nums[i].length) &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i][j] &lt;= 1000</code></li>\n\t<li><code>nums[i]</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2249.统计圆内格点数目",
        "hardRate": "MEDIUM",
        "passRate": "53.34%",
        "problemsUrl": "https://leetcode.cn/problems/count-lattice-points-inside-a-circle/",
        "solutionsUrl": "https://leetcode.cn/problems/count-lattice-points-inside-a-circle/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>circles</code> ，其中 <code>circles[i] = [x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub>]</code> 表示网格上圆心为 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> 且半径为 <code>r<sub>i</sub></code> 的第 <code>i</code> 个圆，返回出现在<strong> 至少一个 </strong>圆内的 <strong>格点数目</strong> 。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><strong>格点</strong> 是指整数坐标对应的点。</li>\n\t<li><strong>圆周上的点</strong> 也被视为出现在圆内的点。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/exa-11.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>circles = [[2,2,1]]\n<strong>输出：</strong>5\n<strong>解释：</strong>\n给定的圆如上图所示。\n出现在圆内的格点为 (1, 2)、(2, 1)、(2, 2)、(2, 3) 和 (3, 2)，在图中用绿色标识。\n像 (1, 1) 和 (1, 3) 这样用红色标识的点，并未出现在圆内。\n因此，出现在至少一个圆内的格点数目是 5 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/exa-22.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>circles = [[2,2,2],[3,4,1]]\n<strong>输出：</strong>16\n<strong>解释：</strong>\n给定的圆如上图所示。\n共有 16 个格点出现在至少一个圆内。\n其中部分点的坐标是 (0, 2)、(2, 0)、(2, 4)、(3, 2) 和 (4, 4) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= circles.length &lt;= 200</code></li>\n\t<li><code>circles[i].length == 3</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 100</code></li>\n\t<li><code>1 &lt;= r<sub>i</sub> &lt;= min(x<sub>i</sub>, y<sub>i</sub>)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2250.统计包含每个点的矩形数目",
        "hardRate": "MEDIUM",
        "passRate": "34.93%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-rectangles-containing-each-point/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-rectangles-containing-each-point/solution",
        "problemsDesc": "<p>给你一个二维整数数组&nbsp;<code>rectangles</code>&nbsp;，其中&nbsp;<code>rectangles[i] = [l<sub>i</sub>, h<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个矩形长为&nbsp;<code>l<sub>i</sub></code>&nbsp;高为&nbsp;<code>h<sub>i</sub></code>&nbsp;。给你一个二维整数数组&nbsp;<code>points</code>&nbsp;，其中&nbsp;<code>points[j] = [x<sub>j</sub>, y<sub>j</sub>]</code>&nbsp;是坐标为&nbsp;<code>(x<sub>j</sub>, y<sub>j</sub>)</code>&nbsp;的一个点。</p>\n\n<p>第&nbsp;<code>i</code>&nbsp;个矩形的 <strong>左下角</strong>&nbsp;在&nbsp;<code>(0, 0)</code>&nbsp;处，<strong>右上角</strong>&nbsp;在&nbsp;<code>(l<sub>i</sub>, h<sub>i</sub>)</code>&nbsp;。</p>\n\n<p>请你返回一个整数数组<em>&nbsp;</em><code>count</code>&nbsp;，长度为&nbsp;<code>points.length</code>，其中<em>&nbsp;</em><code>count[j]</code>是 <strong>包含</strong> 第<em>&nbsp;</em><code>j</code>&nbsp;个点的矩形数目。</p>\n\n<p>如果&nbsp;<code>0 &lt;= x<sub>j</sub> &lt;= l<sub>i</sub></code> 且&nbsp;<code>0 &lt;= y<sub>j</sub> &lt;= h<sub>i</sub></code>&nbsp;，那么我们说第&nbsp;<code>i</code>&nbsp;个矩形包含第&nbsp;<code>j</code>&nbsp;个点。如果一个点刚好在矩形的 <strong>边上</strong>&nbsp;，这个点也被视为被矩形包含。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/example1.png\" style=\"width: 300px; height: 509px;\"></p>\n\n<pre><b>输入：</b>rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]\n<b>输出：</b>[2,1]\n<b>解释：</b>\n第一个矩形不包含任何点。\n第二个矩形只包含一个点 (2, 1) 。\n第三个矩形包含点 (2, 1) 和 (1, 4) 。\n包含点 (2, 1) 的矩形数目为 2 。\n包含点 (1, 4) 的矩形数目为 1 。\n所以，我们返回 [2, 1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/example2.png\" style=\"width: 300px; height: 312px;\"></p>\n\n<pre><b>输入：</b>rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]\n<b>输出：</b>[1,3]\n<strong>解释：\n</strong>第一个矩形只包含点 (1, 1) 。\n第二个矩形只包含点 (1, 1) 。\n第三个矩形包含点 (1, 3) 和 (1, 1) 。\n包含点 (1, 3) 的矩形数目为 1 。\n包含点 (1, 1) 的矩形数目为 3 。\n所以，我们返回 [1, 3] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rectangles.length, points.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>rectangles[i].length == points[j].length == 2</code></li>\n\t<li><code>1 &lt;= l<sub>i</sub>, x<sub>j</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= h<sub>i</sub>, y<sub>j</sub> &lt;= 100</code></li>\n\t<li>所有&nbsp;<code>rectangles</code>&nbsp;<strong>互不相同</strong>&nbsp;。</li>\n\t<li>所有&nbsp;<code>points</code> <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    }
]